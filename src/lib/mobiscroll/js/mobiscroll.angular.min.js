/* eslint-disable */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular/forms')) :
  typeof define === 'function' && define.amd ? define(['exports', '@angular/core', '@angular/common', '@angular/forms'], factory) :
  (global = global || self, factory(global.mobiscroll = {}, global.angularCore, global.angularCommon, global.angularForms));
}(this, (function (exports, core, common, forms) { 'use strict';

  /* eslint-disable */

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */

  /* global Reflect, Promise */
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  function __extends(d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  var mobiscroll = mobiscroll || {},
      util = {},
      calendars = {};

  var os,
      vers,
      majorVersion,
      minorVersion,
      version = [],
      isBrowser = typeof window !== 'undefined',
      isDark = isBrowser && window.matchMedia && window.matchMedia('(prefers-color-scheme:dark)').matches,
      userAgent = isBrowser ? navigator.userAgent : '',
      platform = isBrowser ? navigator.platform : '',
      maxTouchPoints = isBrowser ? navigator.maxTouchPoints : 0,
      isSafari = /Safari/.test(userAgent),
      device = userAgent.match(/Android|iPhone|iPad|iPod|Windows Phone|Windows|MSIE/i),
      raf = isBrowser && window.requestAnimationFrame || function (func) {
    return setTimeout(func, 20);
  },
      rafc = isBrowser && window.cancelAnimationFrame || function (id) {
    clearTimeout(id);
  };

  if (/Android/i.test(device)) {
    os = 'android';
    vers = userAgent.match(/Android\s+([\d.]+)/i);

    if (vers) {
      version = vers[0].replace('Android ', '').split('.');
    }
  } else if (/iPhone|iPad|iPod/i.test(device) || /iPhone|iPad|iPod/i.test(platform) || platform === 'MacIntel' && maxTouchPoints > 1) {
    // On iPad with iOS 13 desktop site request is automatically enabled in Safari,
    // so 'iPad' is no longer present in the user agent string.
    // In this case we check `navigator.platform` and `navigator.maxTouchPoints`.
    // maxTouchPoints is needed to exclude desktop Mac OS X.
    os = 'ios';
    vers = userAgent.match(/OS\s+([\d_]+)/i);

    if (vers) {
      version = vers[0].replace(/_/g, '.').replace('OS ', '').split('.');
    }
  } else if (/Windows Phone/i.test(device)) {
    os = 'wp';
  } else if (/Windows|MSIE/i.test(device)) {
    os = 'windows';
  }

  majorVersion = version[0];
  minorVersion = version[1];

  function testProps(props) {
    var i;

    for (i in props) {
      if (mod[props[i]] !== undefined) {
        return true;
      }
    }

    return false;
  }

  function testPrefix() {
    var prefixes = ['Webkit', 'Moz', 'O', 'ms'],
        p;

    for (p in prefixes) {
      if (testProps([prefixes[p] + 'Transform'])) {
        return '-' + prefixes[p].toLowerCase() + '-';
      }
    }

    return '';
  }

  function testTouch(e, elm) {
    if (e.type == 'touchstart') {
      elm.__mbscTouched = 1;
    } else if (elm.__mbscTouched) {
      delete elm.__mbscTouched;
      return false;
    }

    return true;
  }

  function getPosition(t, vertical) {
    var prefixes = ['t', 'webkitT', 'MozT', 'OT', 'msT'],
        style = getComputedStyle(t[0]),
        i = 0,
        matrix,
        px,
        v;

    while (!matrix && i < prefixes.length) {
      v = prefixes[i];

      if (style[v + 'ransform'] !== undefined) {
        matrix = style[v + 'ransform'];
      }

      i++;
    }

    matrix = matrix.split(')')[0].split(', ');
    px = vertical ? matrix[13] || matrix[5] : matrix[12] || matrix[4];
    return px;
  }

  function getTextColor(color) {
    if (color) {
      // Cache calculated text colors, because it is slow
      if (textColors[color]) {
        return textColors[color];
      }

      var ctx = canvas && canvas.getContext('2d');

      if (!ctx) {
        return '#fff';
      } // Use canvas element, since it does not require DOM append


      ctx.fillStyle = color;
      ctx.fillRect(0, 0, 1, 1);
      var rgb = ctx.getImageData(0, 0, 1, 1).data;
      var delta = +rgb[0] * 0.299 + +rgb[1] * 0.587 + +rgb[2] * 0.114;
      var textColor = delta < 130 ? '#fff' : '#000';
      textColors[color] = textColor;
      return textColor;
    }
  }

  function scrollStep(el, startTime, from, to, callback) {
    var elapsed = Math.min(1, (new Date() - startTime) / 468),
        eased = 0.5 * (1 - Math.cos(Math.PI * elapsed)),
        current = from + (to - from) * eased;
    el.scrollTop = current;

    if (current !== to) {
      raf(function () {
        scrollStep(el, startTime, from, to, callback);
      });
    } else if (callback) {
      callback();
    }
  }

  function smoothScroll(el, to, prevAnim, callback) {
    if (prevAnim) {
      el.scrollTop = to;

      if (callback) {
        callback();
      }
    } else {
      scrollStep(el, new Date(), el.scrollTop, to, callback);
    }
  }

  function listen(el, event, handler, opt) {
    if (el) {
      el.addEventListener(event, handler, opt);
    }
  }

  function unlisten(el, event, handler, opt) {
    if (el) {
      el.removeEventListener(event, handler, opt);
    }
  }

  function matches(element, selector) {
    if (!selector || !element || element.nodeType !== 1) {
      return false;
    }

    var matchesSelector = element.matches || element.matchesSelector || element.webkitMatchesSelector || element.mozMatchesSelector || element.msMatchesSelector;
    return matchesSelector.call(element, selector);
  }

  function closest(el, target, selector) {
    while (target) {
      if (matches(target, selector)) {
        return target;
      }

      target = target !== el ? target.parentNode : null;
    }

    return null;
  }

  function trigger(elm, name, data) {
    var evt;

    try {
      evt = new CustomEvent(name, {
        detail: data,
        bubbles: true,
        cancelable: true
      });
    } catch (e) {
      evt = document.createEvent('Event');
      evt.initEvent(name, true, true);
      evt.detail = data;
    }

    elm.dispatchEvent(evt);
  }

  function setFocusInvisible() {
    win.__mbscFocusVisible = false;
  }

  function setFocusVisible() {
    win.__mbscFocusVisible = true;
  }

  function addWindowFocus() {
    var focusCount = win.__mbscFocusCount || 0;

    if (focusCount === 0) {
      listen(win, 'mousedown', setFocusInvisible, true);
      listen(win, 'keydown', setFocusVisible, true);
    }

    win.__mbscFocusCount = ++focusCount;
  }

  function removeWindowFocus() {
    var focusCount = win.__mbscFocusCount || 0;
    win.__mbscFocusCount = --focusCount;

    if (win.__mbscFocusCount === 0) {
      unlisten(win, 'mousedown', setFocusInvisible);
      unlisten(win, 'keydown', setFocusVisible);
    }
  }

  var animEnd,
      canvas,
      mod,
      cssPrefix,
      hasGhostClick,
      hasTransition,
      isWebView,
      isWkWebView,
      jsPrefix,
      win,
      textColors = {};

  if (isBrowser) {
    win = window;
    canvas = document.createElement('canvas');
    mod = document.createElement('modernizr').style;
    cssPrefix = testPrefix();
    jsPrefix = cssPrefix.replace(/^-/, '').replace(/-$/, '').replace('moz', 'Moz');
    animEnd = mod.animation !== undefined ? 'animationend' : 'webkitAnimationEnd';
    hasTransition = mod.transition !== undefined; // UIWebView on iOS still has the ghost click, 
    // WkWebView does not have a ghost click, but it's hard to tell if it's UIWebView or WkWebView
    // In addition in iOS 12.2 if we enable tap handling, it brakes the form inputs
    // (keyboard appears, but the cursor is not in the input).

    isWebView = os === 'ios' && !isSafari;
    isWkWebView = isWebView && win.webkit && win.webkit.messageHandlers;
    hasGhostClick = mod.touchAction === undefined || isWebView && !isWkWebView;
  }

  var cssNumber = {
    'column-count': 1,
    'columns': 1,
    'font-weight': 1,
    'line-height': 1,
    'opacity': 1,
    'z-index': 1,
    'zoom': 1
  },
      propMap = {
    'readonly': 'readOnly'
  },
      emptyArray = [],
      _slice = Array.prototype.slice;

  function isFunction(value) {
    return typeof value === "function";
  }

  function isObject(obj) {
    return typeof obj === "object";
  }

  function likeArray(obj) {
    return typeof obj.length == 'number';
  }

  function camelize(str) {
    return str.replace(/-+(.)?/g, function (match, chr) {
      return chr ? chr.toUpperCase() : '';
    });
  }

  function extend(target, source, deep) {
    for (var key in source) {
      if (deep && ($.isPlainObject(source[key]) || $.isArray(source[key]))) {
        if ($.isPlainObject(source[key]) && !$.isPlainObject(target[key]) || $.isArray(source[key]) && !$.isArray(target[key])) {
          target[key] = {};
        }

        extend(target[key], source[key], deep);
      } else if (source[key] !== undefined) {
        target[key] = source[key];
      }
    }
  }

  function dasherize(str) {
    return str.replace(/::/g, '/').replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2').replace(/([a-z\d])([A-Z])/g, '$1_$2').replace(/_/g, '-').toLowerCase();
  }

  function maybeAddPx(name, value) {
    return typeof value == "number" && !cssNumber[dasherize(name)] ? value + "px" : value;
  }

  var Dom = function () {
    var Dom = function Dom(arr) {
      var _this = this,
          i = 0; // Create array-like object


      for (i = 0; i < arr.length; i++) {
        _this[i] = arr[i];
      }

      _this.length = arr.length; // Return collection with methods

      return $(this);
    };

    var $ = function $(selector, context) {
      var arr = [],
          i = 0;

      if (selector && !context) {
        if (selector instanceof Dom) {
          return selector;
        }
      }

      if (isFunction(selector)) {
        return $(document).ready(selector);
      }

      if (selector) {
        // String
        if (typeof selector === 'string') {
          var els, tempParent, html;
          selector = html = selector.trim();

          if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
            var toCreate = 'div';

            if (html.indexOf('<li') === 0) {
              toCreate = 'ul';
            }

            if (html.indexOf('<tr') === 0) {
              toCreate = 'tbody';
            }

            if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) {
              toCreate = 'tr';
            }

            if (html.indexOf('<tbody') === 0) {
              toCreate = 'table';
            }

            if (html.indexOf('<option') === 0) {
              toCreate = 'select';
            }

            tempParent = document.createElement(toCreate);
            tempParent.innerHTML = html;

            for (i = 0; i < tempParent.childNodes.length; i++) {
              arr.push(tempParent.childNodes[i]);
            }
          } else {
            if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
              // Pure ID selector
              els = [document.getElementById(selector.split('#')[1])];
            } else {
              if (context instanceof Dom) {
                context = context[0];
              } // Other selectors


              els = (context || document).querySelectorAll(selector);
            }

            for (i = 0; i < els.length; i++) {
              if (els[i]) {
                arr.push(els[i]);
              }
            }
          }
        } // Node/element
        else if (selector.nodeType || selector === window || selector === document) {
            arr.push(selector);
          } //Array of elements or instance of Dom
          else if (selector.length > 0 && selector[0].nodeType) {
              for (i = 0; i < selector.length; i++) {
                arr.push(selector[i]);
              }
            } else if ($.isArray(selector)) {
              arr = selector;
            }
      }

      return new Dom(arr);
    };

    Dom.prototype = {
      ready: function ready(callback) {
        if (document.attachEvent ? document.readyState == 'complete' : document.readyState != 'loading') {
          callback($);
        } else {
          document.addEventListener('DOMContentLoaded', function () {
            callback($);
          }, false);
        }

        return this;
      },
      concat: emptyArray.concat,
      empty: function empty() {
        return this.each(function () {
          this.innerHTML = '';
        });
      },
      map: function map(fn) {
        return $($.map(this, function (el, i) {
          return fn.call(el, i, el);
        }));
      },
      slice: function slice() {
        return $(_slice.apply(this, arguments));
      },
      // Classes and attriutes
      // NOTE: element.classList attribure is not supported on android 2.3!!!
      addClass: function addClass(className) {
        if (typeof className === 'undefined') {
          return this;
        }

        var classes = className.split(' ');

        for (var i = 0; i < classes.length; i++) {
          for (var j = 0; j < this.length; j++) {
            if (typeof this[j].classList !== 'undefined' && classes[i] !== '') {
              this[j].classList.add(classes[i]);
            }
          }
        }

        return this;
      },
      removeClass: function removeClass(className) {
        if (typeof className === 'undefined') {
          return this;
        }

        var classes = className.split(' ');

        for (var i = 0; i < classes.length; i++) {
          for (var j = 0; j < this.length; j++) {
            if (typeof this[j].classList !== 'undefined' && classes[i] !== '') {
              this[j].classList.remove(classes[i]);
            }
          }
        }

        return this;
      },
      hasClass: function hasClass(className) {
        return this[0] ? this[0].classList.contains(className) : false;
      },
      toggleClass: function toggleClass(className) {
        var classes = className.split(' ');

        for (var i = 0; i < classes.length; i++) {
          for (var j = 0; j < this.length; j++) {
            if (typeof this[j].classList !== 'undefined') {
              this[j].classList.toggle(classes[i]);
            }
          }
        }

        return this;
      },
      closest: function closest(selector, context) {
        var node = this[0],
            collection = false;

        if (isObject(selector)) {
          collection = $(selector);
        }

        while (node && !(collection ? collection.indexOf(node) >= 0 : matches(node, selector))) {
          node = node !== context && node.nodeType !== node.DOCUMENT_NODE && node.parentNode;
        }

        return $(node);
      },
      attr: function attr(attrs, value) {
        var attr;

        if (arguments.length === 1 && typeof attrs === 'string') {
          // Get attr
          if (this.length) {
            attr = this[0].getAttribute(attrs);
            return attr || attr === '' ? attr : undefined;
          }
        } else {
          // Set attrs
          for (var i = 0; i < this.length; i++) {
            if (arguments.length === 2) {
              // String
              this[i].setAttribute(attrs, value);
            } else {
              // Object
              for (var attrName in attrs) {
                this[i][attrName] = attrs[attrName];
                this[i].setAttribute(attrName, attrs[attrName]);
              }
            }
          }

          return this;
        }
      },
      removeAttr: function removeAttr(attr) {
        for (var i = 0; i < this.length; i++) {
          this[i].removeAttribute(attr);
        }

        return this;
      },
      prop: function prop(props, value) {
        props = propMap[props] || props;

        if (arguments.length === 1 && typeof props === 'string') {
          // Get prop
          return this[0] ? this[0][props] : undefined;
        } else {
          // Set props
          for (var i = 0; i < this.length; i++) {
            this[i][props] = value;
          }

          return this;
        }
      },
      val: function val(value) {
        if (typeof value === 'undefined') {
          if (this.length && this[0].multiple) {
            return $.map(this.find('option:checked'), function (v) {
              return v.value;
            });
          }

          return this[0] ? this[0].value : undefined;
        }

        if (this.length && this[0].multiple) {
          $.each(this[0].options, function () {
            this.selected = value.indexOf(this.value) != -1;
          });
        } else {
          for (var i = 0; i < this.length; i++) {
            this[i].value = value;
          }
        }

        return this;
      },
      //Events
      on: function on(eventName, targetSelector, listener, capture) {
        var boundListener,
            elm,
            event,
            events = eventName.split(' '),
            i,
            j;

        function handleLiveEvent(e) {
          var target = e.target;

          while (target) {
            if ($(target).is(targetSelector)) {
              listener.call(target, e);
            }

            target = target !== this ? target.parentNode : null;
          }
        }

        function handleNamespaces(el, name, listener, capture) {
          var namespace = name.split('.');

          if (!el.DomNameSpaces) {
            el.DomNameSpaces = [];
          }

          el.DomNameSpaces.push({
            namespace: namespace[1],
            event: namespace[0],
            listener: listener,
            capture: capture
          });
          el.addEventListener(namespace[0], listener, capture);
        }

        for (i = 0; i < this.length; i++) {
          elm = this[i];

          if (isFunction(targetSelector) || targetSelector === false) {
            // Usual events
            if (isFunction(targetSelector)) {
              capture = listener || false;
              listener = targetSelector;
            }

            for (j = 0; j < events.length; j++) {
              event = events[j]; // check for namespaces

              if (event.indexOf('.') != -1) {
                handleNamespaces(elm, event, listener, capture);
              } else {
                elm.addEventListener(event, listener, capture);
              }
            }
          } else {
            // Live events
            boundListener = handleLiveEvent.bind(elm);

            for (j = 0; j < events.length; j++) {
              event = events[j];

              if (!elm.DomLiveListeners) {
                elm.DomLiveListeners = [];
              }

              elm.DomLiveListeners.push({
                listener: listener,
                liveListener: boundListener
              });

              if (event.indexOf('.') != -1) {
                handleNamespaces(elm, event, boundListener, capture);
              } else {
                elm.addEventListener(event, boundListener, capture);
              }
            }
          }
        }

        return this;
      },
      off: function off(eventName, targetSelector, listener, capture) {
        var elm,
            event,
            events,
            i,
            j,
            k,
            liveListeners,
            that = this;

        function removeEvents(event) {
          var el,
              i,
              j,
              item,
              nameSpaces,
              parts = event.split('.'),
              name = parts[0],
              ns = parts[1];

          for (i = 0; i < that.length; ++i) {
            el = that[i];
            nameSpaces = el.DomNameSpaces;

            if (nameSpaces) {
              for (j = 0; j < nameSpaces.length; ++j) {
                item = nameSpaces[j];

                if (item.namespace == ns && (item.event == name || !name)) {
                  el.removeEventListener(item.event, item.listener, item.capture);
                  item.removed = true;
                }
              } // remove the events from the DomNameSpaces array


              for (j = nameSpaces.length - 1; j >= 0; --j) {
                if (nameSpaces[j].removed) {
                  nameSpaces.splice(j, 1);
                }
              }
            }
          }
        }

        events = eventName.split(' ');

        for (i = 0; i < events.length; i++) {
          event = events[i];

          for (j = 0; j < this.length; j++) {
            elm = this[j];
            liveListeners = elm.DomLiveListeners;

            if (isFunction(targetSelector) || targetSelector === false) {
              // Usual events
              if (isFunction(targetSelector)) {
                capture = listener || false;
                listener = targetSelector;
              }

              if (event.indexOf('.') === 0) {
                // remove namespace events
                removeEvents(event.substr(1));
              } else {
                elm.removeEventListener(event, listener, capture);
              }
            } else {
              // Live event
              if (liveListeners) {
                for (k = 0; k < liveListeners.length; k++) {
                  if (liveListeners[k].listener === listener) {
                    elm.removeEventListener(event, liveListeners[k].liveListener, capture);
                  }
                }
              }

              if (elm.DomNameSpaces && elm.DomNameSpaces.length && event) {
                removeEvents(event);
              }
            }
          }
        }

        return this;
      },
      trigger: function trigger$1(eventName, eventData) {
        var events = eventName.split(' ');

        for (var i = 0; i < events.length; i++) {
          for (var j = 0; j < this.length; j++) {
            trigger(this[j], events[i], eventData);
          }
        }

        return this;
      },
      // Sizing/Styles
      width: function width(dim) {
        if (dim !== undefined) {
          return this.css('width', dim);
        }

        if (this[0] === window) {
          return window.innerWidth;
        } else if (this[0] === document) {
          return document.documentElement.scrollWidth;
        } else {
          return this.length > 0 ? parseFloat(this.css('width')) : null;
        }
      },
      height: function height(dim) {
        if (dim !== undefined) {
          return this.css('height', dim);
        }

        if (this[0] === window) {
          return window.innerHeight;
        } else if (this[0] === document) {
          var body = document.body,
              html = document.documentElement;
          return Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
        } else {
          return this.length > 0 ? parseFloat(this.css('height')) : null;
        }
      },
      innerWidth: function innerWidth() {
        var elm = this;

        if (this.length > 0) {
          if (this[0].innerWidth) {
            return this[0].innerWidth;
          } else {
            var size = this[0].offsetWidth,
                sides = ['left', 'right'];
            sides.forEach(function (side) {
              size -= parseInt(elm.css(camelize('border-' + side + '-width')) || 0, 10);
            });
            return size;
          }
        }
      },
      innerHeight: function innerHeight() {
        var elm = this;

        if (this.length > 0) {
          if (this[0].innerHeight) {
            return this[0].innerHeight;
          } else {
            var size = this[0].offsetHeight,
                sides = ['top', 'bottom'];
            sides.forEach(function (side) {
              size -= parseInt(elm.css(camelize('border-' + side + '-width')) || 0, 10);
            });
            return size;
          }
        }
      },
      offset: function offset() {
        if (this.length > 0) {
          var el = this[0],
              box = el.getBoundingClientRect(),
              doc = document.documentElement;
          return {
            top: box.top + window.pageYOffset - doc.clientTop,
            left: box.left + window.pageXOffset - doc.clientLeft
          };
        }
      },
      hide: function hide() {
        for (var i = 0; i < this.length; i++) {
          this[i].style.display = 'none';
        }

        return this;
      },
      show: function show() {
        for (var i = 0; i < this.length; i++) {
          if (this[i].style.display == "none") {
            this[i].style.display = '';
          }

          if (getComputedStyle(this[i], '').getPropertyValue("display") == "none") {
            this[i].style.display = 'block';
          }
        }

        return this;
      },
      clone: function clone() {
        return this.map(function () {
          return this.cloneNode(true);
        });
      },
      styles: function styles() {
        return this[0] ? window.getComputedStyle(this[0], null) : undefined;
      },
      css: function css(property, value) {
        var i,
            key,
            element = this[0],
            css = '';

        if (arguments.length < 2) {
          if (!element) {
            return;
          }

          if (typeof property === 'string') {
            return element.style[property] || getComputedStyle(element, '').getPropertyValue(property);
          }
        }

        if (typeof property === 'string') {
          if (!value && value !== 0) {
            this.each(function () {
              this.style.removeProperty(dasherize(property));
            });
          } else {
            css = dasherize(property) + ":" + maybeAddPx(property, value);
          }
        } else {
          for (key in property) {
            if (!property[key] && property[key] !== 0) {
              for (i = 0; i < this.length; i++) {
                this[i].style.removeProperty(dasherize(key));
              }
            } else {
              css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';';
            }
          }
        }

        return this.each(function () {
          this.style.cssText += ';' + css;
        });
      },
      each: function each(callback) {
        for (var i = 0; i < this.length; i++) {
          if (callback.apply(this[i], [i, this[i]]) === false) {
            break;
          }
        }

        return this;
      },
      filter: function filter(callback) {
        var matchedItems = [];

        for (var i = 0; i < this.length; i++) {
          if (isFunction(callback)) {
            if (callback.call(this[i], i, this[i])) {
              matchedItems.push(this[i]);
            }
          } else if (matches(this[i], callback)) {
            matchedItems.push(this[i]);
          }
        }

        return new Dom(matchedItems);
      },
      html: function html(_html) {
        if (typeof _html === 'undefined') {
          return this[0] ? this[0].innerHTML : undefined;
        } else {
          this.empty();

          for (var i = 0; i < this.length; i++) {
            this[i].innerHTML = _html;
          }

          return this;
        }
      },
      text: function text(_text) {
        if (typeof _text === 'undefined') {
          return this[0] ? this[0].textContent.trim() : null;
        } else {
          for (var i = 0; i < this.length; i++) {
            this[i].textContent = _text;
          }

          return this;
        }
      },
      is: function is(selector) {
        return this.length > 0 && matches(this[0], selector);
      },
      not: function not(selector) {
        var nodes = [];

        if (isFunction(selector) && selector.call !== undefined) {
          this.each(function (idx) {
            if (!selector.call(this, idx)) {
              nodes.push(this);
            }
          });
        } else {
          var excludes = typeof selector == 'string' ? this.filter(selector) : likeArray(selector) && isFunction(selector.item) ? _slice.call(selector) : $(selector);

          if (isObject(excludes)) {
            excludes = $.map(excludes, function (el) {
              return el;
            });
          }

          this.each(function (i, el) {
            if (excludes.indexOf(el) < 0) {
              nodes.push(el);
            }
          });
        }

        return $(nodes);
      },
      indexOf: function indexOf(el) {
        for (var i = 0; i < this.length; i++) {
          if (this[i] === el) {
            return i;
          }
        }
      },
      index: function index(element) {
        return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0]);
      },
      get: function get(idx) {
        return idx === undefined ? _slice.call(this) : this[idx >= 0 ? idx : idx + this.length];
      },
      eq: function eq(index) {
        if (typeof index === 'undefined') {
          return this;
        }

        var length = this.length,
            returnIndex;

        if (index > length - 1) {
          return new Dom([]);
        }

        if (index < 0) {
          returnIndex = length + index;
          return returnIndex < 0 ? new Dom([]) : new Dom([this[returnIndex]]);
        }

        return new Dom([this[index]]);
      },
      append: function append(newChild) {
        var i, j;

        for (i = 0; i < this.length; i++) {
          if (typeof newChild === 'string') {
            var tempDiv = document.createElement('div');
            tempDiv.innerHTML = newChild;

            while (tempDiv.firstChild) {
              this[i].appendChild(tempDiv.firstChild);
            }
          } else if (newChild instanceof Dom) {
            for (j = 0; j < newChild.length; j++) {
              this[i].appendChild(newChild[j]);
            }
          } else {
            this[i].appendChild(newChild);
          }
        }

        return this;
      },
      appendTo: function appendTo(parent) {
        $(parent).append(this);
        return this;
      },
      prepend: function prepend(newChild) {
        var i, j;

        for (i = 0; i < this.length; i++) {
          if (typeof newChild === 'string') {
            var tempDiv = document.createElement('div');
            tempDiv.innerHTML = newChild;

            for (j = tempDiv.childNodes.length - 1; j >= 0; j--) {
              this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
            } // this[i].insertAdjacentHTML('afterbegin', newChild);

          } else if (newChild instanceof Dom) {
            for (j = 0; j < newChild.length; j++) {
              this[i].insertBefore(newChild[j], this[i].childNodes[0]);
            }
          } else {
            this[i].insertBefore(newChild, this[i].childNodes[0]);
          }
        }

        return this;
      },
      prependTo: function prependTo(parent) {
        $(parent).prepend(this);
        return this;
      },
      insertBefore: function insertBefore(selector) {
        var before = $(selector);

        for (var i = 0; i < this.length; i++) {
          if (before.length === 1) {
            before[0].parentNode.insertBefore(this[i], before[0]);
          } else if (before.length > 1) {
            for (var j = 0; j < before.length; j++) {
              before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
            }
          }
        }

        return this;
      },
      insertAfter: function insertAfter(selector) {
        var after = $(selector);

        for (var i = 0; i < this.length; i++) {
          if (after.length === 1) {
            after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
          } else if (after.length > 1) {
            for (var j = 0; j < after.length; j++) {
              after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
            }
          }
        }

        return this;
      },
      next: function next(selector) {
        if (this.length > 0) {
          if (selector) {
            if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
              return new Dom([this[0].nextElementSibling]);
            } else {
              return new Dom([]);
            }
          } else {
            if (this[0].nextElementSibling) {
              return new Dom([this[0].nextElementSibling]);
            } else {
              return new Dom([]);
            }
          }
        } else {
          return new Dom([]);
        }
      },
      nextAll: function nextAll(selector) {
        var nextEls = [],
            el = this[0];

        if (!el) {
          return new Dom([]);
        }

        while (el.nextElementSibling) {
          var next = el.nextElementSibling;

          if (selector) {
            if ($(next).is(selector)) {
              nextEls.push(next);
            }
          } else {
            nextEls.push(next);
          }

          el = next;
        }

        return new Dom(nextEls);
      },
      prev: function prev(selector) {
        if (this.length > 0) {
          if (selector) {
            if (this[0].previousElementSibling && $(this[0].previousElementSibling).is(selector)) {
              return new Dom([this[0].previousElementSibling]);
            } else {
              return new Dom([]);
            }
          } else {
            if (this[0].previousElementSibling) {
              return new Dom([this[0].previousElementSibling]);
            } else {
              return new Dom([]);
            }
          }
        } else {
          return new Dom([]);
        }
      },
      prevAll: function prevAll(selector) {
        var prevEls = [];
        var el = this[0];

        if (!el) {
          return new Dom([]);
        }

        while (el.previousElementSibling) {
          var prev = el.previousElementSibling;

          if (selector) {
            if ($(prev).is(selector)) {
              prevEls.push(prev);
            }
          } else {
            prevEls.push(prev);
          }

          el = prev;
        }

        return new Dom(prevEls);
      },
      parent: function parent(selector) {
        var parents = [];

        for (var i = 0; i < this.length; i++) {
          if (this[i].parentNode !== null) {
            if (selector) {
              if ($(this[i].parentNode).is(selector)) {
                parents.push(this[i].parentNode);
              }
            } else {
              parents.push(this[i].parentNode);
            }
          }
        }

        return $($.unique(parents));
      },
      parents: function parents(selector) {
        var parents = [];

        for (var i = 0; i < this.length; i++) {
          var parent = this[i].parentNode;

          while (parent) {
            if (selector) {
              if ($(parent).is(selector)) {
                parents.push(parent);
              }
            } else {
              parents.push(parent);
            }

            parent = parent.parentNode;
          }
        }

        return $($.unique(parents));
      },
      find: function find(selector) {
        var foundElements = [];

        for (var i = 0; i < this.length; i++) {
          var found = this[i].querySelectorAll(selector);

          for (var j = 0; j < found.length; j++) {
            foundElements.push(found[j]);
          }
        }

        return new Dom(foundElements);
      },
      children: function children(selector) {
        var children = [];

        for (var i = 0; i < this.length; i++) {
          var childNodes = this[i].childNodes;

          for (var j = 0; j < childNodes.length; j++) {
            if (!selector) {
              if (childNodes[j].nodeType === 1) {
                children.push(childNodes[j]);
              }
            } else {
              if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) {
                children.push(childNodes[j]);
              }
            }
          }
        }

        return new Dom($.unique(children));
      },
      remove: function remove() {
        for (var i = 0; i < this.length; i++) {
          if (this[i].parentNode) {
            this[i].parentNode.removeChild(this[i]);
          }
        }

        return this;
      },
      add: function add() {
        var dom = this;
        var i, j;

        for (i = 0; i < arguments.length; i++) {
          var toAdd = $(arguments[i]);

          for (j = 0; j < toAdd.length; j++) {
            dom[dom.length] = toAdd[j];
            dom.length++;
          }
        }

        return dom;
      },
      before: function before(elm) {
        $(elm).insertBefore(this);
        return this;
      },
      after: function after(elm) {
        $(elm).insertAfter(this);
        return this;
      },
      scrollTop: function scrollTop(value) {
        if (!this.length) {
          return;
        }

        var hasScrollTop = 'scrollTop' in this[0];

        if (value === undefined) {
          return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset;
        }

        return this.each(hasScrollTop ? function () {
          this.scrollTop = value;
        } : function () {
          this.scrollTo(this.scrollX, value);
        });
      },
      scrollLeft: function scrollLeft(value) {
        if (!this.length) {
          return;
        }

        var hasScrollLeft = 'scrollLeft' in this[0];

        if (value === undefined) {
          return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset;
        }

        return this.each(hasScrollLeft ? function () {
          this.scrollLeft = value;
        } : function () {
          this.scrollTo(value, this.scrollY);
        });
      },
      contents: function contents() {
        return this.map(function (i, v) {
          return _slice.call(v.childNodes);
        });
      },
      nextUntil: function nextUntil(selector) {
        var n = this,
            array = [];

        while (n.length && !n.filter(selector).length) {
          array.push(n[0]);
          n = n.next();
        }

        return $(array);
      },
      prevUntil: function prevUntil(selector) {
        var n = this,
            array = [];

        while (n.length && !$(n).filter(selector).length) {
          array.push(n[0]);
          n = n.prev();
        }

        return $(array);
      },
      detach: function detach() {
        return this.remove();
      }
    }; // Link to prototype

    $.fn = Dom.prototype;
    return $;
  }(); // Export to local scope


  var $ = Dom; // Export to mobiscroll

  mobiscroll.$ = Dom; // DOM Library Utilites

  $.inArray = function (elem, array, i) {
    return emptyArray.indexOf.call(array, elem, i);
  };

  $.extend = function (target) {
    var deep,
        args = _slice.call(arguments, 1);

    if (typeof target == 'boolean') {
      deep = target;
      target = args.shift();
    }

    target = target || {};
    args.forEach(function (arg) {
      extend(target, arg, deep);
    });
    return target;
  };

  $.isFunction = isFunction;

  $.isArray = function (arr) {
    return Object.prototype.toString.apply(arr) === '[object Array]';
  };

  $.isPlainObject = function (obj) {
    return isObject(obj) && obj !== null && obj !== obj.window && Object.getPrototypeOf(obj) == Object.prototype;
  };

  $.each = function (obj, callback) {
    var i, prop;

    if (!isObject(obj) || !callback) {
      return;
    }

    if ($.isArray(obj) || obj instanceof Dom) {
      // Array
      for (i = 0; i < obj.length; i++) {
        if (callback.call(obj[i], i, obj[i]) === false) {
          break;
        }
      }
    } else {
      // Object
      for (prop in obj) {
        // eslint-disable-next-line no-prototype-builtins
        if (obj.hasOwnProperty(prop) && prop !== 'length') {
          if (callback.call(obj[prop], prop, obj[prop]) === false) {
            break;
          }
        }
      }
    }

    return this;
  };

  $.unique = function (arr) {
    var unique = [];

    for (var i = 0; i < arr.length; i++) {
      if (unique.indexOf(arr[i]) === -1) {
        unique.push(arr[i]);
      }
    }

    return unique;
  };

  $.map = function (elements, callback) {
    var value,
        values = [],
        i,
        key;

    if (likeArray(elements)) {
      for (i = 0; i < elements.length; i++) {
        value = callback(elements[i], i);

        if (value !== null) {
          values.push(value);
        }
      }
    } else {
      for (key in elements) {
        value = callback(elements[key], key);

        if (value !== null) {
          values.push(value);
        }
      }
    }

    return values.length > 0 ? $.fn.concat.apply([], values) : values;
  };

  function noop() {}

  function objectToArray(obj) {
    var arr = [],
        i;

    for (i in obj) {
      arr.push(obj[i]);
    }

    return arr;
  }

  function arrayToObject(arr) {
    var obj = {},
        i;

    if (arr) {
      for (i = 0; i < arr.length; i++) {
        obj[arr[i]] = arr[i];
      }
    }

    return obj;
  }

  function isNumeric(a) {
    return a - parseFloat(a) >= 0;
  }

  function isString(s) {
    return typeof s === 'string';
  }

  function constrain(val, min, max) {
    return Math.max(min, Math.min(val, max));
  }

  function pad(num, size) {
    num = num + '';
    size = size || 2;

    while (num.length < size) {
      num = '0' + num;
    }

    return num;
  }

  function throttle(fn, threshhold) {
    var last, timer;
    threshhold = threshhold || 100;
    return function () {
      var context = this,
          now = +new Date(),
          args = arguments;

      if (last && now < last + threshhold) {
        clearTimeout(timer);
        timer = setTimeout(function () {
          last = now;
          fn.apply(context, args);
        }, threshhold);
      } else {
        last = now;
        fn.apply(context, args);
      }
    };
  }

  function vibrate(time) {
    if ('vibrate' in navigator) {
      navigator.vibrate(time || 50);
    }
  }

  function getPercent(v, min, max) {
    return (v - min) * 100 / (max - min);
  }

  function getBoolAttr(attr, def, $elm) {
    var v = $elm.attr(attr);
    return v === undefined || v === '' ? def : v === 'true';
  }

  var tapped = 0;
  var allowQuick;

  function preventClick() {
    // Prevent ghost click
    tapped++;
    setTimeout(function () {
      tapped--;
    }, 500);
  }

  function triggerClick(ev, control) {
    // Prevent duplicate triggers on the same element
    // e.g. a form checkbox inside a listview item
    if (control.mbscClick) {
      return;
    }

    var touch = (ev.originalEvent || ev).changedTouches[0],
        evt = document.createEvent('MouseEvents');
    evt.initMouseEvent('click', true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
    evt.isMbscTap = true; // Prevent ionic to bust our click
    // This works for Ionic 1 - 3, not sure about 4

    evt.isIonicTap = true; // This will allow a click fired together with this click
    // We need this, because clicking on a label will trigger a click
    // on the associated input as well, which should not be busted

    allowQuick = true;
    control.mbscChange = true;
    control.mbscClick = true;
    control.dispatchEvent(evt);
    allowQuick = false; // Prevent ghost click

    preventClick();
    setTimeout(function () {
      delete control.mbscClick;
    });
  }

  function getCoord(e, c, page) {
    var ev = e.originalEvent || e,
        prop = (page ? 'page' : 'client') + c; // Multi touch support

    if (ev.targetTouches && ev.targetTouches[0]) {
      return ev.targetTouches[0][prop];
    }

    if (ev.changedTouches && ev.changedTouches[0]) {
      return ev.changedTouches[0][prop];
    }

    return e[prop];
  }

  function getControlType($elm) {
    var attrs = ['switch', 'range', 'rating', 'segmented', 'stepper'];
    var elm = $elm[0];
    var role = $elm.attr('data-role');
    var type = $elm.attr('type') || elm.nodeName.toLowerCase();

    if (/(switch|range|rating|segmented|stepper|select)/.test(role)) {
      type = role;
    } else {
      for (var i = 0; i < attrs.length; i++) {
        if ($elm.is('[mbsc-' + attrs[i] + ']')) {
          type = attrs[i];
        }
      }
    }

    return type;
  }

  function activateControl(control, type, ev) {
    control.focus();

    if (/(button|submit|checkbox|switch|radio)/.test(type)) {
      ev.preventDefault();
    }

    if (!/select/.test(type)) {
      triggerClick(ev, control);
    }
  }

  function tap(that, el, handler, prevent, tolerance, time) {
    var startX,
        startY,
        target,
        moved,
        startTime,
        $ = mobiscroll.$,
        $elm = $(el);
    tolerance = tolerance || 9;

    function onStart(ev) {
      if (!target) {
        // Can't always call preventDefault here, it kills page scroll
        // if (prevent) {
        //     ev.preventDefault();
        // }
        target = this;
        startX = getCoord(ev, 'X');
        startY = getCoord(ev, 'Y');
        moved = false;
        startTime = new Date();
      }
    }

    function onMove(ev) {
      // If movement is more than 20px, don't fire the click event handler
      if (target && !moved && (Math.abs(getCoord(ev, 'X') - startX) > tolerance || Math.abs(getCoord(ev, 'Y') - startY) > tolerance)) {
        moved = true;
      }
    }

    function onEnd(ev) {
      if (target) {
        if (time && new Date() - startTime < 100 || !moved) {
          // ev.preventDefault();
          // handler.call(target, ev, that);
          triggerClick(ev, ev.target);
        } else {
          preventClick();
        }

        target = false;
      }
    }

    function onClick(ev) {
      if (prevent) {
        ev.preventDefault();
      } // If handler was not called on touchend, call it on click;


      handler.call(this, ev, that);
    }

    function onCancel() {
      target = false;
    }

    $elm.each(function (i, elm) {
      if (that.settings.tap) {
        listen(elm, 'touchstart', onStart, {
          passive: true
        });
        listen(elm, 'touchcancel', onCancel);
        listen(elm, 'touchmove', onMove, {
          passive: true
        });
        listen(elm, 'touchend', onEnd);
      }

      listen(elm, 'click', onClick);

      elm.__mbscOff = function () {
        unlisten(elm, 'touchstart', onStart, {
          passive: true
        });
        unlisten(elm, 'touchcancel', onCancel);
        unlisten(elm, 'touchmove', onMove, {
          passive: true
        });
        unlisten(elm, 'touchend', onEnd);
        unlisten(elm, 'click', onClick);
        delete elm.__mbscOff;
      };
    });
  }

  function tapOff($elm) {
    if ($elm && $elm[0] && $elm[0].__mbscOff) {
      $elm[0].__mbscOff();
    }
  } // Prevent standard behaviour on body click


  function bustClick(ev) {
    // Textarea needs the mousedown event
    if (tapped && !allowQuick && !ev.isMbscTap && !(ev.target.nodeName == 'TEXTAREA' && ev.type == 'mousedown')) {
      ev.stopPropagation();
      ev.preventDefault();
      return false;
    }
  }

  if (isBrowser) {
    ['mouseover', 'mousedown', 'mouseup', 'click'].forEach(function (ev) {
      document.addEventListener(ev, bustClick, true);
    });

    if (os == 'android' && majorVersion < 5) {
      document.addEventListener('change', function (ev) {
        if (tapped && ev.target.type == 'checkbox' && !ev.target.mbscChange) {
          ev.stopPropagation();
          ev.preventDefault();
        }

        delete ev.target.mbscChange;
      }, true);
    }
  }

  function adjustedDate(y, m, d, h, i, s, u) {
    var date = new Date(y, m, d, h || 0, i || 0, s || 0, u || 0);

    if (date.getHours() == 23 && (h || 0) === 0) {
      date.setHours(date.getHours() + 2);
    }

    return date;
  }
  /**
   * Format a date into a string value with a specified format.
   * @param {String} format Output format.
   * @param {Date} date Date to format.
   * @param {Object} [settings={}] Settings.
   * @return {String} Returns the formatted date string.
   */


  function formatDate(format, date, settings) {
    if (!date) {
      return null;
    }

    var s = extend$1({}, dateTimeDefaults, settings),
        look = function look(m) {
      // Check whether a format character is doubled
      var n = 0;

      while (i + 1 < format.length && format.charAt(i + 1) == m) {
        n++;
        i++;
      }

      return n;
    },
        f1 = function f1(m, val, len) {
      // Format a number, with leading zero if necessary
      var n = '' + val;

      if (look(m)) {
        while (n.length < len) {
          n = '0' + n;
        }
      }

      return n;
    },
        f2 = function f2(m, val, s, l) {
      // Format a name, short or long as requested
      return look(m) ? l[val] : s[val];
    },
        i,
        year,
        output = '',
        literal = false;

    for (i = 0; i < format.length; i++) {
      if (literal) {
        if (format.charAt(i) == "'" && !look("'")) {
          literal = false;
        } else {
          output += format.charAt(i);
        }
      } else {
        switch (format.charAt(i)) {
          case 'd':
            output += f1('d', s.getDay(date), 2);
            break;

          case 'D':
            output += f2('D', date.getDay(), s.dayNamesShort, s.dayNames);
            break;

          case 'o':
            output += f1('o', (date.getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000, 3);
            break;

          case 'm':
            output += f1('m', s.getMonth(date) + 1, 2);
            break;

          case 'M':
            output += f2('M', s.getMonth(date), s.monthNamesShort, s.monthNames);
            break;

          case 'y':
            year = s.getYear(date);
            output += look('y') ? year : (year % 100 < 10 ? '0' : '') + year % 100; //output += (look('y') ? date.getFullYear() : (date.getYear() % 100 < 10 ? '0' : '') + date.getYear() % 100);

            break;

          case 'h':
            var h = date.getHours();
            output += f1('h', h > 12 ? h - 12 : h === 0 ? 12 : h, 2);
            break;

          case 'H':
            output += f1('H', date.getHours(), 2);
            break;

          case 'i':
            output += f1('i', date.getMinutes(), 2);
            break;

          case 's':
            output += f1('s', date.getSeconds(), 2);
            break;

          case 'a':
            output += date.getHours() > 11 ? s.pmText : s.amText;
            break;

          case 'A':
            output += date.getHours() > 11 ? s.pmText.toUpperCase() : s.amText.toUpperCase();
            break;

          case "'":
            if (look("'")) {
              output += "'";
            } else {
              literal = true;
            }

            break;

          default:
            output += format.charAt(i);
        }
      }
    }

    return output;
  } // --- TRIAL SERVER CODE END ---

  /**
   * Extract a date from a string value with a specified format.
   * @param {String} format Input format.
   * @param {String} value String to parse.
   * @param {Object} [settings={}] Settings.
   * @return {Date} Returns the extracted date.
   */


  function parseDate(format, value, settings) {
    var s = extend$1({}, dateTimeDefaults, settings),
        def = makeDate(s.defaultValue || new Date());

    if (!format || !value) {
      return def;
    } // If already a date object


    if (value.getTime) {
      return value;
    }

    value = typeof value == 'object' ? value.toString() : value + '';

    var shortYearCutoff = s.shortYearCutoff,
        year = s.getYear(def),
        month = s.getMonth(def) + 1,
        day = s.getDay(def),
        doy = -1,
        hours = def.getHours(),
        minutes = def.getMinutes(),
        seconds = 0,
        //def.getSeconds(),
    ampm = -1,
        literal = false,
        // Check whether a format character is doubled
    lookAhead = function lookAhead(match) {
      var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) == match;

      if (matches) {
        iFormat++;
      }

      return matches;
    },
        getNumber = function getNumber(match) {
      // Extract a number from the string value
      lookAhead(match);
      var size = match == '@' ? 14 : match == '!' ? 20 : match == 'y' ? 4 : match == 'o' ? 3 : 2,
          digits = new RegExp('^\\d{1,' + size + '}'),
          num = value.substr(iValue).match(digits);

      if (!num) {
        return 0;
      }

      iValue += num[0].length;
      return parseInt(num[0], 10);
    },
        getName = function getName(match, s, l) {
      // Extract a name from the string value and convert to an index
      var names = lookAhead(match) ? l : s,
          i;

      for (i = 0; i < names.length; i++) {
        if (value.substr(iValue, names[i].length).toLowerCase() == names[i].toLowerCase()) {
          iValue += names[i].length;
          return i + 1;
        }
      }

      return 0;
    },
        checkLiteral = function checkLiteral() {
      iValue++;
    },
        iValue = 0,
        iFormat;

    for (iFormat = 0; iFormat < format.length; iFormat++) {
      if (literal) {
        if (format.charAt(iFormat) == "'" && !lookAhead("'")) {
          literal = false;
        } else {
          checkLiteral();
        }
      } else {
        switch (format.charAt(iFormat)) {
          case 'd':
            day = getNumber('d');
            break;

          case 'D':
            getName('D', s.dayNamesShort, s.dayNames);
            break;

          case 'o':
            doy = getNumber('o');
            break;

          case 'm':
            month = getNumber('m');
            break;

          case 'M':
            month = getName('M', s.monthNamesShort, s.monthNames);
            break;

          case 'y':
            year = getNumber('y');
            break;

          case 'H':
            hours = getNumber('H');
            break;

          case 'h':
            hours = getNumber('h');
            break;

          case 'i':
            minutes = getNumber('i');
            break;

          case 's':
            seconds = getNumber('s');
            break;

          case 'a':
            ampm = getName('a', [s.amText, s.pmText], [s.amText, s.pmText]) - 1;
            break;

          case 'A':
            ampm = getName('A', [s.amText, s.pmText], [s.amText, s.pmText]) - 1;
            break;

          case "'":
            if (lookAhead("'")) {
              checkLiteral();
            } else {
              literal = true;
            }

            break;

          default:
            checkLiteral();
        }
      }
    }

    if (year < 100) {
      year += new Date().getFullYear() - new Date().getFullYear() % 100 + (year <= (typeof shortYearCutoff != 'string' ? shortYearCutoff : new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10)) ? 0 : -100);
    }

    if (doy > -1) {
      month = 1;
      day = doy;

      do {
        var dim = 32 - new Date(year, month - 1, 32, 12).getDate();

        if (day > dim) {
          month++;
          day -= dim;
        }
      } while (day > dim);
    }

    hours = ampm == -1 ? hours : ampm && hours < 12 ? hours + 12 : !ampm && hours == 12 ? 0 : hours;
    var date = s.getDate(year, month - 1, day, hours, minutes, seconds);

    if (s.getYear(date) != year || s.getMonth(date) + 1 != month || s.getDay(date) != day) {
      return def; // Invalid date
    }

    return date;
  }

  function getDayDiff(d1, d2) {
    return Math.round((d2 - d1) / (24 * 60 * 60 * 1000));
  }

  function getDateOnly(d) {
    return adjustedDate(d.getFullYear(), d.getMonth(), d.getDate());
  }

  function getDateStr(d) {
    return d.getFullYear() + '-' + (d.getMonth() + 1) + '-' + d.getDate();
  }

  function getISOString(d, parts) {
    var ret = '',
        time = '';

    if (d) {
      if (parts.h) {
        time += pad(d.getHours()) + ':' + pad(d.getMinutes());

        if (parts.s) {
          time += ':' + pad(d.getSeconds());
        }

        if (parts.u) {
          time += '.' + pad(d.getMilliseconds(), 3);
        }

        if (parts.tz) {
          time += parts.tz; // Just put what we got
        }
      }

      if (parts.y) {
        ret += d.getFullYear();

        if (parts.m) {
          ret += '-' + pad(d.getMonth() + 1);

          if (parts.d) {
            ret += '-' + pad(d.getDate());
          }

          if (parts.h) {
            ret += 'T' + time;
          }
        }
      } else if (parts.h) {
        ret = time;
      }
    }

    return ret;
  }

  function setISOParts(parsed, offset, parts) {
    var part,
        v,
        p = {
      y: 1,
      m: 2,
      d: 3,
      h: 4,
      i: 5,
      s: 6,
      u: 7,
      tz: 8
    };

    if (parts) {
      for (part in p) {
        v = parsed[p[part] - offset];

        if (v) {
          parts[part] = part == 'tz' ? v : 1;
        }
      }
    }
  }

  function returnDate(d, s, displayFormat) {
    var moment = window.moment || s.moment,
        format = s.returnFormat;

    if (d) {
      if (format == 'moment' && moment) {
        return moment(d);
      }

      if (format == 'locale') {
        return formatDate(displayFormat, d, s);
      }

      if (format == 'iso8601') {
        return getISOString(d, s.isoParts);
      }
    }

    return d;
  }

  function makeDate(d, format, s, parts) {
    var parse;

    if (!d) {
      return null;
    } // If already date object


    if (d.getTime) {
      return d;
    } // Moment object


    if (d.toDate) {
      return d.toDate();
    }

    if (typeof d == 'string') {
      d = d.trim();
    }

    parse = ISO_8601_TIME.exec(d); // If ISO 8601 time string

    if (parse) {
      setISOParts(parse, 2, parts);
      return new Date(1970, 0, 1, parse[2] ? +parse[2] : 0, parse[3] ? +parse[3] : 0, parse[4] ? +parse[4] : 0, parse[5] ? +parse[5] : 0);
    }

    if (!parse) {
      parse = ISO_8601_FULL.exec(d);
    } // If ISO 8601 date string


    if (parse) {
      setISOParts(parse, 0, parts);
      return new Date(parse[1] ? +parse[1] : 1970, parse[2] ? parse[2] - 1 : 0, parse[3] ? +parse[3] : 1, parse[4] ? +parse[4] : 0, parse[5] ? +parse[5] : 0, parse[6] ? +parse[6] : 0, parse[7] ? +parse[7] : 0);
    } // Parse date based on format


    return parseDate(format, d, s);
  }

  function isSameDay(d1, d2) {
    return d1.getFullYear() == d2.getFullYear() && d1.getMonth() == d2.getMonth() && d1.getDate() == d2.getDate();
  }

  var ISO_8601_FULL = /^(\d{4}|[+-]\d{6})(?:-(\d{2})(?:-(\d{2}))?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?((Z)|([+-])(\d{2})(?::(\d{2}))?)?)?$/;
  var ISO_8601_TIME = /^((\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+-])(\d{2})(?::(\d{2}))?)?)?$/;
  var DAY_OF_MONTH = /^\d{1,2}(\/\d{1,2})?$/;
  var DAY_OF_WEEK = /^w\d$/i;
  var dateTimeDefaults = {
    shortYearCutoff: '+10',
    monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
    monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
    dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
    dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
    dayNamesMin: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
    amText: 'am',
    pmText: 'pm',
    getYear: function getYear(d) {
      return d.getFullYear();
    },
    getMonth: function getMonth(d) {
      return d.getMonth();
    },
    getDay: function getDay(d) {
      return d.getDate();
    },
    getDate: adjustedDate,
    getMaxDayOfMonth: function getMaxDayOfMonth(y, m) {
      return 32 - new Date(y, m, 32, 12).getDate();
    },
    getWeekNumber: function getWeekNumber(d) {
      // Copy date so don't modify original
      d = new Date(d);
      d.setHours(0, 0, 0); // Set to nearest Thursday: current date + 4 - current day number
      // Make Sunday's day number 7

      d.setDate(d.getDate() + 4 - (d.getDay() || 7)); // Get first day of year

      var yearStart = new Date(d.getFullYear(), 0, 1); // Calculate full weeks to nearest Thursday

      return Math.ceil(((d - yearStart) / 86400000 + 1) / 7);
    }
  };
  util.datetime = {
    formatDate: formatDate,
    parseDate: parseDate
  };

  /*!
   * Mobiscroll v4.10.9
   * http://mobiscroll.com
   *
   * Copyright 2010-2018, Acid Media
   *
   */
  console.info('The trial is being authenticated with remote calls made to https://trial.mobiscroll.com. This is strictly necessary for the trial. No remote calls are made from the licensed version. More info on the trial and its limitations: http://help.mobiscroll.com/trials/what-are-the-limitations-of-the-trial');

  function getWidth(el) {
    return el[0].innerWidth || el.innerWidth();
  }

  function getThemeName(s) {
    var themeName = s.theme,
        themeVariant = s.themeVariant;

    if (themeName == 'auto' || !themeName) {
      themeName = ms.autoTheme;
    }

    if (themeName == 'default') {
      themeName = 'mobiscroll';
    }

    if ((themeVariant === 'dark' || isDark && themeVariant === 'auto') && ms.themes.form[themeName + '-dark']) {
      themeName = themeName + '-dark';
    } else if (themeVariant === 'light' && /.+-dark$/.test(themeName)) {
      themeName = themeName.replace(/-dark$/, '');
    }

    return themeName;
  }

  function autoInit(selector, Component, hasRefresh) {
    if (isBrowser) {
      $$1(function () {
        $$1(selector).each(function () {
          new Component(this, {});
        });
        $$1(document).on('mbsc-enhance', function (ev, settings) {
          if ($$1(ev.target).is(selector)) {
            new Component(ev.target, settings || {});
          } else {
            $$1(selector, ev.target).each(function () {
              new Component(this, settings || {});
            });
          }
        });

        if (hasRefresh) {
          $$1(document).on('mbsc-refresh', function (ev) {
            var inst;

            if ($$1(ev.target).is(selector)) {
              inst = instances[ev.target.id];

              if (inst) {
                inst.refresh();
              }
            } else {
              $$1(selector, ev.target).each(function () {
                inst = instances[this.id];

                if (inst) {
                  inst.refresh();
                }
              });
            }
          });
        }
      });
    }
  }

  var messageShow,
      ms,
      $$1 = mobiscroll.$,
      id = +new Date(),
      instances = {},
      classes = {},
      empty = {},
      breakpoints = {
    xsmall: 0,
    small: 576,
    medium: 768,
    large: 992,
    xlarge: 1200
  },
      extend$1 = $$1.extend;
  extend$1(util, {
    getCoord: getCoord,
    preventClick: preventClick,
    vibrate: vibrate
  });
  ms = extend$1(mobiscroll, {
    $: $$1,
    version: '4.10.9',
    autoTheme: 'mobiscroll',
    themes: {
      form: {},
      page: {},
      frame: {},
      scroller: {},
      listview: {},
      navigation: {},
      progress: {},
      card: {}
    },
    platform: {
      name: os,
      majorVersion: majorVersion,
      minorVersion: minorVersion
    },
    i18n: {},
    instances: instances,
    classes: classes,
    util: util,
    settings: {},
    setDefaults: function setDefaults(o) {
      extend$1(this.settings, o);
    },
    customTheme: function customTheme(name, baseTheme) {
      var i,
          themes = mobiscroll.themes,
          comps = ['frame', 'scroller', 'listview', 'navigation', 'form', 'page', 'progress', 'card'];

      for (i = 0; i < comps.length; i++) {
        themes[comps[i]][name] = extend$1({}, themes[comps[i]][baseTheme], {
          baseTheme: baseTheme
        });
      }
    }
  });

  var Base = function Base(el, settings) {
    var ctx,
        lang,
        preset,
        resp,
        s,
        theme,
        themeName,
        trigger,
        defaults,
        that = this;
    that.settings = {};
    that._getText = new Function('mobiscroll, p', function () {
      function getKey(encryptKey) {
        var a = encryptKey[0],
            i;

        for (i = 0; i < 16; ++i) {
          if (a * i % 16 == 1) {
            return [i, encryptKey[1]];
          }
        }
      }

      function affine(enc, str, a, b) {
        var alfb = '0123456789abcdef',
            newstr = '',
            len = str.length,
            i;

        for (i = 0; i < len; ++i) {
          newstr += enc ? alfb[(a * alfb.indexOf(str[i]) + b) % 16] : alfb[((a * alfb.indexOf(str[i]) - a * b) % 16 + 16) % 16];
        }

        return newstr;
      }

      function decrypt(str, encryptKey) {
        var decryptKey = getKey(encryptKey),
            decryptedStr = affine(0, str, decryptKey[0], decryptKey[1]),
            len = decryptedStr.length,
            arr = [],
            i;

        for (i = 0; i < len; i += 2) {
          arr.push(decryptedStr[i] + decryptedStr[i + 1]);
        }

        return arr;
      }

      var a = decrypt("565c5f59030d0c0f51015c0d0e0ec80d55006cb21317195c0b565b5c08ca6307560ac85c0708060d03cacf1e6307560ac803075aca12c81210ce52cf1dc51e060f50c251565f0e0b13ccc5c9005b0801560f0d08ca0bcf5950075cc256130bc80e0b0805560ace08ce5c19550a0f0e0bca12c7131356cf595c136307560ac8000e0d0d5cca6307560ac85c0708060d03cacfc456cf1956c313171908130bb956b3190bb956b3130bb95cb3190bb95cb31308535c0b565b5c08c20b53cab9c5060f51520e075f140c0e0d0109c70f03520d5c56070856c5cec5520d510f560f0d0814070c510d0e5b560bc70f03520d5c56070856c5cec554c30f08060b5a14c317c5cec5560d521412c70f03520d5c56070856c5cec50e0b00561412c70f03520d5c56070856c5cec50c0d56560d031412c70f03520d5c56070856c5cec55c0f050a561412c70f03520d5c56070856c5cec503075c050f081412c70f03520d5c56070856c5cec5520706060f08051412c70f03520d5c56070856c5cec5000d0856c3510f540b141a525ac70f03520d5c56070856c5cec50e0f080bc30a0b0f050a5614171c525ac5cec5560b5a56c3070e0f050814010b08560b5cc5cec50d5207010f565f14c5c9ca6307560ac8000e0d0d5cca6307560ac85c0708060d03cacfc41c12cfcd171212c912c81acfc9c5c70f03520d5c56070856c5b3cfc8040d0f08cac519c5cfc9c5cc18be5b12121b16be5b12121b1cbe5b1212161fbe5b12121617be5b121216011ecd060f5018c514c5c5cf53010756010aca0bcf595c0b565b5c08c2c5c55334", [5, 2]),
          b = '',
          l = a.length,
          c;

      for (c = 0; c < l; c++) {
        b += String.fromCharCode(parseInt(a[c], 16));
      }

      return b;
    }());
    that.element = el;
    that._init = noop;
    that._destroy = noop;
    that._processSettings = noop;

    that._checkResp = function (width) {
      if (that && that._responsive) {
        var newResp = getResponsiveSettings(width);

        if (resp !== newResp) {
          resp = newResp;
          that.init({});
          return true;
        }
      }
    };

    that._getRespCont = function () {
      return $$1(s.context == 'body' ? window : s.context);
    };

    that.init = function (newSettings, newValue) {
      var key, value; // In case of settings update save the old value

      if (newSettings && that.getVal) {
        value = that.getVal();
      } // Reset settings object


      for (key in that.settings) {
        delete that.settings[key];
      }

      s = that.settings; // Update original user settings

      extend$1(settings, newSettings); // Load user defaults

      if (that._hasDef) {
        defaults = ms.settings;
      } // Create settings object


      extend$1(s, that._defaults, defaults, settings);
      ctx = that._getRespCont();

      if (that._responsive) {
        if (!resp) {
          resp = getResponsiveSettings();
        }

        extend$1(s, resp);
      } // Get theme defaults


      if (that._hasTheme) {
        themeName = getThemeName(s);
        settings.theme = themeName;
        theme = ms.themes[that._class] ? ms.themes[that._class][themeName] : {};
      } // Get language defaults


      if (that._hasLang) {
        lang = ms.i18n[s.lang];
      } // Update settings object


      extend$1(s, theme, lang, defaults, settings, resp);

      that._processSettings(resp || {}); // --- REMOTE TRIAL CODE START ---


      var noRemote = {
        form: true,
        page: true,
        progress: true,
        switch: true,
        slider: true,
        stepper: true
      };

      function toDateStr(d) {
        return typeof d == 'string' ? d : getISOString(makeDate(d), {
          y: 1,
          m: 1,
          d: 1,
          h: 1,
          i: 1,
          s: 1,
          u: 1
        });
      }

      function init() {
        that._init(newSettings); // In case of settings update reset the value.
        // This is needed to adapt the value for the updated settings
        // E.g. min/max, date format, etc.


        if (newSettings && that.setVal) {
          that.setVal(newValue === undefined ? value : newValue, true);
        }

        trigger('onInit');
      }

      if (!that._class || noRemote[that._class]) {
        init();
      } else {
        if (!ms.fwv) {
          var vers;

          switch (ms.fw) {
            case 'angular':
              vers = $$1('[ng-version]').attr('ng-version');
              break;

            case 'jquery':
              vers = $$1.fn && $$1.fn.jquery;
              break;
          }

          ms.fwv = vers || 'N/A';
        }

        var config = {
          className: that._class,
          buttons: that.buttons,
          platform: ms.platform,
          v: ms.version,
          userAgent: navigator.userAgent,
          defSortHandle: $$1(el).find(s.listSelector || 'ul,ol').length ? 'left' : 'right',
          // For listview
          settings: {
            activeClass: s.activeClass,
            ampmText: s.ampmText,
            amText: s.amText,
            animateIcons: s.animateIcons,
            backText: s.backText,
            baseTheme: s.baseTheme,
            buttons: s.buttons,
            btnClass: s.btnClass,
            btnWidth: s.btnWidth,
            btnReverse: s.btnReverse,
            closeIcon: s.closeIcon,
            context: s.context == 'body' ? 'body' : '',
            controls: s.controls,
            cssClass: s.cssClass,
            dateDisplay: s.dateDisplay,
            dateFormat: s.dateFormat,
            dateWheels: s.dateWheels,
            dayNames: s.dayNames,
            dayNamesShort: s.dayNamesShort,
            daySuffix: s.daySuffix,
            display: s.display,
            dayText: s.dayText,
            endYear: s.endYear,
            fixedHeader: s.fixedHeader,
            handleClass: s.handleClass,
            handleMarkup: s.handleMarkup,
            hideText: s.hideText,
            hourText: s.hourText,
            itemNode: s.itemNode,
            itemWidth: s.itemWidth,
            lang: s.lang,
            lapIcon: s.lapIcon,
            lapText: s.lapText,
            layout: s.layout,
            leftArrowClass: s.leftArrowClass,
            max: toDateStr(s.max),
            min: toDateStr(s.min),
            minuteText: s.minuteText,
            monthNames: s.monthNames,
            monthNamesShort: s.monthNamesShort,
            monthSuffix: s.monthSuffix,
            monthText: s.monthText,
            nowIcon: s.nowIcon,
            nowText: s.nowText,
            pmText: s.pmText,
            preset: s.preset,
            resetIcon: s.resetIcon,
            resetText: s.resetText,
            rightArrowClass: s.rightArrowClass,
            rtl: s.rtl,
            secText: s.secText,
            select: s.select,
            showOverlay: s.showOverlay,
            snap: s.snap,
            sort: s.sort,
            sortable: s.sortable,
            sortHandle: s.sortHandle,
            startIcon: s.startIcon,
            startText: s.startText,
            startYear: s.startYear,
            stepHour: s.stepHour,
            stepMinute: s.stepMinute,
            stepSecond: s.stepSecond,
            steps: s.steps,
            stopIcon: s.stopIcon,
            stopText: s.stopText,
            striped: s.striped,
            theme: s.theme,
            timeFormat: s.timeFormat,
            timeWheels: s.timeWheels,
            todayText: s.todayText,
            type: s.type,
            variant: s.variant,
            wrapperClass: s.wrapperClass,
            yearSuffix: s.yearSuffix,
            yearText: s.yearText
          }
        };

        var i,
            prop,
            q = [],
            tempInst = {},
            presetFunctions = ['refresh', 'redraw', 'navigate', 'changeTab', // Calendar Base
        'getDate', 'setDate', // Datetime
        'addEvent', 'removeEvent', 'getEvents', 'setEvents', // Event calendar
        'setActiveDate', // Range
        'start', 'stop', 'reset', 'lap', 'resetlap', 'getTime', 'setTime', 'getEllapsedTime', 'setEllapsedTime' // Timer
        ],
            noProxy = {
          jsonp: 1,
          getInst: 1,
          init: 1,
          destroy: 1
        },
            proxy = function proxy(name) {
          that[name] = function () {
            q.push({
              func: name,
              args: arguments
            });
          };
        }; // Override all methods of the instance to delay execution
        // until the server side initialization is done.
        // For this we create a function which just pushes the function name
        // and arguments into a queue.


        for (prop in that) {
          if (typeof that[prop] === 'function' && !noProxy[prop]) {
            tempInst[prop] = that[prop];
            proxy(prop);
          }
        } // Proxy possible preset functions, which does not exist yet


        for (i = 0; i < presetFunctions.length; i++) {
          proxy(presetFunctions[i]);
        } // Workaround for timer buttons


        if (s.preset == 'timer' && !settings.buttons) {
          config.settings.buttons = ['resetlap', 'toggle'];

          if (s.display !== 'inline') {
            config.settings.buttons.unshift('hide');
          }
        }

        if (s.preset == 'eventcalendar' && !settings.buttons && s.display != 'inline') {
          config.settings.buttons = ['close'];
        }

        s.zone = s.zone || {
          run: function run(func) {
            func();
          },
          runOutsideAngular: function runOutsideAngular(func) {
            func();
          }
        };

        if (ms.apiKey !== 'mbscdemo') {
          logData.theme = s.theme;
          logData.components = logData.components || [];
          logData.components.push(that._class + '_' + (s.preset || ''));
          sendLog();
        }

        that.jsonp('remote', config, function (data) {
          s.zone.run(function () {
            if (!that) {
              return;
            }

            that.remote = data; // Copy back original functions in place of the proxy

            for (prop in tempInst) {
              that[prop] = tempInst[prop];
            }

            if (data.notification !== undefined && !messageShow) {
              messageShow = true;
              mobiscroll.snackbar(data.notification);
            } // Workaround for remote data updates


            var settingsCopy = extend$1({}, settings);
            delete settingsCopy.data; // --- REMOTE TRIAL CODE END ---
            // Load preset settings

            if (that._presets) {
              preset = that._presets[s.preset];

              if (preset) {
                preset = preset.call(el, that, settings);
                extend$1(s, preset, settingsCopy, resp);
              }
            }

            init(); // --- REMOTE TRIAL CODE START ---
            // Execute functions in the queue

            for (i = 0; i < q.length; i++) {
              that[q[i].func].apply(that, q[i].args);
            } // Empty temporary variables


            q = null;
            tempInst = null;
          });
        }, guid);
      } // --- REMOTE TRIAL CODE END ---

    };

    that.destroy = function () {
      if (that) {
        that._destroy();

        trigger('onDestroy'); // Delete scroller instance

        delete instances[el.id];
        that = null;
      }
    };
    /**
     * Attach tap event to the given element.
     */


    that.tap = function (el, handler, prevent, tolerance, time) {
      tap(that, el, handler, prevent, tolerance, time);
    };
    /**
     * Triggers an event
     */


    that.trigger = function (name, ev) {
      var ret,
          i,
          v,
          s = [defaults, theme, preset, settings];

      for (i = 0; i < 4; i++) {
        v = s[i];

        if (v && v[name]) {
          ret = v[name].call(el, ev || {}, that);
        }
      }

      return ret;
    };
    /**
     * Sets one ore more options.
     */


    that.option = function (opt, value, newValue) {
      var obj = {},
          // preserve settings that are possible to change runtime
      dynamic = ['data', 'invalid', 'valid', 'readonly'];

      if (/calendar|eventcalendar|range/.test(s.preset)) {
        dynamic.push('marked', 'labels', 'colors');
      }

      if (typeof opt === 'object') {
        obj = opt;
      } else {
        obj[opt] = value;
      }

      dynamic.forEach(function (v) {
        settings[v] = s[v];
      });
      that.init(obj, newValue);
    };
    /**
     * Returns the mobiscroll instance.
     */


    that.getInst = function () {
      return that;
    }; // --- REMOTE TRIAL CODE START ---


    that.jsonp = jsonp;
    var guid = 'comp_' + (el.id || ++uid); // --- REMOTE TRIAL CODE END ---

    settings = settings || {};
    trigger = that.trigger;

    function getResponsiveSettings(w) {
      var result = empty,
          width;

      if (s.responsive) {
        width = w || getWidth(ctx);
        $$1.each(s.responsive, function (key, value) {
          if (width >= (value.breakpoint || breakpoints[key])) {
            result = value;
          }
        });
      }

      return result;
    }

    function construct() {
      $$1(el).addClass('mbsc-comp'); // Autogenerate id

      if (!el.id) {
        el.id = 'mobiscroll' + ++id;
      } else if (instances[el.id]) {
        instances[el.id].destroy();
      } // Save instance


      instances[el.id] = that;
      that.__ready = true;
    }

    if (!that.__ready) {
      construct();
    }
  }; // --- REMOTE TRIAL CODE START ---


  var uid = 0;
  var logData = {};
  var logTimer;

  function sendError() {
    var sessionID = document.cookie.replace(/(?:(?:^|.*;\s*)ASP.NET_SessionId\s*=\s*([^;]*).*$)|^.*$/, "$1");
    document.cookie = 'mobiscrollClientError=1; expires=' + new Date(new Date().getTime() + 1000 * 60 * 60 * 24).toUTCString() + '; path=/'; // Workaround for file protocoll

    try {
      window.name = (window.name || '') + ';mobiscrollClientError';
    } catch (e) {// Make eslint happy
    }

    jsonp('error', {
      trialCode: ms.apiKey,
      sessionID: sessionID
    }, function () {
      document.cookie = 'mobiscrollClientError=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/';

      try {
        window.name = (window.name || '').replace(/;mobiscrollClientError/g, '');
      } catch (e) {// Make eslint happy
      }
    });
  }

  function sendLog() {
    clearTimeout(logTimer);
    logTimer = setTimeout(function () {
      extend$1(logData, {
        trialCode: ms.apiKey,
        fw: ms.fw + (window.Ionic || window.ionic ? '-ionic' : ''),
        fwv: ms.fwv,
        demo: !!window.isMbscDemo,
        v: ms.version
      });
      jsonp('log', logData, function () {
        logData = {};
      });
    }, 5000);
  }

  function jsonp(method, data, callback, uniqueId, attempts) {
    var timer,
        script = document.createElement('script'),
        unique = 'mbsc_jsonp_' + (uniqueId ? uniqueId : ++id);
    attempts = attempts || 1;

    function onError() {
      if (window[unique]) {
        window[unique]();
      }

      if (method === 'remote') {
        if (attempts < 4) {
          jsonp(method, data, callback, uniqueId, attempts + 1);
        } else if (!ms.trialError) {
          ms.trialError = true;
          sendError();

          if (ms.apiKey != 'mbscdemo') {
            alert('Mobiscroll trial not loaded. Please check your connection. If the problem persists, contact us at support@mobiscroll.com');
          }
        }
      }
    }

    window[unique] = function (data) {
      clearTimeout(timer);
      script.parentNode.removeChild(script);
      delete window[unique];
      callback(data ? JSON.parse(data, function (key, value) {
        if (typeof value != 'string') {
          return value;
        }

        if (value.substring(0, 8) === 'function') {
          return window.eval('(' + value + ')');
        }

        if (value.match(ISO_8601_FULL)) {
          return makeDate(value);
        }

        return value;
      }) : {});
    };

    timer = setTimeout(onError, 6000);
    script.onerror = onError;
    script.src = ms.apiUrl + ms.apiKey + '/' + method + '?callback=' + unique + '&data=' + encodeURIComponent(JSON.stringify(data));
    document.body.appendChild(script);
  }

  if (isBrowser) {
    $$1(function () {
      if (document.cookie.replace(/(?:(?:^|.*;\s*)mobiscrollClientError\s*=\s*([^;]*).*$)|^.*$/, "$1") || /mobiscrollClientError/.test(window.name || '')) {
        sendError();
      }
    });
  } // --- REMOTE TRIAL CODE END ---

  var Observable = function () {
    function Observable() {
      this.keyCount = 0;
      this.subscribers = new Map();
    }

    Observable.prototype.subscribe = function (handler) {
      var key = this.keyCount++;
      this.subscribers.set(key, handler);
      return key;
    };

    Observable.prototype.unsubscribe = function (handler) {
      if (typeof handler === 'number') {
        this.subscribers.delete(handler);
      } else {
        var foundKey_1 = null;
        this.subscribers.forEach(function (fn, key) {
          if (fn === handler) {
            foundKey_1 = key;
          }
        });
        this.subscribers.delete(foundKey_1);
      }
    };

    Observable.prototype.next = function (value) {
      this.subscribers.forEach(function (handler) {
        handler(value);
      });
    };

    return Observable;
  }();

  var MbscRouterToken = (function () {
      function MbscRouterToken() {
      }
      return MbscRouterToken;
  }());
  var MbscOptionsService = (function () {
      function MbscOptionsService() {
      }
      Object.defineProperty(MbscOptionsService.prototype, "options", {
          get: function () {
              return this._options;
          },
          set: function (o) {
              this._options = o;
          },
          enumerable: true,
          configurable: true
      });
      MbscOptionsService.decorators = [
          { type: core.Injectable },
      ];
      MbscOptionsService.ctorParameters = function () { return []; };
      return MbscOptionsService;
  }());
  var MbscInputService = (function () {
      function MbscInputService() {
          this._controlSet = false;
          this._componentRef = undefined;
      }
      Object.defineProperty(MbscInputService.prototype, "isControlSet", {
          get: function () {
              return this._controlSet;
          },
          set: function (v) {
              this._controlSet = v;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MbscInputService.prototype, "input", {
          get: function () {
              return this._componentRef;
          },
          set: function (v) {
              this._componentRef = v;
          },
          enumerable: true,
          configurable: true
      });
      MbscInputService.decorators = [
          { type: core.Injectable },
      ];
      MbscInputService.ctorParameters = function () { return []; };
      return MbscInputService;
  }());
  var MbscListService = (function () {
      function MbscListService() {
          this.addRemoveObservable = new Observable();
      }
      MbscListService.prototype.notifyAddRemove = function (item) {
          this.addRemoveObservable.next(item);
      };
      MbscListService.prototype.onAddRemove = function () {
          return this.addRemoveObservable;
      };
      MbscListService.decorators = [
          { type: core.Injectable },
      ];
      MbscListService.ctorParameters = function () { return []; };
      return MbscListService;
  }());
  var MbscBase = (function () {
      function MbscBase(initialElem, zone) {
          this.initialElem = initialElem;
          this.zone = zone;
          this.options = {};
          this.onInit = new core.EventEmitter();
          this.onDestroy = new core.EventEmitter();
          this.inlineOptionsObj = {};
          this.pendingValue = undefined;
          this.themeClassesSet = false;
          this.instance = null;
          this.element = null;
          this.inlineOptionsObj.zone = zone;
      }
      MbscBase.prototype.getInlineEvents = function () {
          var _this = this;
          var _loop_1 = function (prop) {
              if (this_1[prop] instanceof (core.EventEmitter) && (!this_1.options || !(this_1.options[prop]))) {
                  this_1.inlineOptionsObj[prop] = function (event, inst) {
                      event.inst = inst;
                      _this[prop].emit(event);
                  };
              }
          };
          var this_1 = this;
          for (var prop in this) {
              _loop_1(prop);
          }
      };
      MbscBase.prototype.setThemeClasses = function () {
          $$1(this.initialElem.nativeElement).addClass(this.getThemeClasses());
          this.themeClassesSet = true;
      };
      MbscBase.prototype.clearThemeClasses = function () {
          $$1(this.initialElem.nativeElement).removeClass(this.getThemeClasses());
      };
      MbscBase.prototype.getThemeClasses = function () {
          var s = this.instance.settings;
          return 'mbsc-control-ng mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : '');
      };
      MbscBase.prototype.setElement = function () {
          this.element = this.initialElem.nativeElement;
          var contentInput = $$1('input', this.initialElem.nativeElement);
          if (contentInput.length) {
              this.element = contentInput[0];
          }
      };
      MbscBase.prototype.ngAfterViewInit = function () {
          this.setElement();
          this.startInit();
      };
      MbscBase.prototype.startInit = function () {
          var _this = this;
          this.getInlineEvents();
          var ionInput = this.getIonInput();
          if (ionInput && (ionInput.getInputElement || ionInput.then) && this.element.nodeName !== "INPUT") {
              if (ionInput.getInputElement) {
                  ionInput.getInputElement().then(function (inp) {
                      _this.setElement();
                      _this.initControl();
                  });
              }
              else {
                  ionInput.then(function (ionInpComponent) {
                      ionInpComponent
                          .getInputElement()
                          .then(function (inp) {
                          _this.setElement();
                          _this.initControl();
                      });
                  });
              }
          }
          else if (!this.instance) {
              this.initControl();
          }
      };
      MbscBase.prototype.getIonInput = function () {
          var v = this._view;
          var native = this.initialElem.nativeElement;
          var ionInputNode = native.nodeName === "ION-INPUT";
          var inp1 = ionInputNode && v && v._data && v._data.componentView && v._data.componentView.component;
          var inp2 = ionInputNode && native.componentOnReady && native.componentOnReady();
          return inp1 || inp2;
      };
      MbscBase.prototype.initControl = function () { };
      MbscBase.prototype.ngOnDestroy = function () {
          if (this.instance) {
              this.instance.destroy();
          }
      };
      MbscBase.prototype.updateOptions = function (newOptions, optionChanged, invalidChanged, dataChanged) {
          var _this = this;
          if (optionChanged || invalidChanged) {
              setTimeout(function () {
                  if (newOptions.theme && _this.themeClassesSet) {
                      _this.clearThemeClasses();
                  }
                  _this.instance.option(newOptions, undefined, _this.pendingValue);
                  if (newOptions.theme && _this.themeClassesSet) {
                      _this.setThemeClasses();
                  }
              });
          }
          else if (dataChanged) {
              this.refreshData(this.data);
          }
          else if (this.instance.redraw) {
              this.instance.redraw();
          }
      };
      MbscBase.prototype.ngOnChanges = function (changes) {
          var optionChange = false, cloneChange = false, invalidChange = false, dataChange = false, newOptions = {};
          for (var prop in changes) {
              if (!changes[prop].firstChange && prop !== 'options' && prop !== 'value') {
                  if (this.cloneDictionary && this.cloneDictionary[prop]) {
                      this.makeClone(prop, changes[prop].currentValue);
                      if (this.instance) {
                          this.instance.settings[prop] = changes[prop].currentValue;
                      }
                      if (prop == 'invalid') {
                          invalidChange = true;
                      }
                      if (prop == 'data') {
                          dataChange = true;
                      }
                      cloneChange = true;
                  }
                  else {
                      newOptions[prop] = changes[prop].currentValue;
                      optionChange = true;
                  }
              }
              else if (!changes[prop].firstChange && prop !== 'value') {
                  newOptions = extend$1(changes[prop].currentValue, newOptions);
                  optionChange = true;
              }
              else if (changes[prop].firstChange) {
                  if (prop !== 'options' && prop !== 'value') {
                      this.inlineOptionsObj[prop] = changes[prop].currentValue;
                  }
              }
          }
          if (cloneChange) {
              extend$1(newOptions, this.cloneDictionary);
          }
          if (optionChange || cloneChange) {
              this.updateOptions(newOptions, optionChange, invalidChange, dataChange);
          }
      };
      MbscBase.decorators = [
          { type: core.Directive, args: [{ selector: '[mbsc-b]' },] },
      ];
      MbscBase.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
      ]; };
      MbscBase.propDecorators = {
          'options': [{ type: core.Input, args: ['mbsc-options',] },],
          'cssClass': [{ type: core.Input },],
          'theme': [{ type: core.Input },],
          'themeVariant': [{ type: core.Input },],
          'lang': [{ type: core.Input },],
          'rtl': [{ type: core.Input },],
          'responsive': [{ type: core.Input },],
          'onInit': [{ type: core.Output },],
          'onDestroy': [{ type: core.Output },],
      };
      return MbscBase;
  }());
  var MbscValueBase = (function (_super) {
      __extends(MbscValueBase, _super);
      function MbscValueBase(initialElem, zone) {
          var _this = _super.call(this, initialElem, zone) || this;
          _this.initialValue = undefined;
          return _this;
      }
      MbscValueBase.prototype.setNewValue = function (v) { };
      MbscValueBase.prototype.setNewValueProxy = function (v) {
          if (!this.instance) {
              this.initialValue = v;
          }
          this.setNewValue(v);
      };
      MbscValueBase.decorators = [
          { type: core.Directive, args: [{ selector: '[mbsc-v-b]' },] },
      ];
      MbscValueBase.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
      ]; };
      return MbscValueBase;
  }(MbscBase));
  var MbscCloneBase = (function (_super) {
      __extends(MbscCloneBase, _super);
      function MbscCloneBase(initElem, zone) {
          var _this = _super.call(this, initElem, zone) || this;
          _this.cloneDictionary = {};
          return _this;
      }
      MbscCloneBase.prototype.makeClone = function (setting, value) {
          if (value) {
              this.cloneDictionary[setting] = [];
              for (var i = 0; i < value.length; i++) {
                  this.cloneDictionary[setting].push(value[i]);
              }
          }
          else {
              this.cloneDictionary[setting] = value;
          }
      };
      MbscCloneBase.prototype.ngDoCheck = function () {
          var changed = false, data = false, invalid = false;
          for (var key in this.cloneDictionary) {
              if (this[key] !== undefined && !deepEqualsArray(this[key], this.cloneDictionary[key])) {
                  this.makeClone(key, this[key]);
                  this.instance.settings[key] = this[key];
                  changed = true;
                  if (key == 'invalid') {
                      invalid = true;
                  }
                  if (key == 'data') {
                      data = true;
                  }
              }
          }
          if (changed && this.instance) {
              this.updateOptions(this.cloneDictionary, false, invalid, data);
          }
      };
      MbscCloneBase.prototype.ngOnInit = function () {
          for (var key in this.cloneDictionary) {
              this.makeClone(key, this[key]);
          }
      };
      MbscCloneBase.decorators = [
          { type: core.Directive, args: [{ selector: '[mbsc-c-b]' },] },
      ];
      MbscCloneBase.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
      ]; };
      return MbscCloneBase;
  }(MbscValueBase));
  var MbscControlBase = (function (_super) {
      __extends(MbscControlBase, _super);
      function MbscControlBase(initialElement, zone, control, _inputService, _view) {
          var _this = _super.call(this, initialElement, zone) || this;
          _this.control = control;
          _this._inputService = _inputService;
          _this._view = _view;
          _this._needsTimeout = true;
          _this.onChange = function () { };
          _this.onTouch = function () { };
          _this.onChangeEmitter = new core.EventEmitter();
          _this.oldAccessor = null;
          _this.overwriteAccessor();
          if (_inputService) {
              _inputService.isControlSet = true;
          }
          return _this;
      }
      Object.defineProperty(MbscControlBase.prototype, "optionExtensions", {
          get: function () {
              var _this = this;
              var externalOnClose = this.options && this.options.onClose;
              var externalOnFill = this.options && this.options.onFill;
              var onCloseEmitter = this.onClose;
              return {
                  onFill: function (event, inst) {
                      if (_this.oldAccessor) {
                          _this.oldAccessor.writeValue(event.valueText);
                      }
                      else {
                          var ionInput = _this.getIonInput();
                          if (ionInput) {
                              ionInput.value = event.valueText;
                          }
                      }
                      if (externalOnFill) {
                          externalOnFill(event, inst);
                      }
                  },
                  onClose: function (event, inst) {
                      _this.onTouch();
                      if (externalOnClose) {
                          externalOnClose(event, inst);
                      }
                      if (onCloseEmitter) {
                          event.inst = inst;
                          onCloseEmitter.emit(event);
                      }
                  }
              };
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MbscControlBase.prototype, "enableManualEdit", {
          get: function () {
              var nsf = this.showOnFocus === false || this.options.showOnFocus === false, nst = this.showOnTap === false || this.options.showOnTap === false;
              return nsf && nst;
          },
          enumerable: true,
          configurable: true
      });
      MbscControlBase.prototype.handleChange = function (element) {
          var that = this;
          $$1(element || this.element).on('change', function () {
              that.zone.run(function () {
                  var elmValue = that.element.value;
                  var instValue = that.instance._value;
                  if (elmValue !== instValue && (instValue !== null || elmValue !== '') && that.enableManualEdit) {
                      that.instance.setVal(elmValue, true, true);
                  }
                  else {
                      var value = that.instance.getVal();
                      if (that.control) {
                          if (!valueEquals(value, that.control.model)) {
                              that.onChange(value);
                              that.control.control.patchValue(value);
                          }
                      }
                      else {
                          that.onChangeEmitter.emit(value);
                      }
                  }
              });
          });
          function valueEquals(v1, v2) {
              if (v1 === v2) {
                  return true;
              }
              if (v1 instanceof Date && v2 instanceof Date) {
                  return (+v1) === (+v2);
              }
              return false;
          }
      };
      MbscControlBase.prototype.overwriteAccessor = function () {
          if (this.control) {
              if (this.control.valueAccessor !== this) {
                  this.oldAccessor = this.control.valueAccessor;
              }
              this.control.valueAccessor = this;
          }
      };
      MbscControlBase.prototype.ngAfterViewInit = function () {
          _super.prototype.ngAfterViewInit.call(this);
          this.handleChange();
          this.overwriteAccessor();
          if (this.control && this.control._setUpControl) {
              this.control._setUpControl();
          }
      };
      MbscControlBase.prototype.registerOnChange = function (fn) {
          this.onChange = fn;
      };
      MbscControlBase.prototype.registerOnTouched = function (fn) {
          this.onTouch = fn;
      };
      MbscControlBase.prototype.setDisabledState = function (isDisabled) {
          this.disabled = isDisabled;
          if (this.oldAccessor && this.oldAccessor.setDisabledState) {
              this.oldAccessor.setDisabledState(isDisabled);
          }
          if (this.instance && this.instance.disable && this.instance.enable) {
              if (isDisabled) {
                  this.instance.disable();
              }
              else {
                  this.instance.enable();
              }
          }
      };
      MbscControlBase.prototype.writeValue = function (v) {
          var _this = this;
          if (this._needsTimeout) {
              this.pendingValue = v;
              setTimeout(function () {
                  _this.pendingValue = undefined;
                  _this.setNewValueProxy(v);
              });
          }
          else {
              this.setNewValueProxy(v);
          }
      };
      MbscControlBase.decorators = [
          { type: core.Directive, args: [{ selector: '[mbsc-cc-b]' },] },
      ];
      MbscControlBase.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, },
          { type: MbscInputService, },
          { type: core.ViewContainerRef, },
      ]; };
      MbscControlBase.propDecorators = {
          'labelStyle': [{ type: core.Input, args: ['label-style',] },],
          'inputStyle': [{ type: core.Input, args: ['input-style',] },],
          'showOnFocus': [{ type: core.Input },],
          'showOnTap': [{ type: core.Input },],
          'disabled': [{ type: core.Input },],
      };
      return MbscControlBase;
  }(MbscCloneBase));
  var MbscFrameBase = (function (_super) {
      __extends(MbscFrameBase, _super);
      function MbscFrameBase(initialElem, zone, control, _inputService, view) {
          var _this = _super.call(this, initialElem, zone, control, _inputService, view) || this;
          _this.onBeforeClose = new core.EventEmitter();
          _this.onBeforeShow = new core.EventEmitter();
          _this.onCancel = new core.EventEmitter();
          _this.onClose = new core.EventEmitter();
          _this.onFill = new core.EventEmitter();
          _this.onMarkupReady = new core.EventEmitter();
          _this.onPosition = new core.EventEmitter();
          _this.onShow = new core.EventEmitter();
          return _this;
      }
      Object.defineProperty(MbscFrameBase.prototype, "inline", {
          get: function () {
              return (this.display || (this.options && this.options.display)) === 'inline';
          },
          enumerable: true,
          configurable: true
      });
      MbscFrameBase.prototype.ngOnInit = function () {
          this.cloneDictionary.invalid = [];
          this.cloneDictionary.valid = [];
          _super.prototype.ngOnInit.call(this);
      };
      MbscFrameBase.decorators = [
          { type: core.Directive, args: [{ selector: '[mbsc-fr-b]' },] },
      ];
      MbscFrameBase.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, },
          { type: MbscInputService, },
          { type: core.ViewContainerRef, },
      ]; };
      MbscFrameBase.propDecorators = {
          'options': [{ type: core.Input },],
          'dropdown': [{ type: core.Input },],
          'anchor': [{ type: core.Input },],
          'animate': [{ type: core.Input },],
          'buttons': [{ type: core.Input },],
          'closeOnOverlayTap': [{ type: core.Input },],
          'context': [{ type: core.Input },],
          'display': [{ type: core.Input },],
          'showInput': [{ type: core.Input },],
          'focusOnClose': [{ type: core.Input },],
          'focusTrap': [{ type: core.Input },],
          'headerText': [{ type: core.Input },],
          'scrollLock': [{ type: core.Input },],
          'touchUi': [{ type: core.Input },],
          'onBeforeClose': [{ type: core.Output },],
          'onBeforeShow': [{ type: core.Output },],
          'onCancel': [{ type: core.Output },],
          'onClose': [{ type: core.Output },],
          'onFill': [{ type: core.Output },],
          'onMarkupReady': [{ type: core.Output },],
          'onPosition': [{ type: core.Output },],
          'onShow': [{ type: core.Output },],
      };
      return MbscFrameBase;
  }(MbscControlBase));
  var MbscScrollerBase = (function (_super) {
      __extends(MbscScrollerBase, _super);
      function MbscScrollerBase(initialElement, zone, control, _inputService, view) {
          var _this = _super.call(this, initialElement, zone, control, _inputService, view) || this;
          _this.onWheelChange = new core.EventEmitter();
          _this.onSet = new core.EventEmitter();
          _this.onItemTap = new core.EventEmitter();
          _this.onClear = new core.EventEmitter();
          return _this;
      }
      MbscScrollerBase.decorators = [
          { type: core.Directive, args: [{ selector: '[mbsc-s-b]' },] },
      ];
      MbscScrollerBase.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, },
          { type: MbscInputService, },
          { type: core.ViewContainerRef, },
      ]; };
      MbscScrollerBase.propDecorators = {
          'circular': [{ type: core.Input },],
          'height': [{ type: core.Input },],
          'layout': [{ type: core.Input },],
          'maxWidth': [{ type: core.Input },],
          'minWidth': [{ type: core.Input },],
          'multiline': [{ type: core.Input },],
          'readonly': [{ type: core.Input },],
          'rows': [{ type: core.Input },],
          'showLabel': [{ type: core.Input },],
          'showScrollArrows': [{ type: core.Input },],
          'wheels': [{ type: core.Input },],
          'width': [{ type: core.Input },],
          'validate': [{ type: core.Input },],
          'cancelText': [{ type: core.Input },],
          'clearText': [{ type: core.Input },],
          'selectedText': [{ type: core.Input },],
          'setText': [{ type: core.Input },],
          'formatValue': [{ type: core.Input },],
          'parseValue': [{ type: core.Input },],
          'onWheelChange': [{ type: core.Output, args: ['onChange',] },],
          'onSet': [{ type: core.Output },],
          'onItemTap': [{ type: core.Output },],
          'onClear': [{ type: core.Output },],
      };
      return MbscScrollerBase;
  }(MbscFrameBase));
  var MbscBaseModule = (function () {
      function MbscBaseModule() {
      }
      MbscBaseModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule],
                      declarations: [MbscBase, MbscValueBase, MbscCloneBase, MbscControlBase],
                  },] },
      ];
      MbscBaseModule.ctorParameters = function () { return []; };
      return MbscBaseModule;
  }());
  var MbscFrameBaseModule = (function () {
      function MbscFrameBaseModule() {
      }
      MbscFrameBaseModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule, MbscBaseModule],
                      declarations: [MbscFrameBase],
                  },] },
      ];
      MbscFrameBaseModule.ctorParameters = function () { return []; };
      return MbscFrameBaseModule;
  }());
  var MbscScrollerBaseModule = (function () {
      function MbscScrollerBaseModule() {
      }
      MbscScrollerBaseModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule, MbscFrameBaseModule],
                      declarations: [MbscScrollerBase],
                  },] },
      ];
      MbscScrollerBaseModule.ctorParameters = function () { return []; };
      return MbscScrollerBaseModule;
  }());
  function deepEqualsArray(a1, a2) {
      if (a1 === a2) {
          return true;
      }
      else if (!a1 || !a2 || a1.length !== a2.length) {
          return false;
      }
      else {
          for (var i = 0; i < a1.length; i++) {
              if (a1[i] !== a2[i]) {
                  return false;
              }
          }
          return true;
      }
  }
  function isDateEqual(d1, d2) {
      if ((d1 && !d2) || (d2 && !d1)) {
          return false;
      }
      else if (!d1 && !d2) {
          return true;
      }
      else {
          return d1 && d2 && d1.toString() === d2.toString();
      }
  }
  function emptyOrTrue(val) {
      return (typeof (val) === 'string' && (val === 'true' || val === '')) || !!val;
  }
  var INPUT_TEMPLATE = "<mbsc-input *ngIf=\"!inline || showInput\"\n    [controlNg]=\"false\" [name]=\"name\" [theme]=\"theme\" [themeVariant]=\"themeVariant\" [label-style]=\"labelStyle\" [input-style]=\"inputStyle\" [disabled]=\"disabled\" [dropdown]=\"dropdown\" [placeholder]=\"placeholder\"\n    [error]=\"error\" [errorMessage]=\"errorMessage\"\n    [icon]=\"inputIcon\" [icon-align]=\"iconAlign\">\n    <ng-content></ng-content>\n</mbsc-input>";

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  var wrapClass = 'mbsc-input-wrap';
  var events = ['touchend', 'touchcancel', 'mousedown', 'mousemove', 'mouseup', 'mouseleave'];
  var defaults = {
    tap: hasGhostClick
  };
  var $active;

  function addIcon($control, ic) {
    var icons = {},
        control = $control[0],
        $parent = $control.parent(),
        errorMsg = $parent.find('.mbsc-err-msg'),
        align = $control.attr('data-icon-align') || 'left',
        icon = $control.attr('data-icon');

    if ($parent.hasClass(wrapClass)) {
      $parent = $parent.parent();
    } else {
      // Wrap input
      $$1('<span class="' + wrapClass + '"></span>').insertAfter($control).append($control);
    }

    if (errorMsg) {
      $parent.find('.' + wrapClass).append(errorMsg);
    }

    if (icon) {
      if (icon.indexOf('{') !== -1) {
        icons = JSON.parse(icon);
      } else {
        icons[align] = icon;
      }
    }

    if (control.type == 'file') {
      // Set icon
      icons.right = $control.attr('data-icon-upload') || 'upload';
    }

    if (icon || ic) {
      extend$1(icons, ic);
      $parent.addClass((icons.right ? 'mbsc-ic-right ' : '') + (icons.left ? ' mbsc-ic-left' : '')).find('.' + wrapClass).append('<span class="mbsc-input-fill"></span>').append(icons.left ? '<span class="mbsc-input-ic mbsc-left-ic mbsc-ic mbsc-ic-' + icons.left + '"></span>' : '').append(icons.right ? '<span class="mbsc-input-ic mbsc-right-ic mbsc-ic mbsc-ic-' + icons.right + '"></span>' : '');
    }
  }

  function addIconToggle(that, $parent, $control) {
    var icons = {},
        control = $control[0],
        toggle = $control.attr('data-password-toggle'),
        iconShow = $control.attr('data-icon-show') || 'eye',
        iconHide = $control.attr('data-icon-hide') || 'eye-blocked';

    if (toggle) {
      icons.right = control.type == 'password' ? iconShow : iconHide;
    }

    addIcon($control, icons);

    if (toggle) {
      tap(that, $parent.find('.mbsc-right-ic').addClass('mbsc-input-toggle'), function () {
        if (control.type == "text") {
          control.type = "password";
          $$1(this).addClass('mbsc-ic-' + iconShow).removeClass('mbsc-ic-' + iconHide);
        } else {
          control.type = "text";
          $$1(this).removeClass('mbsc-ic-' + iconShow).addClass('mbsc-ic-' + iconHide);
        }
      });
    }
  }

  function wrapLabel($parent, type, inputStyle, labelStyle, elm) {
    // Wrap non-empty text nodes in span with mbsc-label class
    if (type == 'segmented') {
      $parent.closest('.mbsc-segmented').addClass(inputStyle == 'box' ? 'mbsc-input-box' : '').addClass(inputStyle == 'outline' ? 'mbsc-input-outline' : '');
    } else if (type != 'button' && type != 'submit') {
      $parent.addClass('mbsc-control-w').addClass(inputStyle == 'box' ? 'mbsc-input-box' : '').addClass(inputStyle == 'outline' ? 'mbsc-input-outline' : '').addClass(labelStyle == 'inline' ? 'mbsc-label-inline' : '').addClass(labelStyle == 'stacked' ? 'mbsc-label-stacked' : '').addClass(labelStyle == 'floating' ? 'mbsc-label-floating' : '').addClass(labelStyle == 'floating' && elm.value ? 'mbsc-label-floating-active' : '').find('label').addClass('mbsc-label').each(function (i, v) {
        $$1(v).attr('title', $$1(v).text());
      });
      $parent.contents().filter(function () {
        return this.nodeType == 3 && this.nodeValue && /\S/.test(this.nodeValue);
      }).each(function () {
        $$1('<span class="mbsc-label" title="' + this.textContent.trim() + '"></span>').insertAfter(this).append(this);
      });
    }
  }

  function getRipple(theme) {
    var ripple = mobiscroll.themes.form[theme];
    return ripple && ripple.addRipple ? ripple : null;
  }

  function getAttr($elm, attr, def) {
    var v = $elm.attr(attr);
    return v === undefined || v === '' ? def : v;
  }

  function getCssClass(s) {
    var theme = getThemeName(s);
    var baseTheme = mobiscroll.themes.form[theme].baseTheme;
    return 'mbsc-' + theme + (baseTheme ? ' mbsc-' + baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr');
  }

  var FormControl =
  /*#__PURE__*/
  function () {
    function FormControl(elm, settings) {
      var _this = this;

      var s = extend$1({}, defaults, mobiscroll.settings, settings);
      var $elm = $$1(elm);
      var $p = $elm.parent();
      var $parent = $p.hasClass('mbsc-input-wrap') ? $p.parent() : $p; // Check for inline mobiscroll components

      var $frame = $elm.next().hasClass('mbsc-fr') ? $elm.next() : null;
      var type = getControlType($elm);
      var inputStyle = getAttr($elm, 'data-input-style', s.inputStyle);
      var labelStyle = getAttr($elm, 'data-label-style', s.labelStyle);

      if (elm.mbscInst) {
        elm.mbscInst.destroy();
      }

      if ($frame) {
        $frame.insertAfter($parent);
      }

      s.theme = getThemeName(s);

      if (s.rtl === undefined && s.lang && mobiscroll.i18n[s.lang]) {
        s.rtl = mobiscroll.i18n[s.lang].rtl;
      }

      wrapLabel($parent, type, inputStyle, labelStyle, elm);
      $elm.addClass('mbsc-control'); // Attach events

      this._handle = this._handle.bind(this); // Prevent 300ms click latency

      events.forEach(function (ev) {
        $elm.on(ev, _this._handle);
      }); // Touch events are added separately, needs to be passive listener

      listen(elm, 'touchstart', this._handle, {
        passive: true
      });
      listen(elm, 'touchmove', this._handle, {
        passive: true
      });
      this.settings = s;
      this._type = type;
      this._elm = elm;
      this._$elm = $elm;
      this._$parent = $parent;
      this._$frame = $frame;
      this._ripple = getRipple(s.theme);
      this._isFloating = labelStyle == 'floating' || $parent.hasClass('mbsc-label-floating');
      this.cssClass = getCssClass(s);
      this.getClassElm().addClass(this.cssClass);
      elm.mbscInst = this;
    }

    var _proto = FormControl.prototype;

    _proto.getClassElm = function getClassElm() {
      return this._$parent;
    };

    _proto.destroy = function destroy() {
      var _this2 = this;

      var $elm = this._$elm;
      var elm = this._elm;
      $elm.removeClass('mbsc-control');
      this.getClassElm().removeClass(this.cssClass);
      events.forEach(function (ev) {
        $elm.off(ev, _this2._handle);
      });
      unlisten(elm, 'touchstart', this._handle, {
        passive: true
      });
      unlisten(elm, 'touchmove', this._handle, {
        passive: true
      });
      delete elm.mbscInst;
    };

    _proto.option = function option(s) {
      extend$1(this.settings, s);
      var classElm = this.getClassElm();

      if (this.cssClass) {
        classElm.removeClass(this.cssClass);
      }

      this.cssClass = getCssClass(this.settings);
      classElm.addClass(this.cssClass);
      this._ripple = getRipple(this.settings.theme);
    };

    _proto._handle = function _handle(ev) {
      switch (ev.type) {
        case 'touchstart':
        case 'mousedown':
          this._onStart(ev);

          break;

        case 'touchmove':
        case 'mousemove':
          this._onMove(ev);

          break;

        case 'touchend':
        case 'touchcancel':
        case 'mouseup':
        case 'mouseleave':
          this._onEnd(ev);

          break;
      }
    };

    _proto._addRipple = function _addRipple(ev) {
      if (this._ripple && this._$rippleElm) {
        this._ripple.addRipple(this._$rippleElm, ev);
      }
    };

    _proto._removeRipple = function _removeRipple() {
      if (this._ripple && this._$rippleElm) {
        this._ripple.removeRipple();
      }
    };

    _proto._onStart = function _onStart(ev) {
      var elm = this._elm;

      if (testTouch(ev, elm)) {
        this._startX = getCoord(ev, 'X');
        this._startY = getCoord(ev, 'Y');

        if ($active) {
          $active.removeClass('mbsc-active');
        }

        if (!elm.disabled) {
          this._isActive = true;
          $active = this._$elm;
          $active.addClass('mbsc-active');

          this._addRipple(ev);
        }
      }

      if (ev.type == 'touchstart') {
        this._$elm.closest('.mbsc-no-touch').removeClass('mbsc-no-touch');
      }
    };

    _proto._onMove = function _onMove(ev) {
      // If movement is more than 9px, don't fire the click event handler
      if (this._isActive && Math.abs(getCoord(ev, 'X') - this._startX) > 9 || Math.abs(getCoord(ev, 'Y') - this._startY) > 9) {
        this._$elm.removeClass('mbsc-active');

        this._removeRipple();

        this._isActive = false;
      }
    };

    _proto._onEnd = function _onEnd(ev) {
      var _this3 = this;

      var control = this._elm;
      var type = this._type;

      if (this._isActive && this.settings.tap && ev.type == 'touchend' && !control.readOnly) {
        activateControl(control, type, ev);
      }

      if (this._isActive) {
        setTimeout(function () {
          _this3._$elm.removeClass('mbsc-active');

          _this3._removeRipple();
        }, 100);
      }

      this._isActive = false;
      $active = null;
    };

    return FormControl;
  }();
  mobiscroll.themes.form.mobiscroll = {};

  var events$1 = ['focus', 'change', 'blur', 'animationstart'];
  var Input =
  /*#__PURE__*/
  function (_FormControl) {
    _inheritsLoose(Input, _FormControl);

    function Input(elm, settings) {
      var _this;

      _this = _FormControl.call(this, elm, settings) || this;
      var $elm = _this._$elm;
      var $parent = _this._$parent;
      var $dummy = $parent.find('.mbsc-select-input, .mbsc-color-input');
      addIconToggle(_assertThisInitialized(_this), $parent, $elm);
      _this._checkLabel = _this._checkLabel.bind(_assertThisInitialized(_this));
      _this._mouseDown = _this._mouseDown.bind(_assertThisInitialized(_this));
      _this._setText = _this._setText.bind(_assertThisInitialized(_this));

      if (elm.type == 'file') {
        // Copy attributes and create dummy input
        var $existing = $parent.find('.mbsc-file-input');
        _this._$input = $existing.length ? $existing : $$1('<input type="text" class="' + ($elm.attr('class') || '') + ' mbsc-file-input" placeholder="' + ($elm.attr('placeholder') || '') + '"/>').insertAfter($elm); // Copy value on file upload

        $elm.on('change', _this._setText);
      }

      $parent.addClass('mbsc-input').on('mousedown', _this._mouseDown); // Attach events

      events$1.forEach(function (ev) {
        $elm.on(ev, _this._checkLabel);
      }); // Move the dummy input after the element for correct styling

      if ($dummy.length) {
        $elm.after($dummy);

        if ($dummy.hasClass('mbsc-select-input')) {
          _this._delm = $dummy[0];

          _this.refresh();
        }
      }

      return _this;
    }

    var _proto = Input.prototype;

    _proto._setText = function _setText(ev) {
      var files = ev.target.files;
      var names = [];

      for (var i = 0; i < files.length; ++i) {
        names.push(files[i].name);
      }

      this._$input.val(names);
    };

    _proto._checkLabel = function _checkLabel(ev) {
      if (this._isFloating) {
        // In case of select we need to check the dummy element
        var elm = this._delm || this._elm; // In case of autofill in webkit browsers the animationstart event will fire 
        // due to the empty animation added in the css,
        // because there's no other event in case of the initial autofill

        if (elm.value || document.activeElement === elm || ev && (ev.type == 'focus' || ev.type == 'animationstart' && this._$elm.is('*:-webkit-autofill'))) {
          this._$parent.addClass('mbsc-label-floating-active');
        } else {
          this._$parent.removeClass('mbsc-label-floating-active');
        }
      }
    };

    _proto._mouseDown = function _mouseDown(ev) {
      // Will prevent floating label animation when loosing focus only for a brief moment
      if (document.activeElement === this._elm && ev.target !== this._elm) {
        ev.preventDefault();
      }
    };

    _proto.refresh = function refresh() {
      this._checkLabel();
    };

    _proto.destroy = function destroy() {
      var _this2 = this;

      _FormControl.prototype.destroy.call(this);

      this._$parent.off('mousedown', this._mouseDown).removeClass('mbsc-ic-left mbsc-ic-right').find('.mbsc-input-ic').remove();

      this._$parent.find('.mbsc-input-fill').remove();

      events$1.forEach(function (ev) {
        _this2._$elm.off(ev, _this2._checkLabel);
      });

      this._$elm.off('change', this._setText);
    };

    return Input;
  }(FormControl); // Init mbsc-input elements on page load

  autoInit('[mbsc-input]', Input);

  var MbscFormBase = (function (_super) {
      __extends(MbscFormBase, _super);
      function MbscFormBase(hostElem, _formService, zone) {
          var _this = _super.call(this, hostElem, zone) || this;
          _this._formService = _formService;
          _this.disabled = false;
          return _this;
      }
      MbscFormBase.prototype.ngOnInit = function () {
          this._inheritedOptions = this._formService ? this._formService.options : {};
      };
      MbscFormBase.decorators = [
          { type: core.Directive, args: [{ selector: '[mbsc-f-b]' },] },
      ];
      MbscFormBase.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: MbscOptionsService, },
          { type: core.NgZone, },
      ]; };
      MbscFormBase.propDecorators = {
          'color': [{ type: core.Input },],
          'options': [{ type: core.Input },],
          'disabled': [{ type: core.Input },],
          'name': [{ type: core.Input },],
          '_initElem': [{ type: core.ViewChild, args: ['initElement', { static: false },] },],
      };
      return MbscFormBase;
  }(MbscBase));
  var MbscFormValueBase = (function (_super) {
      __extends(MbscFormValueBase, _super);
      function MbscFormValueBase(hostElem, _formService, _inputService, _control, zone) {
          var _this = _super.call(this, hostElem, _formService, zone) || this;
          _this._control = _control;
          _this.onChange = function () { };
          _this.onTouch = function () { };
          _this.errorMessage = '';
          _this.valueChangeEmitter = new core.EventEmitter();
          if (_control && (!_inputService || !_inputService.isControlSet)) {
              if (_control.valueAccessor && _control.valueAccessor.oldAccessor !== undefined) {
                  _control.valueAccessor.oldAccessor = _this;
              }
              else {
                  _control.valueAccessor = _this;
              }
          }
          return _this;
      }
      Object.defineProperty(MbscFormValueBase.prototype, "readonly", {
          set: function (val) {
              this._readonly = emptyOrTrue(val);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MbscFormValueBase.prototype, "innerValue", {
          get: function () {
              return this._value;
          },
          set: function (v) {
              this._value = v;
              this.onChange(v);
              this.valueChangeEmitter.emit(v);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MbscFormValueBase.prototype, "value", {
          set: function (v) {
              this._value = v;
              this.refresh();
          },
          enumerable: true,
          configurable: true
      });
      MbscFormValueBase.prototype.registerOnChange = function (fn) {
          this.onChange = fn;
      };
      MbscFormValueBase.prototype.registerOnTouched = function (fn) {
          this.onTouch = fn;
      };
      MbscFormValueBase.prototype.setDisabledState = function (isDisabled) {
          this.disabled = isDisabled;
      };
      MbscFormValueBase.prototype.writeValue = function (v) {
          this._value = v;
          this.refresh();
      };
      MbscFormValueBase.prototype.refresh = function () {
          var _this = this;
          if (this.instance && this.instance.refresh) {
              setTimeout(function () {
                  _this.instance.refresh();
              });
          }
          else {
              this._needRefresh = true;
          }
      };
      MbscFormValueBase.prototype.ngAfterViewInit = function () {
          _super.prototype.ngAfterViewInit.call(this);
          if (this._needRefresh) {
              this.refresh();
          }
      };
      MbscFormValueBase.decorators = [
          { type: core.Directive, args: [{ selector: '[mbsc-fv-b]' },] },
      ];
      MbscFormValueBase.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: forms.NgControl, },
          { type: core.NgZone, },
      ]; };
      MbscFormValueBase.propDecorators = {
          'readonly': [{ type: core.Input },],
          'value': [{ type: core.Input },],
          'error': [{ type: core.Input },],
          'errorMessage': [{ type: core.Input },],
          'valueChangeEmitter': [{ type: core.Output, args: ['valueChange',] },],
      };
      return MbscFormValueBase;
  }(MbscFormBase));
  var MbscInputBase = (function (_super) {
      __extends(MbscInputBase, _super);
      function MbscInputBase(initialElem, _formService, _inputService, _control, zone) {
          var _this = _super.call(this, initialElem, _formService, _inputService, _control, zone) || this;
          _this.type = 'text';
          _this.placeholder = '';
          return _this;
      }
      MbscInputBase.decorators = [
          { type: core.Directive, args: [{ selector: '[mbsc-i-b]' },] },
      ];
      MbscInputBase.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: forms.NgControl, },
          { type: core.NgZone, },
      ]; };
      MbscInputBase.propDecorators = {
          'autocomplete': [{ type: core.Input },],
          'autocapitalize': [{ type: core.Input },],
          'autocorrect': [{ type: core.Input },],
          'spellcheck': [{ type: core.Input },],
          'autofocus': [{ type: core.Input },],
          'minlength': [{ type: core.Input },],
          'maxlength': [{ type: core.Input },],
          'required': [{ type: core.Input },],
          'icon': [{ type: core.Input },],
          'iconAlign': [{ type: core.Input, args: ['icon-align',] },],
          'type': [{ type: core.Input },],
          'passwordToggle': [{ type: core.Input, args: ['password-toggle',] },],
          'iconShow': [{ type: core.Input, args: ['icon-show',] },],
          'iconHide': [{ type: core.Input, args: ['icon-hide',] },],
          'iconUpload': [{ type: core.Input, args: ['icon-upload',] },],
          'inputStyle': [{ type: core.Input, args: ['input-style',] },],
          'labelStyle': [{ type: core.Input, args: ['label-style',] },],
          'placeholder': [{ type: core.Input },],
      };
      return MbscInputBase;
  }(MbscFormValueBase));
  var MbscInput = (function (_super) {
      __extends(MbscInput, _super);
      function MbscInput(initialElem, _formService, _inputService, _control, zone) {
          var _this = _super.call(this, initialElem, _formService, _inputService, _control, zone) || this;
          _this._inputService = _inputService;
          _this.controlNg = true;
          _this.dropdown = false;
          _inputService.input = _this;
          return _this;
      }
      MbscInput.prototype.initControl = function () {
          var _this = this;
          var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
          this.instance = new Input(this._initElem.nativeElement, options);
          setTimeout(function () {
              _this.instance.refresh();
          });
      };
      MbscInput.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-input',
                      host: {
                          '[class.mbsc-control-ng]': 'controlNg',
                          '[class.mbsc-err]': 'error'
                      },
                      template: "\n        <label\n            [class.mbsc-err]=\"error\" [class.mbsc-select]=\"dropdown\"\n            [class.mbsc-input-box]=\"inputStyle == 'box'\"\n            [class.mbsc-input-outline]=\"inputStyle == 'outline'\"\n            [class.mbsc-label-stacked]=\"labelStyle == 'stacked'\"\n            [class.mbsc-label-inline]=\"labelStyle == 'inline'\"\n            [class.mbsc-label-floating]=\"labelStyle == 'floating'\"\n        >\n            <ng-content></ng-content>\n            <span class=\"mbsc-input-wrap\">\n                <input #initElement [type]=\"type\" [placeholder]=\"placeholder\" [(ngModel)]=\"innerValue\" (blur)=\"onTouch($event)\"\n                    [attr.name]=\"name\"\n                    [attr.data-icon]=\"icon ? icon : null\"\n                    [attr.data-icon-align]=\"iconAlign ? iconAlign : null\"\n                    [attr.data-password-toggle]=\"passwordToggle ? 'true': null\"\n                    [attr.data-icon-show]=\"iconShow ? iconShow : null\"\n                    [attr.data-icon-hide]=\"iconHide ? iconHide : null\"\n                    [attr.data-icon-upload]=\"iconUpload ? iconUpload : null\"\n                    [attr.min]=\"min\"\n                    [attr.max]=\"max\"\n                    [attr.minlength]=\"minlength\"\n                    [attr.maxlength]=\"maxlength\"\n                    [attr.autocomplete]=\"autocomplete\"\n                    [attr.autocapitalize]=\"autocapitalize\"\n                    [attr.autocorrect]=\"autocorrect\"\n                    [attr.spellcheck]=\"spellcheck\"\n                    [attr.autofocus]=\"autofocus\"\n                    [attr.step]=\"step\"\n                    [attr.pattern]=\"pattern\"\n                    [attr.required]=\"required\"\n                    [attr.accept]=\"accept\"\n                    [attr.multiple]=\"multiple\"\n                    [disabled]=\"disabled\"\n                    [readonly]=\"_readonly\" />\n                <span *ngIf=\"dropdown\" class=\"mbsc-select-ic mbsc-ic mbsc-ic-arrow-down5\"></span>\n                <span *ngIf=\"error && errorMessage\" class=\"mbsc-err-msg\">{{errorMessage}}</span>\n            </span>\n        </label>\n    ",
                      providers: [MbscInputService]
                  },] },
      ];
      MbscInput.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: core.NgZone, },
      ]; };
      MbscInput.propDecorators = {
          'min': [{ type: core.Input },],
          'max': [{ type: core.Input },],
          'step': [{ type: core.Input },],
          'pattern': [{ type: core.Input },],
          'accept': [{ type: core.Input },],
          'multiple': [{ type: core.Input },],
          'controlNg': [{ type: core.Input },],
          'dropdown': [{ type: core.Input },],
      };
      return MbscInput;
  }(MbscInputBase));
  var MbscInputModule = (function () {
      function MbscInputModule() {
      }
      MbscInputModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [forms.FormsModule, common.CommonModule, MbscBaseModule],
                      declarations: [MbscInput, MbscInputBase, MbscFormBase, MbscFormValueBase],
                      exports: [MbscInput]
                  },] },
      ];
      MbscInputModule.ctorParameters = function () { return []; };
      return MbscInputModule;
  }());

  function createStepper($elm, action, delay, isReadOnly, stopProp, ripple) {
    var $btn,
        changed,
        index,
        running,
        source,
        startX,
        startY,
        step,
        timer,
        check = isReadOnly || noop;

    function onBtnStart(ev) {
      var proceed;
      $btn = $$1(ev.currentTarget);
      step = +$btn.attr('data-step');
      index = +$btn.attr('data-index');
      changed = true;

      if (stopProp) {
        ev.stopPropagation();
      }

      if (ev.type == 'touchstart') {
        $btn.closest('.mbsc-no-touch').removeClass('mbsc-no-touch');
      }

      if (ev.type == 'mousedown') {
        // Prevent focus
        ev.preventDefault();
      }

      if (ev.type != 'keydown') {
        //e.preventDefault();
        startX = getCoord(ev, 'X');
        startY = getCoord(ev, 'Y');
        proceed = testTouch(ev, this);
      } else {
        proceed = ev.keyCode === 32;
      }

      if (!running && proceed && !$btn.hasClass('mbsc-disabled')) {
        if (start(index, step, ev)) {
          $btn.addClass('mbsc-active');

          if (ripple) {
            ripple.addRipple($btn.find('.mbsc-segmented-content'), ev);
          }
        }

        if (ev.type == 'mousedown') {
          $$1(document).on('mousemove', onBtnMove).on('mouseup', onBtnEnd);
        }
      }
    }

    function onBtnMove(ev) {
      if (Math.abs(startX - getCoord(ev, 'X')) > 7 || Math.abs(startY - getCoord(ev, 'Y')) > 7) {
        changed = true;
        stop();
      }
    }

    function onBtnEnd(ev) {
      if (ev.type == 'touchend') {
        // Prevents iOS scroll on double tap
        ev.preventDefault();
      }

      stop();

      if (ev.type == 'mouseup') {
        $$1(document).off('mousemove', onBtnMove).off('mouseup', onBtnEnd);
      }
    }

    function stop() {
      running = false;
      clearInterval(timer);

      if ($btn) {
        $btn.removeClass('mbsc-active');

        if (ripple) {
          setTimeout(function () {
            ripple.removeRipple();
          }, 100);
        }
      }
    }

    function start(i, st, ev) {
      if (!running && !check(i)) {
        index = i;
        step = st;
        source = ev;
        running = true;
        changed = false;
        setTimeout(tick, 100);
      }

      return running;
    }

    function tick() {
      if ($btn && $btn.hasClass('mbsc-disabled')) {
        stop();
        return;
      }

      if (running || !changed) {
        changed = true;
        action(index, step, source, tick);
      }

      if (running && delay) {
        clearInterval(timer);
        timer = setInterval(function () {
          action(index, step, source);
        }, delay);
      }
    }

    function destroy() {
      $elm.each(function (i, el) {
        unlisten(el, 'touchstart', onBtnStart, {
          passive: true
        });
        unlisten(el, 'mousedown', onBtnStart);
        unlisten(el, 'keydown', onBtnStart);
        unlisten(el, 'touchmove', onBtnMove, {
          passive: true
        });
        unlisten(el, 'touchend', onBtnEnd);
        unlisten(el, 'touchcancel', onBtnEnd);
        unlisten(el, 'keyup', onBtnEnd);
      });
    }

    $elm.each(function (i, el) {
      listen(el, 'touchstart', onBtnStart, {
        passive: true
      });
      listen(el, 'mousedown', onBtnStart);
      listen(el, 'keydown', onBtnStart);
      listen(el, 'touchmove', onBtnMove, {
        passive: true
      });
      listen(el, 'touchend', onBtnEnd);
      listen(el, 'touchcancel', onBtnEnd);
      listen(el, 'keyup', onBtnEnd);
    });
    return {
      start: start,
      stop: stop,
      destroy: destroy
    };
  }

  var innerStyle = 'position:absolute;left:0;top:0;';
  var style = innerStyle + 'right:0;bottom:0;overflow:hidden;z-index:-1;';
  var markup = '<div style="' + style + '"><div style="' + innerStyle + '"></div></div>' + '<div style="' + style + '"><div style="' + innerStyle + 'width:200%;height:200%;"></div></div>';
  var observer;
  var count = 0;
  function resizeObserver(el, callback, zone) {
    function reset() {
      expandChild.style.width = '100000px';
      expandChild.style.height = '100000px';
      expand.scrollLeft = 100000;
      expand.scrollTop = 100000;
      shrink.scrollLeft = 100000;
      shrink.scrollTop = 100000;
    }

    function checkHidden() {
      var now = new Date();
      hiddenRafId = 0;

      if (!stopCheck) {
        if (now - lastCheck > 200 && !expand.scrollTop && !expand.scrollLeft) {
          lastCheck = now;
          reset();
        }

        if (!hiddenRafId) {
          hiddenRafId = raf(checkHidden);
        }
      }
    }

    function onScroll() {
      if (!rafId) {
        rafId = raf(onResize);
      }
    }

    function onResize() {
      rafId = 0;
      reset();
      callback();
    }

    var expand;
    var expandChild;
    var helper;
    var hiddenRafId;
    var rafId;
    var shrink;
    var stopCheck;
    var lastCheck = 0; //let isHidden = true;

    if (window.ResizeObserver) {
      if (!observer) {
        observer = new ResizeObserver(function (entries) {
          for (var _iterator = entries, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
              if (_i >= _iterator.length) break;
              _ref = _iterator[_i++];
            } else {
              _i = _iterator.next();
              if (_i.done) break;
              _ref = _i.value;
            }

            var entry = _ref;

            entry.target.__mbscResize();
          }
        });
      }

      count++;
      el.__mbscResize = callback;
      observer.observe(el);
    } else {
      helper = document.createElement('div');
      helper.innerHTML = markup;
      helper.dir = 'ltr'; // Need this to work in rtl as well;

      shrink = helper.childNodes[1];
      expand = helper.childNodes[0];
      expandChild = expand.childNodes[0];
      el.appendChild(helper);
      expand.addEventListener('scroll', onScroll);
      shrink.addEventListener('scroll', onScroll);

      if (zone) {
        zone.runOutsideAngular(function () {
          raf(checkHidden);
        });
      } else {
        raf(checkHidden);
      }
    }

    return {
      detach: function detach() {
        if (observer) {
          count--;
          observer.unobserve(el);

          if (!count) {
            observer = null;
          }
        } else {
          el.removeChild(helper);
          stopCheck = true;
        }
      }
    };
  }

  var $activeElm,
      preventShow,
      themes = mobiscroll.themes,
      needsFixed = /(iphone|ipod)/i.test(userAgent) && majorVersion >= 7,
      isAndroid = os == 'android',
      isIOS = os == 'ios',
      isIOS8 = isIOS && majorVersion == 8,
      halfBorder = isIOS && majorVersion > 7,
      prevdef = function prevdef(ev) {
    ev.preventDefault();
  };

  var EDITABLE = 'input,select,textarea,button';
  var ALLOW_ENTER = 'textarea,button,input[type="button"],input[type="submit"]';
  var FOCUSABLE = EDITABLE + ',[tabindex="0"]';
  var Frame = function Frame(el, settings, inherit) {
    var //$ariaDiv,
    $ctx,
        $header,
        $lock,
        $markup,
        $overlay,
        $persp,
        $popup,
        $wnd,
        $wrapper,
        buttons,
        btn,
        ctx,
        doAnim,
        hasContext,
        isModal,
        isInserted,
        isPointer,
        markup,
        modalWidth,
        modalHeight,
        needsDimensions,
        needsLock,
        observer,
        overlay,
        popup,
        posDebounce,
        prevInst,
        s,
        scrollLock,
        touched,
        trigger,
        wndWidth,
        wndHeight,
        that = this,
        $elm = $$1(el),
        elmList = [],
        lastFocus = new Date();

    function onBtnStart(ev) {
      // Need this to prevent opening of sidemenus or similar
      if (s.stopProp) {
        ev.stopPropagation();
      }

      var b = closest(this, ev.target, '.mbsc-fr-btn-e');

      if (!b) {
        return;
      } // Can't call preventDefault here, it kills page scroll


      if (btn) {
        btn.removeClass('mbsc-active');
      }

      btn = $$1(b); // Active button

      if (!btn.hasClass('mbsc-disabled') && !btn.hasClass('mbsc-fr-btn-nhl')) {
        btn.addClass('mbsc-active');
      }

      if (ev.type === 'mousedown') {
        $$1(document).on('mouseup', onBtnEnd);
      }
    }

    function onBtnEnd(ev) {
      if (btn) {
        btn.removeClass('mbsc-active');
        btn = null;
      }

      if (ev.type === 'mouseup') {
        $$1(document).off('mouseup', onBtnEnd);
      }
    }

    function onScroll(ev) {
      if (scrollLock && markup.contains(ev.target)) {
        ev.preventDefault();
      }
    }

    function onWndKeyDown(ev) {
      if (mobiscroll.activeInstance == that) {
        if (ev.keyCode == 13 && (!$$1(ev.target).is(ALLOW_ENTER) || ev.shiftKey)) {
          that.select();
        } else if (ev.keyCode == 27) {
          that.cancel();
        }
      }
    }

    function onShow(prevFocus) {
      if (!prevFocus && !isAndroid && that._activeElm) {
        //overlay.focus();
        lastFocus = new Date();

        that._activeElm.focus();
      } //that.ariaMessage(s.ariaMessage);

    }

    function onHide(prevAnim) {
      var $activeEl = $activeElm,
          focus = s.focusOnClose;

      that._markupRemove();

      $markup.remove();

      if (isModal) {
        ctx.mbscModals--;

        if (s.scrollLock) {
          ctx.mbscLock--;
        }

        if (!ctx.mbscLock) {
          $lock.removeClass('mbsc-fr-lock');
        }

        if (needsLock) {
          ctx.mbscIOSLock--;

          if (!ctx.mbscIOSLock) {
            $lock.removeClass('mbsc-fr-lock-ios');
            $ctx.css({
              top: '',
              left: ''
            });
            $wnd.scrollLeft(ctx.mbscScrollLeft);
            $wnd.scrollTop(ctx.mbscScrollTop);
          }
        } // The follwing should be done only if no other
        // instance was opened during the hide animation


        if (!ctx.mbscModals) {
          $lock.removeClass('mbsc-fr-lock-ctx');
        }

        if (!ctx.mbscModals || prevInst) {
          // Put focus back to the last active element
          if (!prevAnim) {
            if (!$activeEl) {
              $activeEl = $elm;
            }

            setTimeout(function () {
              if (focus === undefined || focus === true) {
                preventShow = true;
                $activeEl[0].focus();
              } else if (focus) {
                $$1(focus)[0].focus();
              }
            }, 200);
          }
        }
      }

      prevInst = undefined;
      isInserted = false;
      trigger('onHide');
    }

    function onPosition() {
      clearTimeout(posDebounce);
      posDebounce = setTimeout(function () {
        if (that.position(true)) {
          // Trigger reflow, needed on iOS safari, when orientation is changed
          popup.style.visibility = 'hidden';
          popup.offsetHeight;
          popup.style.visibility = '';
        }
      }, 200);
    }

    function onFocus(ev) {
      if (mobiscroll.activeInstance == that && ev.target.nodeType && !overlay.contains(ev.target) && new Date() - lastFocus > 100) {
        lastFocus = new Date();

        that._activeElm.focus();
      }
    }

    function insertMarkup(prevAnim, prevFocus) {
      function onAnimEnd() {
        $markup.off(animEnd, onAnimEnd).removeClass('mbsc-anim-in mbsc-anim-trans mbsc-anim-trans-' + doAnim).find('.mbsc-fr-popup').removeClass('mbsc-anim-' + doAnim);
        onShow(prevFocus);
      }

      function onOverlayStart(ev) {
        if (!target && ev.target == overlay) {
          target = true;
          moved = false;
          startX = getCoord(ev, 'X');
          startY = getCoord(ev, 'Y');
        }
      }

      function onOverlayMove(ev) {
        if (target && !moved && (Math.abs(getCoord(ev, 'X') - startX) > 9 || Math.abs(getCoord(ev, 'Y') - startY) > 9)) {
          moved = true;
        }
      } // Might be not visible if immediately hidden


      if (!that._isVisible) {
        return;
      } // Show


      if (isModal) {
        $markup.appendTo($ctx);
      } else if ($elm.is('div') && !that._hasContent) {
        // Insert inside the element on which was initialized
        $elm.empty().append($markup);
      } else {
        // Insert after the element
        if ($elm.hasClass('mbsc-control')) {
          var $wrap = $elm.closest('.mbsc-control-w');
          $markup.insertAfter($wrap);

          if ($wrap.hasClass('mbsc-select')) {
            $wrap.addClass('mbsc-select-inline');
          }
        } else {
          $markup.insertAfter($elm);
        }
      }

      isInserted = true;

      that._markupInserted($markup);

      trigger('onMarkupInserted', {
        target: markup
      });

      if (isModal && s.closeOnOverlayTap) {
        var moved, target, startX, startY;
        listen(overlay, 'touchstart', onOverlayStart, {
          passive: true
        });
        listen(overlay, 'touchmove', onOverlayMove, {
          passive: true
        });
        $overlay.on('mousedown', onOverlayStart).on('mousemove', onOverlayMove).on('touchcancel', function () {
          target = false;
        }).on('touchend click', function (ev) {
          if (target && !moved) {
            that.cancel();

            if (ev.type == 'touchend') {
              preventClick();
            }
          }

          target = false;
        });
      }

      $markup.on('mousedown', '.mbsc-btn-e,.mbsc-fr-btn-e', prevdef).on('keydown', '.mbsc-fr-btn-e', function (ev) {
        if (ev.keyCode == 32) {
          // Space
          ev.preventDefault();
          ev.stopPropagation();
          this.click();
        }
      }).on('keydown', function (ev) {
        // Trap focus inside modal
        if (ev.keyCode == 32 && !$$1(ev.target).is(EDITABLE)) {
          // Prevent page scroll on space press
          ev.preventDefault();
        } else if (ev.keyCode == 9 && isModal && s.focusTrap) {
          // Tab
          var $focusable = $markup.find(FOCUSABLE).filter(function () {
            return this.offsetWidth > 0 || this.offsetHeight > 0;
          }),
              index = $focusable.index($$1(':focus', $markup)),
              i = $focusable.length - 1,
              target = 0;

          if (ev.shiftKey) {
            i = 0;
            target = -1;
          }

          if (index === i) {
            $focusable.eq(target)[0].focus();
            ev.preventDefault();
          }
        }
      }).on('touchend', '.mbsc-fr-btn-e', onBtnEnd);
      listen(markup, 'touchstart', onBtnStart, {
        passive: true
      });
      listen(markup, 'mousedown', onBtnStart); // Need event capture for this

      listen(markup, 'touchstart', function () {
        if (!touched) {
          touched = true;
          $ctx.find('.mbsc-no-touch').removeClass('mbsc-no-touch');
        }
      }, {
        passive: true,
        capture: true
      }); // Init buttons

      $$1.each(buttons, function (i, b) {
        that.tap($$1('.mbsc-fr-btn' + i, $markup), function (ev) {
          b = isString(b) ? that.buttons[b] : b;
          (isString(b.handler) ? that.handlers[b.handler] : b.handler).call(this, ev, that);
        }, true);
      });

      that._attachEvents($markup); // Set position


      if (that.position() === false) {
        return;
      }

      if (isModal || that._checkSize) {
        observer = resizeObserver(markup, onPosition, s.zone);
      }

      if (isModal) {
        $markup.removeClass('mbsc-fr-pos');

        if (doAnim && !prevAnim) {
          $markup.addClass('mbsc-anim-in mbsc-anim-trans mbsc-anim-trans-' + doAnim).on(animEnd, onAnimEnd).find('.mbsc-fr-popup').addClass('mbsc-anim-' + doAnim);
        } else {
          onShow(prevFocus);
        }
      }

      trigger('onShow', {
        target: markup,
        valueText: that._tempValue
      });
    }

    function show(beforeShow, $elm) {
      if (that._isVisible) {
        return;
      }

      if (beforeShow) {
        beforeShow();
      }

      if (that.show() !== false) {
        $activeElm = $elm;
      }
    }

    function set() {
      that._fillValue();

      trigger('onSet', {
        valueText: that._value
      });
    }

    function cancel() {
      trigger('onCancel', {
        valueText: that._value
      });
    }

    function clear() {
      that.setVal(null, true);
    } // Call the parent constructor


    Base.call(this, el, settings, true);
    /**
     * Positions the scroller on the screen.
     */

    that.position = function (check) {
      var anchor,
          anchorWidth,
          anchorHeight,
          anchorPos,
          anchorTop,
          anchorLeft,
          arrow,
          arrowWidth,
          arrowHeight,
          docHeight,
          docWidth,
          isWrapped,
          newHeight,
          newWidth,
          oldHeight,
          oldWidth,
          width,
          top,
          left,
          css = {},
          scrollLeft = 0,
          scrollTop = 0,
          minWidth = 0,
          totalWidth = 0;

      if (!isInserted) {
        return false;
      }

      oldWidth = wndWidth;
      oldHeight = wndHeight;
      newHeight = Math.min(markup.offsetHeight, hasContext ? Infinity : window.innerHeight);
      newWidth = Math.min(markup.offsetWidth, hasContext ? Infinity : window.innerWidth);

      if (!newWidth || !newHeight || wndWidth === newWidth && wndHeight === newHeight && check) {
        return;
      }

      if (that._checkResp(newWidth)) {
        return false;
      }

      wndWidth = newWidth;
      wndHeight = newHeight;

      if (that._isFullScreen || /top|bottom/.test(s.display)) {
        // Set width, if document is larger than viewport, needs to be set before onPosition (for calendar)
        $popup.width(newWidth);
      } else if (isModal) {
        // Reset width
        $wrapper.width('');
      }

      that._position($markup); // Call position for nested mobiscroll components
      // $('.mbsc-comp', $markup).each(function () {
      //     var inst = instances[this.id];
      //     if (inst && inst !== that && inst.position) {
      //         inst.position();
      //     }
      // });


      if (!that._isFullScreen && /center|bubble/.test(s.display)) {
        $$1('.mbsc-w-p', $markup).each(function () {
          // Need fractional values here, so offsetWidth is not ok
          width = this.getBoundingClientRect().width;
          totalWidth += width;
          minWidth = width > minWidth ? width : minWidth;
        });
        isWrapped = totalWidth > newWidth - 16 || s.tabs === true;
        $wrapper.css({
          'width': that._isLiquid ? Math.min(s.maxPopupWidth, newWidth - 16) : Math.ceil(isWrapped ? minWidth : totalWidth),
          'white-space': isWrapped ? '' : 'nowrap'
        });
      }

      if (trigger('onPosition', {
        target: markup,
        popup: popup,
        hasTabs: isWrapped,
        oldWidth: oldWidth,
        oldHeight: oldHeight,
        windowWidth: newWidth,
        windowHeight: newHeight
      }) === false || !isModal) {
        return;
      }

      if (needsDimensions) {
        scrollLeft = $wnd.scrollLeft();
        scrollTop = $wnd.scrollTop();

        if (wndWidth) {
          $persp.css({
            width: '',
            height: ''
          });
        }
      }

      modalWidth = popup.offsetWidth;
      modalHeight = popup.offsetHeight;
      scrollLock = modalHeight <= newHeight && modalWidth <= newWidth;

      if (s.display == 'center') {
        left = Math.max(0, scrollLeft + (newWidth - modalWidth) / 2);
        top = Math.max(0, scrollTop + (newHeight - modalHeight) / 2);
      } else if (s.display == 'bubble') {
        anchor = s.anchor === undefined ? $elm : $$1(s.anchor);
        arrow = $$1('.mbsc-fr-arr-i', $markup)[0];
        anchorPos = anchor.offset();
        anchorTop = anchorPos.top + (hasContext ? scrollTop - $ctx.offset().top : 0);
        anchorLeft = anchorPos.left + (hasContext ? scrollLeft - $ctx.offset().left : 0);
        anchorWidth = anchor[0].offsetWidth;
        anchorHeight = anchor[0].offsetHeight;
        arrowWidth = arrow.offsetWidth;
        arrowHeight = arrow.offsetHeight; // Horizontal positioning

        left = constrain(anchorLeft - (modalWidth - anchorWidth) / 2, scrollLeft + 3, scrollLeft + newWidth - modalWidth - 3); // Vertical positioning
        // Below the input

        top = anchorTop + anchorHeight + arrowHeight / 2;

        if (top + modalHeight + 8 > scrollTop + newHeight && anchorTop - modalHeight - arrowHeight / 2 > scrollTop) {
          $popup.removeClass('mbsc-fr-bubble-bottom').addClass('mbsc-fr-bubble-top'); // Above the input

          top = anchorTop - modalHeight - arrowHeight / 2;
        } else {
          $popup.removeClass('mbsc-fr-bubble-top').addClass('mbsc-fr-bubble-bottom');
        } // Set arrow position


        $$1('.mbsc-fr-arr', $markup).css({
          left: constrain(anchorLeft + anchorWidth / 2 - (left + (modalWidth - arrowWidth) / 2), 0, arrowWidth)
        }); // Lock scroll only if popup is entirely in the viewport

        scrollLock = top > scrollTop && left > scrollLeft && top + modalHeight <= scrollTop + newHeight && left + modalWidth <= scrollLeft + newWidth;
      } else {
        left = scrollLeft;
        top = s.display == 'top' ? scrollTop : Math.max(0, scrollTop + newHeight - modalHeight);
      }

      if (needsDimensions) {
        // If top + modal height > doc height, increase doc height
        docHeight = Math.max(top + modalHeight, hasContext ? ctx.scrollHeight : $$1(document).height());
        docWidth = Math.max(left + modalWidth, hasContext ? ctx.scrollWidth : $$1(document).width());
        $persp.css({
          width: docWidth,
          height: docHeight
        }); // Check if scroll needed

        if (s.scroll && s.display == 'bubble' && (top + modalHeight + 8 > scrollTop + newHeight || anchorTop > scrollTop + newHeight || anchorTop + anchorHeight < scrollTop)) {
          $wnd.scrollTop(Math.min(anchorTop, top + modalHeight - newHeight + 8, docHeight - newHeight));
        }
      }

      css.top = Math.floor(top);
      css.left = Math.floor(left);
      $popup.css(css);
      return true;
    };
    /**
     * Show mobiscroll on focus and click event of the parameter.
     * @param {HTMLElement} elm - Events will be attached to this element.
     * @param {Function} [beforeShow=undefined] - Optional function to execute before showing mobiscroll.
     */


    that.attachShow = function (elm, beforeShow) {
      var $label,
          $elm = $$1(elm).off('.mbsc'),
          readOnly = $elm.prop('readonly');
      tapOff($elm);

      if (s.display !== 'inline') {
        if ((s.showOnFocus || s.showOnTap) && $elm.is('input,select')) {
          $elm.prop('readonly', true).on('mousedown.mbsc', function (ev) {
            // Prevent input to get focus on tap (virtual keyboard pops up on some devices)
            ev.preventDefault();
          }).on('focus.mbsc', function () {
            if (that._isVisible) {
              // Don't allow input focus if mobiscroll is being opened
              this.blur();
            }
          });
          $label = $$1('label[for="' + $elm.attr('id') + '"]');

          if (!$label.length) {
            $label = $elm.closest('label');
          }
        }

        if (!$elm.is('select')) {
          if (s.showOnFocus) {
            $elm.on('focus.mbsc', function () {
              if (!preventShow) {
                show(beforeShow, $elm);
              } else {
                preventShow = false;
              }
            });
          }

          if (s.showOnTap) {
            $elm.on('keydown.mbsc', function (ev) {
              if (ev.keyCode == 32 || ev.keyCode == 13) {
                // Space or Enter
                ev.preventDefault();
                ev.stopPropagation();
                show(beforeShow, $elm);
              }
            });
            that.tap($elm, function (ev) {
              if (ev.isMbscTap) {
                touched = true;
              }

              show(beforeShow, $elm);
            });

            if ($label && $label.length) {
              tapOff($label);
              that.tap($label, function (ev) {
                ev.preventDefault();

                if (ev.target !== $elm[0]) {
                  show(beforeShow, $elm);
                }
              });
            }
          }
        }

        elmList.push({
          readOnly: readOnly,
          el: $elm,
          lbl: $label
        });
      }
    };
    /**
     * Set button handler.
     */


    that.select = function () {
      if (isModal) {
        that.hide(false, 'set', false, set);
      } else {
        set();
      }
    };
    /**
     * Cancel and hide the scroller instance.
     */


    that.cancel = function () {
      if (isModal) {
        that.hide(false, 'cancel', false, cancel);
      } else {
        cancel();
      }
    };
    /**
     * Clear button handler.
     */


    that.clear = function () {
      that._clearValue();

      trigger('onClear');

      if (isModal && that._isVisible && !that.live) {
        that.hide(false, 'clear', false, clear);
      } else {
        clear();
      }
    };
    /**
     * Enables the scroller and the associated input.
     */


    that.enable = function () {
      s.disabled = false;
      $$1.each(elmList, function (i, v) {
        if (v.el.is('input,select')) {
          v.el[0].disabled = false;
        }
      });
    };
    /**
     * Disables the scroller and the associated input.
     */


    that.disable = function () {
      s.disabled = true;
      $$1.each(elmList, function (i, v) {
        if (v.el.is('input,select')) {
          v.el[0].disabled = true;
        }
      });
    };
    /**
     * Shows the scroller instance.
     * @param {Boolean} prevAnim - Prevent animation if true
     * @param {Boolean} prevFocus - Prevent focusing if true
     */


    that.show = function (prevAnim, prevFocus) {
      var hasButtons, html, scrollLeft, scrollTop;

      if (s.disabled || that._isVisible) {
        return;
      } // Parse value from input


      that._readValue();

      if (trigger('onBeforeShow') === false) {
        return false;
      }

      $activeElm = null;
      doAnim = s.animate;
      buttons = s.buttons || [];
      needsDimensions = hasContext || s.display == 'bubble';
      needsLock = needsFixed && !needsDimensions && s.scrollLock;
      hasButtons = buttons.length > 0; //touched = false;

      if (doAnim !== false) {
        if (s.display == 'top') {
          doAnim = doAnim || 'slidedown';
        } else if (s.display == 'bottom') {
          doAnim = doAnim || 'slideup';
        } else if (s.display == 'center' || s.display == 'bubble') {
          doAnim = doAnim || 'pop';
        }
      }

      if (isModal) {
        wndWidth = 0;
        wndHeight = 0;

        if (needsLock && !$lock.hasClass('mbsc-fr-lock-ios')) {
          //$lock.scrollTop(0);
          ctx.mbscScrollTop = scrollTop = Math.max(0, $wnd.scrollTop());
          ctx.mbscScrollLeft = scrollLeft = Math.max(0, $wnd.scrollLeft());
          $ctx.css({
            top: -scrollTop + 'px',
            left: -scrollLeft + 'px'
          });
        }

        $lock.addClass((s.scrollLock ? 'mbsc-fr-lock' : '') + (needsLock ? ' mbsc-fr-lock-ios' : '') + (hasContext ? ' mbsc-fr-lock-ctx' : '')); // Hide virtual keyboard

        if ($$1(document.activeElement).is('input,textarea')) {
          document.activeElement.blur();
        } // Save active instance to previous


        prevInst = mobiscroll.activeInstance; // Set active instance

        mobiscroll.activeInstance = that; // Keep track of modals opened per context

        ctx.mbscModals = (ctx.mbscModals || 0) + 1;

        if (needsLock) {
          ctx.mbscIOSLock = (ctx.mbscIOSLock || 0) + 1;
        }

        if (s.scrollLock) {
          ctx.mbscLock = (ctx.mbscLock || 0) + 1;
        }
      }
      /*
      // Create wheels containers
      html = '<div lang="' + s.lang + '" class="mbsc-fr mbsc-' + s.theme +
          (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + ' mbsc-fr-' + s.display + ' ' +
          (s.cssClass || '') + ' ' +
          (s.compClass || '') +
          (that._isLiquid ? ' mbsc-fr-liq' : '') +
          (isModal ? ' mbsc-fr-pos' + ((s.showOverlay ? '' : ' mbsc-fr-no-overlay')) : '') +
          (isPointer ? ' mbsc-fr-pointer' : '') +
          (halfBorder ? ' mbsc-fr-hb' : '') +
          (touched ? '' : ' mbsc-no-touch') +
          (needsLock ? ' mbsc-platform-ios' : '') +
          (hasButtons ? (buttons.length >= 3 ? ' mbsc-fr-btn-block ' : '') : ' mbsc-fr-nobtn') + '">' +
          (isModal ? '<div class="mbsc-fr-persp">' +
              (s.showOverlay ? '<div class="mbsc-fr-overlay"></div>' : '') + // Overlay
              '<div role="dialog" class="mbsc-fr-scroll">' : '') +
          '<div class="mbsc-fr-popup' +
          (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr') +
          (s.headerText ? ' mbsc-fr-has-hdr' : '') +
          '">' + // Popup
          (s.display === 'bubble' ? '<div class="mbsc-fr-arr-w"><div class="mbsc-fr-arr-i"><div class="mbsc-fr-arr"></div></div></div>' : '') + // Bubble arrow
          (isModal ? '<div class="mbsc-fr-focus" tabindex="-1"></div>' : '') +
          '<div class="mbsc-fr-w">' + // Popup content
          //'<div aria-live="assertive" class="mbsc-fr-aria mbsc-fr-hdn"></div>' +
          (s.headerText ? '<div class="mbsc-fr-hdr">' + (isString(s.headerText) ? s.headerText : '') + '</div>' : '') + // Header
          '<div class="mbsc-fr-c">'; // Wheel group container
      */
      // --- REMOTE TRIAL CODE START ---


      html = that.remote.html1.replace('mbsc-no-touch', '') + ' mbsc-fr-' + s.display + ' ' + (s.cssClass || '') + ' ' + (s.compClass || '') + (isModal ? ' mbsc-fr-pos' + (s.showOverlay ? '' : ' mbsc-fr-no-overlay') : '') + (isPointer ? ' mbsc-fr-pointer' : '') + (that._isLiquid ? ' mbsc-fr-liq' : '') + (halfBorder ? ' mbsc-fr-hb' : '') + (touched ? '' : ' mbsc-no-touch') + that.remote.html2 + (s.headerText ? ' mbsc-fr-has-hdr' : '') + '">' + ( // Popup
      s.display === 'bubble' ? '<div class="mbsc-fr-arr-w"><div class="mbsc-fr-arr-i"><div class="mbsc-fr-arr"></div></div></div>' : '') + // Bubble arrow
      that.remote.html3 + (s.headerText ? '<div class="mbsc-fr-hdr">' + (isString(s.headerText) ? s.headerText : '') + '</div>' : '') + // Header
      '<div class="mbsc-fr-c">'; // Wheel group container
      // --- REMOTE TRIAL CODE END ---

      html += that._generateContent(); // --- REMOTE TRIAL CODE START ---

      html += that.remote.html4; // --- REMOTE TRIAL CODE END ---

      /*
      html += '</div>';
        if (hasButtons) {
          var b,
              i,
              j,
              l = buttons.length;
            html += '<div class="mbsc-fr-btn-cont">';
          for (i = 0; i < buttons.length; i++) {
              j = s.btnReverse ? l - i - 1 : i;
              b = buttons[j];
              b = isString(b) ? that.buttons[b] : b;
                if (b.handler === 'set') {
                  b.parentClass = 'mbsc-fr-btn-s';
              }
                if (b.handler === 'cancel') {
                  b.parentClass = 'mbsc-fr-btn-c';
              }
                html += '<div' + (s.btnWidth ? ' style="width:' + (100 / buttons.length) + '%"' : '') +
                  ' class="mbsc-fr-btn-w ' + (b.parentClass || '') + '">' +
                  '<div tabindex="0" role="button" class="mbsc-fr-btn' + j + ' mbsc-fr-btn-e ' +
                  (b.cssClass === undefined ? s.btnClass : b.cssClass) +
                  (b.icon ? ' mbsc-ic mbsc-ic-' + b.icon : '') + '">' + (b.text || '') + '</div></div>';
          }
          html += '</div>';
      }
      html += '</div></div></div></div>' + (isModal ? '</div></div>' : '');
      */

      $markup = $$1(html);
      $persp = $$1('.mbsc-fr-persp', $markup);
      $overlay = $$1('.mbsc-fr-scroll', $markup);
      $wrapper = $$1('.mbsc-fr-w', $markup);
      $popup = $$1('.mbsc-fr-popup', $markup);
      $header = $$1('.mbsc-fr-hdr', $markup); //$ariaDiv = $('.mbsc-fr-aria', $markup);

      markup = $markup[0];
      overlay = $overlay[0];
      popup = $popup[0];
      that._activeElm = $$1('.mbsc-fr-focus', $markup)[0];
      that._markup = $markup;
      that._isVisible = true;
      that.markup = markup;

      that._markupReady($markup);

      trigger('onMarkupReady', {
        target: markup
      }); // Attach events

      if (isModal) {
        // Enter / ESC
        $$1(window).on('keydown', onWndKeyDown); // Prevent scroll if not specified otherwise

        if (s.scrollLock) {
          listen(document, 'touchmove', onScroll, {
            passive: false
          });
          listen(document, 'mousewheel', onScroll, {
            passive: false
          });
          listen(document, 'wheel', onScroll, {
            passive: false
          });
        }

        if (s.focusTrap) {
          $wnd.on('focusin', onFocus);
        }
      }

      if (isModal) {
        // Wait for the toolbar and addressbar to appear on iOS
        setTimeout(function () {
          insertMarkup(prevAnim, prevFocus);
        }, needsLock ? 100 : 0);
      } else {
        insertMarkup(prevAnim, prevFocus);
      }
    };
    /**
     * Hides the scroller instance.
     */


    that.hide = function (prevAnim, btn, force, callback) {
      function onAnimEnd() {
        $markup.off(animEnd, onAnimEnd);
        onHide(prevAnim);
      } // If onClose handler returns false, prevent hide


      if (!that._isVisible || !force && !that._isValid && btn == 'set' || !force && trigger('onBeforeClose', {
        valueText: that._tempValue,
        button: btn
      }) === false) {
        return false;
      }

      that._isVisible = false;

      if (observer) {
        observer.detach();
        observer = null;
      }

      if (isModal) {
        if ($$1(document.activeElement).is('input,textarea') && popup.contains(document.activeElement)) {
          document.activeElement.blur();
        }

        if (mobiscroll.activeInstance == that) {
          mobiscroll.activeInstance = prevInst;
        }

        $$1(window).off('keydown', onWndKeyDown);
        $wnd.off('focusin', onFocus);
        unlisten(document, 'touchmove', onScroll, {
          passive: false
        });
        unlisten(document, 'mousewheel', onScroll, {
          passive: false
        });
        unlisten(document, 'wheel', onScroll, {
          passive: false
        });
      } // Hide wheels and overlay


      if ($markup) {
        if (isModal && isInserted && doAnim && !prevAnim) {
          $markup.addClass('mbsc-anim-out mbsc-anim-trans mbsc-anim-trans-' + doAnim).on(animEnd, onAnimEnd).find('.mbsc-fr-popup').addClass('mbsc-anim-' + doAnim);
        } else {
          onHide(prevAnim);
        }

        that._detachEvents($markup);
      }

      if (callback) {
        callback();
      } // For validation


      $elm.trigger('blur');
      trigger('onClose', {
        valueText: that._value
      });
    }; // that.ariaMessage = function (txt) {
    //     $ariaDiv.html('');
    //     setTimeout(function () {
    //         $ariaDiv.html(txt);
    //     }, 100);
    // };

    /**
     * Return true if the scroller is currently visible.
     */


    that.isVisible = function () {
      return that._isVisible;
    }; // Protected functions to override


    that.setVal = noop;
    that.getVal = noop;
    that._generateContent = noop;
    that._attachEvents = noop;
    that._detachEvents = noop;
    that._readValue = noop;
    that._clearValue = noop;
    that._fillValue = noop;
    that._markupReady = noop;
    that._markupInserted = noop;
    that._markupRemove = noop;
    that._position = noop;
    that.__processSettings = noop;
    that.__init = noop;
    that.__destroy = noop; // Generic frame functions

    /**
     * Destroys the mobiscroll instance.
     */

    that._destroy = function () {
      // Force hide without animation
      that.hide(true, false, true);
      $elm.off('.mbsc');
      tapOff($elm); // Remove all events from elements

      $$1.each(elmList, function (i, v) {
        v.el.off('.mbsc').prop('readonly', v.readOnly);
        tapOff(v.el);

        if (v.lbl) {
          v.lbl.off('.mbsc');
          tapOff(v.lbl);
        }
      });

      that.__destroy();
    };

    that._updateHeader = function () {
      var t = s.headerText,
          txt = t ? typeof t === 'function' ? t.call(el, that._tempValue) : t.replace(/\{value\}/i, that._tempValue) : '';
      $header.html(txt || '&nbsp;');
    };

    that._getRespCont = function () {
      hasContext = s.context != 'body';
      $wnd = $$1(hasContext ? s.context : window);
      return s.display == 'inline' ? $elm.is('div') ? $elm : $elm.parent() : $wnd;
    };

    that._processSettings = function (resp) {
      var b, i;

      that.__processSettings(resp);

      isPointer = !s.touchUi;

      if (isPointer) {
        s.display = resp.display || settings.display || 'bubble';
        s.buttons = resp.buttons || settings.buttons || [];
        s.showOverlay = resp.showOverlay || settings.showOverlay || false;
      } // Add default buttons


      s.buttons = s.buttons || (s.display !== 'inline' ? ['cancel', 'set'] : []); // Hide header text in inline mode by default

      s.headerText = s.headerText === undefined ? s.display !== 'inline' ? '{value}' : false : s.headerText;
      buttons = s.buttons || [];
      isModal = s.display !== 'inline';
      $ctx = $$1(s.context);
      $lock = hasContext ? $ctx : $$1('body,html');
      ctx = $ctx[0];
      that.live = true; // If no set button is found, live mode is activated

      for (i = 0; i < buttons.length; i++) {
        b = buttons[i];

        if (b == 'ok' || b == 'set' || b.handler == 'set') {
          that.live = false;
        }
      }

      that.buttons.set = {
        text: s.setText,
        icon: s.setIcon,
        handler: 'set'
      };
      that.buttons.cancel = {
        text: s.cancelText,
        icon: s.cancelIcon,
        handler: 'cancel'
      };
      that.buttons.close = {
        text: s.closeText,
        icon: s.closeIcon,
        handler: 'cancel'
      };
      that.buttons.clear = {
        text: s.clearText,
        icon: s.clearIcon,
        handler: 'clear'
      };
      that._isInput = $elm.is('input');
    };
    /**
     * Scroller initialization.
     */


    that._init = function (newSettings) {
      var wasVisible = that._isVisible,
          wasReady = wasVisible && !$markup.hasClass('mbsc-fr-pos');

      if (wasVisible) {
        that.hide(true, false, true);
      } // Unbind all events (if re-init)


      $elm.off('.mbsc');
      tapOff($elm);

      that.__init(newSettings);

      that._isLiquid = s.layout == 'liquid';

      if (isModal) {
        that._readValue();

        if (!that._hasContent && !s.skipShow) {
          that.attachShow($elm);
        }

        if (wasVisible) {
          that.show(wasReady);
        }
      } else {
        that.show();
      }

      $elm.removeClass('mbsc-cloak').filter('input, select, textarea').on('change.mbsc', function () {
        if (!that._preventChange) {
          that.setVal($elm.val(), true, false);
        }

        that._preventChange = false;
      });
    };

    that.buttons = {};
    that.handlers = {
      set: that.select,
      cancel: that.cancel,
      clear: that.clear
    };
    that._value = null;
    that._isValid = true;
    that._isVisible = false; // Constructor

    s = that.settings;
    trigger = that.trigger;

    if (!inherit) {
      that.init();
    }
  };
  Frame.prototype._defaults = {
    // Localization
    lang: 'en',
    setText: 'Set',
    selectedText: '{count} selected',
    closeText: 'Close',
    cancelText: 'Cancel',
    clearText: 'Clear',
    // Options
    context: 'body',
    maxPopupWidth: 600,
    disabled: false,
    closeOnOverlayTap: true,
    showOnFocus: isAndroid || isIOS,
    // Needed for ion-input
    showOnTap: true,
    display: 'center',
    scroll: true,
    scrollLock: true,
    showOverlay: true,
    tap: true,
    touchUi: true,
    btnClass: 'mbsc-fr-btn',
    btnWidth: true,
    focusTrap: true,
    focusOnClose: !isIOS8 // Temporary for iOS8

  };
  classes.Frame = Frame;
  themes.frame.mobiscroll = {
    headerText: false,
    btnWidth: false
  };
  themes.scroller.mobiscroll = extend$1({}, themes.frame.mobiscroll, {
    rows: 5,
    showLabel: false,
    selectedLineBorder: 1,
    weekDays: 'min',
    checkIcon: 'ion-ios7-checkmark-empty',
    btnPlusClass: 'mbsc-ic mbsc-ic-arrow-down5',
    btnMinusClass: 'mbsc-ic mbsc-ic-arrow-up5',
    btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left5',
    btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right5'
  });

  if (isBrowser) {
    // Prevent re-show on window focus
    $$1(window).on('focus', function () {
      if ($activeElm) {
        preventShow = true;
      }
    });
  }

  // eslint-disable-next-line no-unused-vars
  var isIOS$1 = os == 'ios';
  var ScrollViewBase = function ScrollViewBase(el, settings, inherit) {
    var $btn,
        $scrollbar,
        $scrollbarTrack,
        btnTimer,
        contSize,
        diffX,
        diffY,
        diff,
        dir,
        easing,
        elastic,
        endX,
        endY,
        eventObj,
        isBtn,
        isInfinite,
        maxScroll,
        maxSnapScroll,
        minScroll,
        move,
        moving,
        nativeScroll,
        rafID,
        //rafMoveID,
    rafRunning,
        scrollbar,
        scrollbarHeight,
        scrollbarOffset,
        scrollbarTrack,
        scrolled,
        scrollDebounce,
        scrollSnap,
        scrollTimer,
        snap,
        snapPoints,
        startPos,
        startTime,
        startX,
        startY,
        style,
        target,
        transTimer,
        threshold,
        trigger,
        vertical,
        that = this,
        currPos,
        currSnap = 0,
        currSnapDir = 1,
        s = settings,
        $elm = $$1(el);

    function onStart(ev) {
      trigger('onStart', {
        domEvent: ev
      }); // Better performance if there are tap events on document

      if (s.stopProp) {
        ev.stopPropagation();
      } //if (s.prevDef || ev.type == 'mousedown') {


      if (s.prevDef && ev.type == 'mousedown') {
        // Prevent touch highlight and focus
        ev.preventDefault();
      }

      if (s.readonly || s.lock && moving) {
        return;
      }

      if (testTouch(ev, this) && !move && mobiscroll.owfBP) {
        if ($btn) {
          $btn.removeClass('mbsc-active');
        } // Highlight button


        isBtn = false;

        if (!moving) {
          $btn = $$1(ev.target).closest('.mbsc-btn-e', this);

          if ($btn.length && !$btn.hasClass('mbsc-disabled')) {
            isBtn = true;
            btnTimer = setTimeout(function () {
              $btn.addClass('mbsc-active');
            }, 100);
          }
        }

        move = true;
        scrolled = false;
        nativeScroll = false;
        that.scrolled = moving;
        startX = getCoord(ev, 'X');
        startY = getCoord(ev, 'Y');
        endX = startX;
        diffX = 0;
        diffY = 0;
        diff = 0;
        startTime = new Date();
        startPos = +getPosition(target, vertical) || 0; // Stop scrolling animation, 1ms is needed for Android 4.0

        if (moving) {
          scroll(startPos, isIOS$1 ? 0 : 1);
        }

        if (ev.type === 'mousedown') {
          $$1(document).on('mousemove', onMove).on('mouseup', onEnd);
        }
      }
    }

    function onMove(ev) {
      if (move) {
        if (s.stopProp) {
          ev.stopPropagation();
        }

        endX = getCoord(ev, 'X');
        endY = getCoord(ev, 'Y');
        diffX = endX - startX;
        diffY = endY - startY;
        diff = vertical ? diffY : diffX;

        if (isBtn && (Math.abs(diffY) > s.thresholdY || Math.abs(diffX) > s.thresholdX)) {
          clearTimeout(btnTimer);
          $btn.removeClass('mbsc-active');
          isBtn = false;
        }

        if (that.scrolled || !nativeScroll && Math.abs(diff) > threshold) {
          if (!scrolled) {
            trigger('onGestureStart', eventObj);
          }

          that.scrolled = scrolled = true;

          if (!rafRunning) {
            rafRunning = true;
            rafID = raf(onMoving);
          }
        }

        if (vertical || s.scrollLock) {
          // Always prevent native scroll, if vertical
          ev.preventDefault();
        } else {
          if (that.scrolled) {
            // Prevent native scroll
            ev.preventDefault();
          } else if (Math.abs(diffY) > 7) {
            nativeScroll = true;
            that.scrolled = true;
            onEnd();
          }
        }
      }
    }

    function onMoving() {
      //var time = new Date();
      if (maxSnapScroll) {
        diff = constrain(diff, -snap * maxSnapScroll, snap * maxSnapScroll);
      }

      scroll(constrain(startPos + diff, minScroll - elastic, maxScroll + elastic)); //if (s.momentum) {
      //    startTime = time;
      //    lastX = endX;
      //}

      rafRunning = false;
    }

    function onEnd(ev) {
      if (move) {
        var speed,
            time = new Date() - startTime; // Better performance if there are tap events on document

        if (s.stopProp && ev) {
          ev.stopPropagation();
        }

        rafc(rafID);
        rafRunning = false;

        if (!nativeScroll && that.scrolled) {
          // Calculate momentum distance
          if (s.momentum && time < 300) {
            speed = diff / time; //speed = Math.abs(lastX - endX) / time;

            diff = Math.max(Math.abs(diff), speed * speed / s.speedUnit) * (diff < 0 ? -1 : 1);
          }

          finalize(diff);
        }

        if (isBtn) {
          clearTimeout(btnTimer);
          $btn.addClass('mbsc-active');
          setTimeout(function () {
            $btn.removeClass('mbsc-active');
          }, 100);

          if (!nativeScroll && !that.scrolled) {
            trigger('onBtnTap', {
              target: $btn[0],
              domEvent: ev
            });
          }
        } // Detach document events


        if (ev && ev.type == 'mouseup') {
          $$1(document).off('mousemove', onMove).off('mouseup', onEnd);
        }

        move = false;
      }
    }

    function onClick(ev) {
      if (that.scrolled) {
        that.scrolled = false;
        ev.stopPropagation();
        ev.preventDefault();
      }
    }

    function onScroll(ev) {
      if (!el.contains(ev.target)) {
        return;
      }

      ev = ev.originalEvent || ev;
      diff = vertical ? ev.deltaY == undefined ? ev.wheelDelta || ev.detail : ev.deltaY : ev.deltaX;
      trigger('onStart', {
        domEvent: ev
      });

      if (s.stopProp) {
        ev.stopPropagation();
      }

      if (diff && mobiscroll.owfBP) {
        ev.preventDefault(); //diff = diff < 0 ? 20 : -20;

        if (ev.deltaMode && ev.deltaMode == 1) {
          diff *= 15;
        }

        diff = constrain(-diff, -scrollSnap, scrollSnap);
        startPos = currPos;

        if (s.readonly) {
          return;
        }

        if (!scrolled) {
          gestureStart();
        }

        if (startPos + diff < minScroll) {
          startPos = minScroll;
          diff = 0;
        }

        if (startPos + diff > maxScroll) {
          startPos = maxScroll;
          diff = 0;
        }

        if (!rafRunning) {
          rafRunning = true;
          rafID = raf(onMoving);
        }

        if (!diff && scrolled) {
          return;
        }

        scrolled = true;
        clearTimeout(scrollDebounce);
        scrollDebounce = setTimeout(function () {
          rafc(rafID);
          rafRunning = false;
          scrolled = false;
          finalize(diff);
        }, 200);
      }
    }

    function onScrollBarStart(ev) {
      trigger('onStart', {
        domEvent: ev
      });

      if (s.readonly) {
        return;
      }

      ev.stopPropagation();
      startPos = currPos;
      scrolled = false;

      if (ev.target == scrollbar) {
        startY = getCoord(ev, 'Y', true);
        $$1(document).on('mousemove', onScrollBarMove).on('mouseup', onScrollBarEnd);
      } else {
        startY = $scrollbar.offset().top;
        onScrollBarMove(ev);
        onScrollBarEnd();
      }
    }

    function onScrollBarMove(ev) {
      var percent = (getCoord(ev, 'Y', true) - startY) / contSize;

      if (isInfinite) {
        diff = -(maxSnapScroll * snap * 2 + contSize) * percent;
        diff = constrain(diff, -snap * maxSnapScroll, snap * maxSnapScroll);
      } else {
        diff = (minScroll - maxScroll - contSize) * percent;
      }

      if (!scrolled) {
        gestureStart();
      }

      scrolled = true;
      scroll(constrain(startPos + diff, minScroll - elastic, maxScroll + elastic));
    }

    function onScrollBarEnd() {
      startPos = currPos;
      finalize(0);
      $$1(document).off('mousemove', onScrollBarMove).off('mouseup', onScrollBarEnd);
    }

    function onScrollBarClick(ev) {
      ev.stopPropagation();
    }

    function gestureStart() {
      eventObj = {
        posX: vertical ? 0 : currPos,
        posY: vertical ? currPos : 0,
        originX: vertical ? 0 : startPos,
        originY: vertical ? startPos : 0,
        direction: diff > 0 ? vertical ? 270 : 360 : vertical ? 90 : 180
      };
      trigger('onGestureStart', eventObj);
    }

    function finalize(diff) {
      var i, time, newPos; // Limit scroll to snap size

      if (maxSnapScroll) {
        diff = constrain(diff, -snap * maxSnapScroll, snap * maxSnapScroll);
      } // Calculate snap and limit between min and max


      newPos = constrain(Math.round((startPos + diff) / snap) * snap, minScroll, maxScroll); // Snap to nearest element

      if (snapPoints) {
        if (diff < 0) {
          for (i = snapPoints.length - 1; i >= 0; i--) {
            if (Math.abs(newPos) + contSize >= snapPoints[i].breakpoint) {
              currSnap = i;
              currSnapDir = 2;
              newPos = snapPoints[i].snap2;
              break;
            }
          }
        } else if (diff >= 0) {
          for (i = 0; i < snapPoints.length; i++) {
            if (Math.abs(newPos) <= snapPoints[i].breakpoint) {
              currSnap = i;
              currSnapDir = 1;
              newPos = snapPoints[i].snap1;
              break;
            }
          }
        }

        newPos = constrain(newPos, minScroll, maxScroll);
      }

      time = s.time || (currPos < minScroll || currPos > maxScroll ? 1000 : Math.max(1000, Math.abs(newPos - currPos) * s.timeUnit));
      eventObj.destinationX = vertical ? 0 : newPos;
      eventObj.destinationY = vertical ? newPos : 0;
      eventObj.duration = time;
      eventObj.transitionTiming = easing;
      trigger('onGestureEnd', eventObj); // Scroll to the calculated position

      that.scroll(newPos, time);
    }

    function scroll(pos, time, tap, callback) {
      var percent,
          changed = pos != currPos,
          anim = time > 1,
          timing = time ? cssPrefix + 'transform ' + Math.round(time) + 'ms ' + easing : '',
          done = function done() {
        clearInterval(scrollTimer);
        clearTimeout(transTimer); //rafc(rafMoveID);

        moving = false;
        currPos = pos;
        eventObj.posX = vertical ? 0 : pos;
        eventObj.posY = vertical ? pos : 0;

        if (changed) {
          trigger('onMove', eventObj);
        }

        if (anim) {
          //that.scrolled = false;
          trigger('onAnimationEnd', eventObj);
        }

        if (callback) {
          callback();
        }
      };

      eventObj = {
        posX: vertical ? 0 : currPos,
        posY: vertical ? currPos : 0,
        originX: vertical ? 0 : startPos,
        originY: vertical ? startPos : 0,
        direction: pos - currPos > 0 ? vertical ? 270 : 360 : vertical ? 90 : 180
      };
      currPos = pos;

      if (anim) {
        eventObj.destinationX = vertical ? 0 : pos;
        eventObj.destinationY = vertical ? pos : 0;
        eventObj.duration = time;
        eventObj.transitionTiming = easing;
        trigger('onAnimationStart', eventObj);
      }

      style[jsPrefix + 'Transition'] = timing;
      style[jsPrefix + 'Transform'] = 'translate3d(' + (vertical ? '0,' + pos + 'px,' : pos + 'px,' + '0,') + '0)';

      if (scrollbar && scrollbarHeight) {
        percent = isInfinite ? (scrollbarOffset - pos) / (maxSnapScroll * snap * 2) : (pos - maxScroll) / (minScroll - maxScroll);
        scrollbar.style[jsPrefix + 'Transition'] = timing;
        scrollbar.style[jsPrefix + 'Transform'] = 'translate3d(0,' + Math.max(0, Math.min((contSize - scrollbarHeight) * percent, contSize - scrollbarHeight)) + 'px,0)';
      }

      if (!changed && !moving || !time || time <= 1) {
        done();
      } else if (time) {
        moving = !tap;
        clearInterval(scrollTimer);
        scrollTimer = setInterval(function () {
          //rafMoveID = raf(function () {
          var p = +getPosition(target, vertical) || 0;
          eventObj.posX = vertical ? 0 : p;
          eventObj.posY = vertical ? p : 0;
          trigger('onMove', eventObj); // Trigger done if close to the end

          if (Math.abs(p - pos) < 2) {
            done();
          } //});

        }, 100);
        clearTimeout(transTimer);
        transTimer = setTimeout(function () {
          done(); //style[pr + 'Transition'] = '';
        }, time); // target.off(transEnd).on(transEnd, function (e) {
        //     if (e.target === target[0]) {
        //         target.off(transEnd);
        //         style[pr + 'Transition'] = '';
        //         done();
        //     }
        // });
      }

      if (s.sync) {
        s.sync(pos, time, easing);
      }
    } // Call the parent constructor


    Base.call(this, el, settings, true);
    that.scrolled = false;
    /**
     * Scroll to the given position or element
     */

    that.scroll = function (pos, time, tap, callback) {
      // If position is not numeric, scroll to element
      if (!isNumeric(pos)) {
        pos = Math.ceil(($$1(pos, el).length ? Math.round(target.offset()[dir] - $$1(pos, el).offset()[dir]) : currPos) / snap) * snap;
      } else {
        pos = Math.round(pos / snap) * snap;
      }

      pos = constrain(pos, minScroll, maxScroll);
      currSnap = Math.round(pos / snap);
      startPos = currPos;
      scrollbarOffset = maxSnapScroll * snap + pos;
      scroll(pos, time, tap, callback);
    };

    that.refresh = function (noScroll) {
      var tempScroll;
      contSize = (s.contSize === undefined ? vertical ? $elm.height() : $elm.width() : s.contSize) || 0;
      maxScroll = (s.maxScroll === undefined ? 0 : s.maxScroll) || 0;
      minScroll = Math.min(maxScroll, s.minScroll === undefined ? Math.min(0, vertical ? contSize - target.height() : contSize - target.width()) : s.minScroll) || 0;
      snapPoints = null;

      if (!vertical && s.rtl) {
        tempScroll = maxScroll;
        maxScroll = -minScroll;
        minScroll = -tempScroll;
      }

      if (isString(s.snap)) {
        snapPoints = [];
        target.find(s.snap).each(function () {
          var offset = vertical ? this.offsetTop : this.offsetLeft,
              size = vertical ? this.offsetHeight : this.offsetWidth;
          snapPoints.push({
            breakpoint: offset + size / 2,
            snap1: -offset,
            snap2: contSize - offset - size
          });
        });
      }

      snap = isNumeric(s.snap) ? s.snap : 1;
      maxSnapScroll = s.snap ? s.maxSnapScroll : 0;
      easing = s.easing;
      elastic = s.elastic ? isNumeric(s.snap) ? snap : isNumeric(s.elastic) ? s.elastic : 0 : 0; // && s.snap ? snap : 0;

      scrollSnap = snap;

      while (scrollSnap > 44) {
        scrollSnap /= 2;
      }

      scrollSnap = Math.round(44 / scrollSnap) * scrollSnap;

      if (scrollbar) {
        isInfinite = minScroll == -Infinity || maxScroll == Infinity;
        scrollbarHeight = minScroll < maxScroll ? Math.max(20, contSize * contSize / (maxScroll - minScroll + contSize)) : 0;
        scrollbar.style.height = scrollbarHeight + 'px';
        scrollbarTrack.style.height = scrollbarHeight ? '' : 0;
      }

      if (currPos === undefined) {
        currPos = s.initialPos;
        currSnap = Math.round(currPos / snap);
      }

      if (!noScroll) {
        that.scroll(s.snap ? snapPoints && snapPoints[currSnap] ? snapPoints[currSnap]['snap' + currSnapDir] : currSnap * snap : currPos);
      }
    };

    that._processSettings = function () {
      vertical = s.axis == 'Y';
      dir = vertical ? 'top' : 'left';
      target = s.moveElement || $elm.children().eq(0);
      style = target[0].style;
      threshold = vertical ? s.thresholdY : s.thresholdX;

      if (s.scrollbar) {
        $scrollbarTrack = s.scrollbar;
        $scrollbar = $scrollbarTrack.find('.mbsc-sc-bar');
        scrollbar = $scrollbar[0];
        scrollbarTrack = $scrollbarTrack[0];
      }
    };

    that._init = function () {
      that.refresh();
      listen(el, 'mousedown', onStart);
      listen(el, 'touchstart', onStart, {
        passive: true
      });
      listen(el, 'touchend', onEnd);
      listen(el, 'touchcancel', onEnd);
      listen(el, 'click', onClick, true);
      listen(document, 'touchmove', onMove, {
        passive: false
      });

      if (s.mousewheel) {
        listen(document, 'wheel', onScroll, {
          passive: false,
          capture: true
        });
        listen(document, 'mousewheel', onScroll, {
          passive: false,
          capture: true
        });
      }

      if (scrollbar) {
        $scrollbarTrack.on('mousedown', onScrollBarStart).on('click', onScrollBarClick);
      } //el.addEventListener('touchend', function (ev) {
      //    if (scrolled) {
      //        ev.stopPropagation();
      //    }
      //}, true);

    };
    /**
     * Destroy
     */


    that._destroy = function () {
      clearInterval(scrollTimer);
      unlisten(el, 'mousedown', onStart);
      unlisten(el, 'touchstart', onStart, {
        passive: true
      });
      unlisten(el, 'touchend', onEnd);
      unlisten(el, 'touchcancel', onEnd);
      unlisten(el, 'click', onClick, true);
      unlisten(document, 'touchmove', onMove, {
        passive: false
      });
      unlisten(document, 'wheel', onScroll, {
        passive: false,
        capture: true
      });
      unlisten(document, 'mousewheel', onScroll, {
        passive: false,
        capture: true
      });

      if (scrollbar) {
        $scrollbarTrack.off('mousedown', onScrollBarStart).off('click', onScrollBarClick);
      }
    }; // Constructor


    s = that.settings;
    trigger = that.trigger;

    if (!inherit) {
      that.init();
    }
  };
  ScrollViewBase.prototype = {
    _defaults: {
      speedUnit: 0.0022,
      //timeUnit: 0.8,
      timeUnit: 3,
      initialPos: 0,
      axis: 'Y',
      thresholdX: 10,
      thresholdY: 5,
      //easing: 'ease-out',
      easing: 'cubic-bezier(0.190, 1.000, 0.220, 1.000)',
      stopProp: true,
      momentum: true,
      mousewheel: true,
      elastic: true
    }
  };

  // eslint-disable-next-line no-unused-vars
  var presets = {},
      css = isBrowser ? window.CSS : null,
      has3d = css && css.supports && css.supports("(transform-style: preserve-3d)");

  function sanitize(str) {
    return (str + '').replace(/"/g, '___');
  }
  var Scroller = function Scroller(el, settings, inherit) {
    var $markup,
        batchSize3d,
        batchSize = 40,
        animTime = 1000,
        scroll3dAngle,
        scroll3d,
        selectedClass,
        showScrollArrows,
        stepper,
        tempWheelArray,
        itemHeight,
        itemHeight3d,
        isPointer,
        isValidating,
        s,
        trigger,
        lines,
        wheels,
        wheelsMap,
        that = this,
        $elm = $$1(el); // Event handlers

    function onKeyDown(ev) {
      var i = +$$1(this).attr('data-index'),
          handle,
          direction;

      if (ev.keyCode == 38) {
        // Up
        handle = true;
        direction = -1;
      } else if (ev.keyCode == 40) {
        // Down
        handle = true;
        direction = 1;
      } else if (ev.keyCode == 32) {
        // Space
        handle = true;
        onItemTap(i, $$1(ev.target));
      }

      if (handle) {
        ev.stopPropagation();
        ev.preventDefault();

        if (direction) {
          stepper.start(i, direction, ev);
        }
      }
    }

    function onKeyUp() {
      stepper.stop();
    }

    function onItemTap(i, $item) {
      var wheel = wheels[i],
          idx = +$item.attr('data-index'),
          val = getValue(wheel, idx),
          selected = that._tempSelected[i],
          maxSelect = isNumeric(wheel.multiple) ? wheel.multiple : Infinity;

      if (trigger('onItemTap', {
        target: $item[0],
        index: i,
        value: val,
        selected: $item.hasClass('mbsc-sc-itm-sel')
      }) !== false && !that._prevItemTap) {
        // Select item on tap
        if (wheel.multiple && !wheel._disabled[val]) {
          if (selected[val] !== undefined) {
            $item.removeClass(selectedClass).removeAttr('aria-selected');
            delete selected[val];
          } else {
            if (maxSelect == 1) {
              that._tempSelected[i] = selected = {};

              wheel._$markup.find('.mbsc-sc-itm-sel').removeClass(selectedClass).removeAttr('aria-selected');
            }

            if (objectToArray(selected).length < maxSelect) {
              $item.addClass(selectedClass).attr('aria-selected', 'true');
              selected[val] = val;
            }
          }
        }

        setWheelValue(wheel, i, idx, animTime, wheel._index < idx ? 1 : 2, true, wheel.multiple);

        if (that.live && (!wheel.multiple || wheel.multiple === 1 && s.tapSelect) && (s.setOnTap === true || s.setOnTap[i])) {
          setTimeout(function () {
            that.select();
          }, s.tapSelect ? 0 : 200);
        }
      }

      that._prevItemTap = false;
    } // Private functions


    function shouldSet(i, noscroll) {
      var wheel = wheels[i];
      return wheel && (!wheel.multiple || wheel.multiple !== 1 && noscroll && (s.setOnTap === true || s.setOnTap[i]));
    }

    function getMin(wheel) {
      return -(wheel.max - wheel._offset - (wheel.multiple && !scroll3d ? Math.floor(s.rows / 2) : 0)) * itemHeight;
    }

    function getMax(wheel) {
      return -(wheel.min - wheel._offset + (wheel.multiple && !scroll3d ? Math.floor(s.rows / 2) : 0)) * itemHeight;
    }

    function getIndex(wheel, val) {
      return (wheel._array ? wheel._map[val] : +wheel.getIndex(val, that)) || 0;
    }

    function getItem(wheel, i) {
      var data = wheel.data;

      if (i >= wheel.min && i <= wheel.max) {
        return wheel._array ? wheel.circular ? $$1(data).get(i % wheel._length) : data[i] : $$1.isFunction(data) ? data(i, that) : '';
      }
    }

    function getItemValue(item) {
      return $$1.isPlainObject(item) ? item.value !== undefined ? item.value : item.display : item;
    }

    function getItemText(item) {
      var text = $$1.isPlainObject(item) ? item.display : item;
      return text === undefined ? '' : text + that._getText(mobiscroll, 0.2);
    }

    function getValue(wheel, i) {
      return getItemValue(getItem(wheel, i));
    }

    function step(index, direction, ev) {
      var wheel = wheels[index];
      setWheelValue(wheel, index, wheel._index + direction, s.delay + 100, direction == 1 ? 1 : 2, false, false, ev.type == 'keydown');
    }

    function isReadOnly(i) {
      return $$1.isArray(s.readonly) ? s.readonly[i] : s.readonly;
    }

    function initWheel(ww, l, keep) {
      // Create a copy of the wheel, in case if same option object is used for multiple scroller instances
      var w = extend$1(wheels[l] || {}, ww);
      var index = w._index - w._batch;
      w.data = w.data || [];
      w.key = w.key !== undefined ? w.key : l;
      w.label = w.label !== undefined ? w.label : l;
      w._map = {};
      w._array = $$1.isArray(w.data); // Map keys to index

      if (w._array) {
        w._length = w.data.length;
        $$1.each(w.data, function (i, v) {
          w._map[getItemValue(v)] = i;
        });
      }

      w.circular = s.circular === undefined ? w.circular === undefined ? w._array && w._length > s.rows : w.circular : $$1.isArray(s.circular) ? s.circular[l] : s.circular;
      w.min = w._array ? w.circular ? -Infinity : 0 : w.min === undefined ? -Infinity : w.min;
      w.max = w._array ? w.circular ? Infinity : w._length - 1 : w.max === undefined ? Infinity : w.max;
      w._nr = l;
      w._index = getIndex(w, tempWheelArray[l]);
      w._disabled = {};
      w._batch = 0;
      w._current = w._index;
      w._first = w._index - batchSize; //Math.max(w.min, w._current - batchSize);

      w._last = w._index + batchSize; //Math.min(w.max, w._first + 2 * batchSize);

      w._offset = w._first;

      if (keep) {
        w._offset -= w._margin / itemHeight + (w._index - index);
        w._margin += (w._index - index) * itemHeight;
      } else {
        w._margin = 0; //w._first * itemHeight;
      }

      w._refresh = function (noScroll) {
        extend$1(w._scroller.settings, {
          minScroll: getMin(w),
          maxScroll: getMax(w)
        });

        w._scroller.refresh(noScroll);
      };

      wheelsMap[w.key] = w;
      return w;
    }

    function generateItems(wheel, index, start, end, is3d) {
      var i,
          css,
          item,
          value,
          text,
          lbl,
          invalid,
          selected,
          html = '',
          checked = that._tempSelected[index],
          disabled = wheel._disabled || {};

      for (i = start; i <= end; i++) {
        item = getItem(wheel, i);
        text = getItemText(item);
        value = getItemValue(item);
        css = item && item.cssClass !== undefined ? item.cssClass : '';
        lbl = item && item.label !== undefined ? item.label : '';
        invalid = item && item.invalid;
        selected = value !== undefined && value == tempWheelArray[index] && !wheel.multiple; // TODO: don't generate items with no value (use margin or placeholder instead)

        html += '<div role="option" tabindex="-1" aria-selected="' + (checked[value] ? true : false) + '" class="mbsc-sc-itm ' + (is3d ? 'mbsc-sc-itm-3d ' : '') + css + ' ' + (selected ? 'mbsc-sc-itm-sel ' : '') + (checked[value] ? selectedClass : '') + (value === undefined ? ' mbsc-sc-itm-ph' : ' mbsc-btn-e') + (invalid ? ' mbsc-sc-itm-inv-h mbsc-disabled' : '') + (disabled[value] ? ' mbsc-sc-itm-inv mbsc-disabled' : '') + '" data-index="' + i + '" data-val="' + sanitize(value) + '"' + (lbl ? ' aria-label="' + lbl + '"' : '') + (selected ? ' aria-selected="true"' : '') + ' style="height:' + itemHeight + 'px;line-height:' + itemHeight + 'px;' + (is3d ? cssPrefix + 'transform:rotateX(' + (wheel._offset - i) * scroll3dAngle % 360 + 'deg) translateZ(' + itemHeight * s.rows / 2 + 'px);' : '') + '">' + (lines > 1 ? '<div class="mbsc-sc-itm-ml" style="line-height:' + Math.round(itemHeight / lines) + 'px;font-size:' + Math.round(itemHeight / lines * 0.8) + 'px;">' : '') + text + (lines > 1 ? '</div>' : '') + '</div>';
      }

      return html;
    }

    function infinite(wheel, i, pos) {
      var index = Math.round(-pos / itemHeight) + wheel._offset,
          diff = index - wheel._current,
          first = wheel._first,
          last = wheel._last,
          first3d = first + batchSize - batchSize3d + 1,
          last3d = last - batchSize + batchSize3d;

      if (diff) {
        wheel._first += diff;
        wheel._last += diff;
        wheel._current = index; // Generate items
        //setTimeout(function () {

        if (diff > 0) {
          wheel._$scroller.append(generateItems(wheel, i, Math.max(last + 1, first + diff), last + diff));

          $$1('.mbsc-sc-itm', wheel._$scroller).slice(0, Math.min(diff, last - first + 1)).remove(); // 3D

          if (scroll3d) {
            wheel._$3d.append(generateItems(wheel, i, Math.max(last3d + 1, first3d + diff), last3d + diff, true));

            $$1('.mbsc-sc-itm', wheel._$3d).slice(0, Math.min(diff, last3d - first3d + 1)).attr('class', 'mbsc-sc-itm-del');
          }
        } else if (diff < 0) {
          wheel._$scroller.prepend(generateItems(wheel, i, first + diff, Math.min(first - 1, last + diff)));

          $$1('.mbsc-sc-itm', wheel._$scroller).slice(Math.max(diff, first - last - 1)).remove(); // 3D

          if (scroll3d) {
            wheel._$3d.prepend(generateItems(wheel, i, first3d + diff, Math.min(first3d - 1, last3d + diff), true));

            $$1('.mbsc-sc-itm', wheel._$3d).slice(Math.max(diff, first3d - last3d - 1)).attr('class', 'mbsc-sc-itm-del');
          }
        }

        wheel._margin += diff * itemHeight;

        wheel._$scroller.css('margin-top', wheel._margin + 'px'); //}, 10);

      }
    }

    function getValid(index, v, dir, dis) {
      var counter,
          wheel = wheels[index],
          disabled = dis || wheel._disabled,
          idx = getIndex(wheel, v),
          val = getValue(wheel, idx),
          v1 = val,
          v2 = val,
          dist1 = 0,
          dist2 = 0; // TODO: what if all items are invalid

      if (disabled[val] === true) {
        counter = 0;

        while (idx - dist1 >= wheel.min && disabled[v1] && counter < 100) {
          counter++;
          dist1++;
          v1 = getValue(wheel, idx - dist1);
        }

        counter = 0;

        while (idx + dist2 < wheel.max && disabled[v2] && counter < 100) {
          counter++;
          dist2++;
          v2 = getValue(wheel, idx + dist2);
        } // If we have direction (+/- or mouse wheel), the distance does not count


        if ((dist2 < dist1 && dist2 && dir !== 2 || !dist1 || idx - dist1 < 0 || dir == 1) && !disabled[v2]) {
          val = v2;
        } else {
          val = v1;
        }
      }

      return val;
    }

    function scrollToPos(time, index, dir, manual, tap, noscroll, shouldFocus) {
      var diff,
          idx,
          offset,
          ret,
          isVisible = that._isVisible;
      isValidating = true;
      ret = s.validate.call(el, {
        values: tempWheelArray.slice(0),
        index: index,
        direction: dir
      }, that) || {};
      isValidating = false;

      if (ret.valid) {
        that._tempWheelArray = tempWheelArray = ret.valid.slice(0);
      }

      if (!noscroll) {
        $$1.each(wheels, function (i, wheel) {
          if (isVisible) {
            // Enable all items
            wheel._$markup.find('.mbsc-sc-itm-inv').removeClass('mbsc-sc-itm-inv mbsc-disabled');
          }

          wheel._disabled = {}; // Disable invalid items

          if (ret.disabled && ret.disabled[i]) {
            $$1.each(ret.disabled[i], function (j, v) {
              wheel._disabled[v] = true;

              if (isVisible) {
                wheel._$markup.find('.mbsc-sc-itm[data-val="' + sanitize(v) + '"]').addClass('mbsc-sc-itm-inv mbsc-disabled');
              }
            });
          } // Get closest valid value


          tempWheelArray[i] = wheel.multiple ? tempWheelArray[i] : getValid(i, tempWheelArray[i], dir);

          if (isVisible) {
            if (!wheel.multiple || index === undefined) {
              wheel._$markup.find('.mbsc-sc-itm-sel').removeClass(selectedClass).removeAttr('aria-selected');
            } // Get index of valid value


            idx = getIndex(wheel, tempWheelArray[i]);
            diff = idx - wheel._index + wheel._batch;

            if (Math.abs(diff) > 2 * batchSize + 1) {
              offset = diff + (2 * batchSize + 1) * (diff > 0 ? -1 : 1);
              wheel._offset += offset;
              wheel._margin -= offset * itemHeight;

              wheel._refresh();
            }

            wheel._index = idx + wheel._batch;

            if (wheel.multiple) {
              // Add selected styling to selected elements in case of multiselect
              if (index === undefined) {
                for (var v in that._tempSelected[i]) {
                  wheel._$markup.find('.mbsc-sc-itm[data-val="' + sanitize(v) + '"]').addClass(selectedClass).attr('aria-selected', 'true');
                }
              }
            } else {
              // Mark element as aria selected
              wheel._$markup.find('.mbsc-sc-itm[data-val="' + sanitize(tempWheelArray[i]) + '"]').addClass('mbsc-sc-itm-sel').attr('aria-selected', 'true');
            }

            if (wheel._$active) {
              wheel._$active.attr('tabindex', -1);
            }

            wheel._$active = wheel._$markup.find('.mbsc-sc-itm[data-index="' + wheel._index + '"]').eq(scroll3d && wheel.multiple ? 1 : 0).attr('tabindex', 0);

            if (shouldFocus && index === i && wheel._$active.length) {
              wheel._$active[0].focus();

              wheel._$scroller.parent().scrollTop(0);
            } // Scroll to valid value


            wheel._scroller.scroll(-(idx - wheel._offset + wheel._batch) * itemHeight, index === i || index === undefined ? time : animTime, tap);
          }
        });
      }

      trigger('onValidated', {
        index: index,
        time: time
      }); // Get formatted value

      that._tempValue = s.formatValue.call(el, tempWheelArray, that);

      if (isVisible) {
        that._updateHeader();
      } // If in live mode, set and fill value on every move


      if (that.live && shouldSet(index, noscroll)) {
        that._hasValue = manual || that._hasValue;
        setValue(manual, manual, 0, true);

        if (manual) {
          trigger('onSet', {
            valueText: that._value
          });
        }
      }

      if (manual) {
        trigger('onChange', {
          index: index,
          valueText: that._tempValue
        });
      }
    }

    function setWheelValue(wheel, i, idx, time, dir, tap, noscroll, shouldFocus) {
      // Get the value at the given index
      var value = getValue(wheel, idx);

      if (value !== undefined) {
        tempWheelArray[i] = value; // In case of circular wheels calculate the offset of the current batch

        wheel._batch = wheel._array ? Math.floor(idx / wheel._length) * wheel._length : 0;
        wheel._index = idx;
        setTimeout(function () {
          scrollToPos(time, i, dir, true, tap, noscroll, shouldFocus);
        }, 10);
      }
    }

    function setValue(fill, change, time, noscroll, temp) {
      if (!noscroll) {
        scrollToPos(time);
      } else {
        that._tempValue = s.formatValue.call(el, that._tempWheelArray, that);
      }

      if (!temp) {
        that._wheelArray = [];

        for (var i = 0; i < tempWheelArray.length; i++) {
          // In case of multiple select wheel take the first selected value,
          that._wheelArray[i] = wheels[i] && wheels[i].multiple ? Object.keys(that._tempSelected[i] || {})[0] : tempWheelArray[i];
        }

        that._value = that._hasValue ? that._tempValue : null;
        that._selected = extend$1(true, {}, that._tempSelected);
      }

      if (fill) {
        if (that._isInput) {
          $elm.val(that._hasValue ? that._tempValue : '');
        }

        trigger('onFill', {
          valueText: that._hasValue ? that._tempValue : '',
          change: change
        });

        if (change) {
          that._preventChange = true;
          $elm.trigger('change');
        }
      }
    } // Call the parent constructor


    Frame.call(this, el, settings, true); // Public functions

    /**
     * Sets the value of the scroller.
     * @param {Array} val - New value.
     * @param {Boolean} [fill=false] - Set the value of the associated input element.
     * @param {Boolean} [change=false] - Trigger change on the input element.
     * @param {Boolean} [temp=false] - If true, then only set the temporary value (only scroll there but not set the value).
     * @param {Number} [time=0] - Animation time in milliseconds.
     */

    that.setVal = that._setVal = function (val, fill, change, temp, time) {
      that._hasValue = val !== null && val !== undefined;
      that._tempWheelArray = tempWheelArray = $$1.isArray(val) ? val.slice(0) : s.parseValue.call(el, val, that) || [];
      setValue(fill, change === undefined ? fill : change, time, false, temp);
    };
    /**
     * Returns the selected value.
     */


    that.getVal = that._getVal = function (temp) {
      var val = that._hasValue || temp ? that[temp ? '_tempValue' : '_value'] : null;
      return isNumeric(val) ? +val : val;
    };
    /*
     * Sets the wheel values (passed as an array).
     */


    that.setArrayVal = that.setVal;
    /*
     * Returns the selected wheel values as an array.
     */

    that.getArrayVal = function (temp) {
      return temp ? that._tempWheelArray : that._wheelArray;
    };

    that.changeWheel = function (whls, time, manual) {
      var i, w, ww;
      $$1.each(whls, function (key, wheel) {
        ww = wheelsMap[key]; // Check if wheel exists

        if (ww) {
          i = ww._nr;
          w = initWheel(wheel, i, true);

          if (that._isVisible) {
            if (scroll3d) {
              w._$3d.html(generateItems(w, i, w._first + batchSize - batchSize3d + 1, w._last - batchSize + batchSize3d, true));
            }

            w._$scroller.html(generateItems(w, i, w._first, w._last)).css('margin-top', w._margin + 'px');

            w._refresh(isValidating);
          }
        }
      });

      if (that._isVisible && !that._isLiquid && !isValidating) {
        that.position();
      }

      if (!isValidating) {
        scrollToPos(time, undefined, undefined, manual);
      }
    };
    /**
     * Returns the closest valid value.
     */


    that.getValidValue = getValid; // Protected overrides 

    that._generateContent = function () {
      var lbl,
          maxPopupWidth = 0,
          html = '',
          style = scroll3d ? cssPrefix + 'transform: translateZ(' + (itemHeight * s.rows / 2 + 3) + 'px);' : '',
          highlight = '<div class="mbsc-sc-whl-l" style="' + style + 'height:' + itemHeight + 'px;margin-top:-' + (itemHeight / 2 + (s.selectedLineBorder || 0)) + 'px;"></div>',
          l = 0;
      $$1.each(s.wheels, function (i, wg) {
        html += '<div class="mbsc-w-p mbsc-sc-whl-gr-c' + (scroll3d ? ' mbsc-sc-whl-gr-3d-c' : '') + (s.showLabel ? ' mbsc-sc-lbl-v' : '') + '">' + highlight + '<div class="mbsc-sc-whl-gr' + (scroll3d ? ' mbsc-sc-whl-gr-3d' : '') + (showScrollArrows ? ' mbsc-sc-cp' : '') + (s.width || s.maxWidth ? '"' : '" style="max-width:' + s.maxPopupWidth + 'px;"') + '>';
        $$1.each(wg, function (j, ww) {
          // Wheels
          that._tempSelected[l] = extend$1({}, that._selected[l]); // TODO: this should be done on initialization, not on show

          var w = initWheel(ww, l);
          var topMargin = !isPointer || s.rows % 2 ? itemHeight3d / 2 : 0;
          wheels[l] = w;
          maxPopupWidth += s.maxWidth ? s.maxWidth[l] || s.maxWidth : s.width ? s.width[l] || s.width : 0;
          lbl = w.label !== undefined ? w.label : j;
          html += '<div class="mbsc-sc-whl-w ' + (w.cssClass || '') + (w.multiple ? ' mbsc-sc-whl-multi' : '') + '" style="' + (s.width ? 'width:' + (s.width[l] || s.width) + 'px;' : (s.minWidth ? 'min-width:' + (s.minWidth[l] || s.minWidth) + 'px;' : '') + (s.maxWidth ? 'max-width:' + (s.maxWidth[l] || s.maxWidth) + 'px;' : '')) + '">' + (isPointer ? '<div class="mbsc-sc-bar-c"><div class="mbsc-sc-bar"></div></div>' : '') + // Scrollbar
          '<div class="mbsc-sc-whl-o" style="' + style + '"></div>' + highlight + '<div aria-live="off" aria-label="' + lbl + '"' + (w.multiple ? ' aria-multiselectable="true"' : '') + ' role="listbox" data-index="' + l + '" class="mbsc-sc-whl"' + ' style="' + 'height:' + s.rows * itemHeight * (scroll3d ? 1.1 : 1) + 'px;">' + (showScrollArrows ? '<div data-index="' + l + '" data-step="1" class="mbsc-sc-btn mbsc-sc-btn-plus ' + (s.btnPlusClass || '') + '"></div>' + // + button
          '<div data-index="' + l + '" data-step="-1" class="mbsc-sc-btn mbsc-sc-btn-minus ' + (s.btnMinusClass || '') + '"></div>' : '') + // - button
          '<div class="mbsc-sc-lbl">' + lbl + '</div>' + // Wheel label
          '<div class="mbsc-sc-whl-c"' + ' style="height:' + itemHeight3d + 'px;margin-top:-' + (topMargin + 1) + 'px;' + style + '">' + '<div class="mbsc-sc-whl-sc" style="top:' + (itemHeight3d - itemHeight) / 2 + 'px;">'; // Create wheel values

          html += generateItems(w, l, w._first, w._last) + '</div></div>';

          if (scroll3d) {
            html += '<div class="mbsc-sc-whl-3d" style="height:' + itemHeight + 'px;margin-top:-' + itemHeight / 2 + 'px;">';
            html += generateItems(w, l, w._first + batchSize - batchSize3d + 1, w._last - batchSize + batchSize3d, true);
            html += '</div>';
          }

          html += '</div></div>';
          l++;
        });
        html += '</div></div>';
      });

      if (maxPopupWidth) {
        s.maxPopupWidth = maxPopupWidth;
      }

      return html;
    };

    that._attachEvents = function ($markup) {
      stepper = createStepper($$1('.mbsc-sc-btn', $markup), step, s.delay, isReadOnly, true);
      $$1('.mbsc-sc-whl', $markup).on('keydown', onKeyDown).on('keyup', onKeyUp);
    };

    that._detachEvents = function () {
      if (stepper) {
        stepper.stop();
      }

      for (var i = 0; i < wheels.length; i++) {
        wheels[i]._scroller.destroy();
      }
    };

    that._markupReady = function ($m) {
      $markup = $m;
      $$1('.mbsc-sc-whl-w', $markup).each(function (i) {
        var idx,
            $wh = $$1(this),
            wheel = wheels[i];
        wheel._$markup = $wh;
        wheel._$scroller = $$1('.mbsc-sc-whl-sc', this);
        wheel._$3d = $$1('.mbsc-sc-whl-3d', this);
        wheel._scroller = new ScrollViewBase(this, {
          mousewheel: s.mousewheel,
          moveElement: wheel._$scroller,
          scrollbar: $$1('.mbsc-sc-bar-c', this),
          initialPos: (wheel._first - wheel._index) * itemHeight,
          contSize: s.rows * itemHeight,
          snap: itemHeight,
          minScroll: getMin(wheel),
          maxScroll: getMax(wheel),
          maxSnapScroll: batchSize,
          prevDef: true,
          stopProp: true,
          timeUnit: 3,
          easing: 'cubic-bezier(0.190, 1.000, 0.220, 1.000)',
          sync: function sync(pos, time, easing) {
            var timing = time ? cssPrefix + 'transform ' + Math.round(time) + 'ms ' + easing : '';

            if (scroll3d) {
              wheel._$3d[0].style[jsPrefix + 'Transition'] = timing;
              wheel._$3d[0].style[jsPrefix + 'Transform'] = 'rotateX(' + -pos / itemHeight * scroll3dAngle + 'deg)';
            }
          },
          onStart: function onStart(ev, inst) {
            inst.settings.readonly = isReadOnly(i);
          },
          onGestureStart: function onGestureStart() {
            $wh.addClass('mbsc-sc-whl-a mbsc-sc-whl-anim');
            trigger('onWheelGestureStart', {
              index: i
            });
          },
          onGestureEnd: function onGestureEnd(ev) {
            var dir = ev.direction == 90 ? 1 : 2,
                time = ev.duration,
                pos = ev.destinationY;
            idx = Math.round(-pos / itemHeight) + wheel._offset;
            setWheelValue(wheel, i, idx, time, dir);
          },
          onAnimationStart: function onAnimationStart() {
            $wh.addClass('mbsc-sc-whl-anim');
          },
          onAnimationEnd: function onAnimationEnd() {
            $wh.removeClass('mbsc-sc-whl-a mbsc-sc-whl-anim');
            trigger('onWheelAnimationEnd', {
              index: i
            });

            wheel._$3d.find('.mbsc-sc-itm-del').remove();
          },
          onMove: function onMove(ev) {
            infinite(wheel, i, ev.posY);
          },
          onBtnTap: function onBtnTap(ev) {
            onItemTap(i, $$1(ev.target));
          }
        });
      });
      scrollToPos();
    };

    that._fillValue = function () {
      that._hasValue = true;
      setValue(true, true, 0, true);
    };

    that._clearValue = function () {
      $$1('.mbsc-sc-whl-multi .mbsc-sc-itm-sel', $markup).removeClass(selectedClass).removeAttr('aria-selected');
    };

    that._readValue = function () {
      var v = $elm.val() || '',
          l = 0;

      if (v !== '') {
        that._hasValue = true;
      }

      that._tempWheelArray = tempWheelArray = that._hasValue && that._wheelArray ? that._wheelArray.slice(0) : s.parseValue.call(el, v, that) || [];
      that._tempSelected = extend$1(true, {}, that._selected);
      $$1.each(s.wheels, function (i, wg) {
        $$1.each(wg, function (j, w) {
          // Wheels
          wheels[l] = initWheel(w, l);
          l++;
        });
      });
      setValue(false, false, 0, true);
      trigger('onRead');
    };

    that.__processSettings = function (resp) {
      s = that.settings;
      trigger = that.trigger;
      lines = s.multiline;
      selectedClass = 'mbsc-sc-itm-sel mbsc-ic mbsc-ic-' + s.checkIcon;
      isPointer = !s.touchUi;

      if (isPointer) {
        // Settings that might be needed by the scroller preset as well
        s.tapSelect = true;
        s.circular = false;
        s.rows = resp.rows || settings.rows || 7;
      }
    };

    that.__init = function (newSettings) {
      if (newSettings) {
        // Reset wheel array in case of setting change,
        // since it might affect the number of wheels
        that._wheelArray = null;
      }

      wheels = [];
      wheelsMap = {};
      showScrollArrows = s.showScrollArrows;
      scroll3d = s.scroll3d && has3d && !showScrollArrows && !isPointer && (s.theme == 'ios' || s.baseTheme == 'ios');
      itemHeight = s.height;
      itemHeight3d = scroll3d ? Math.round((itemHeight - (itemHeight * s.rows / 2 + 3) * 0.03) / 2) * 2 : itemHeight;
      batchSize3d = Math.round(s.rows * 1.8);
      scroll3dAngle = 360 / (batchSize3d * 2); // Ensure a minimum number of 3 items if clickpick buttons present

      if (showScrollArrows) {
        s.rows = Math.max(3, s.rows);
      }
    };

    that._getItemValue = getItemValue; // Properties

    that._tempSelected = {};
    that._selected = {}; // Constructor

    if (!inherit) {
      that.init();
    }
  }; // Extend defaults

  Scroller.prototype = {
    _hasDef: true,
    _hasTheme: true,
    _hasLang: true,
    _responsive: true,
    _class: 'scroller',
    _presets: presets,
    _defaults: extend$1({}, Frame.prototype._defaults, {
      // Options
      minWidth: 80,
      height: 40,
      rows: 3,
      multiline: 1,
      delay: 200,
      readonly: false,
      showLabel: true,
      setOnTap: false,
      wheels: [],
      preset: '',
      speedUnit: 0.0012,
      timeUnit: 0.08,
      checkIcon: 'checkmark',
      compClass: 'mbsc-sc',
      validate: function validate() {},
      formatValue: function formatValue(d) {
        return d.join(' ');
      },
      parseValue: function parseValue(value, inst) {
        var val = [],
            ret = [],
            i = 0,
            found,
            data;

        if (value !== null && value !== undefined) {
          val = (value + '').split(' ');
        }

        $$1.each(inst.settings.wheels, function (j, wg) {
          $$1.each(wg, function (k, w) {
            data = w.data; // Default to first wheel value if not found

            found = inst._getItemValue(data[0]);
            $$1.each(data, function (l, item) {
              // Don't do strict comparison
              if (val[i] == inst._getItemValue(item)) {
                found = inst._getItemValue(item);
                return false;
              }
            });
            ret.push(found);
            i++;
          });
        });
        return ret;
      }
    })
  };
  classes.Scroller = Scroller;

  var defaults$1 = {
    separator: ' ',
    // Localization
    dateFormat: 'mm/dd/yy',
    dateDisplay: 'MMddyy',
    timeFormat: 'h:ii A',
    dayText: 'Day',
    monthText: 'Month',
    yearText: 'Year',
    hourText: 'Hours',
    minuteText: 'Minutes',
    ampmText: '&nbsp;',
    secText: 'Seconds',
    nowText: 'Now',
    todayText: 'Today'
  }; // --- TRIAL SERVER CODE END ---

  var DateTime = function DateTime(inst) {
    function convertRanges(arr) {
      var i,
          v,
          start,
          end,
          ret = [];

      if (arr) {
        for (i = 0; i < arr.length; i++) {
          v = arr[i]; // Check if it's a range, but skip time-only ranges

          if (v.start && v.end && !ISO_8601_TIME.test(v.start)) {
            start = new Date(makeDate(v.start, format, s));
            end = new Date(makeDate(v.end, format, s));

            while (start <= end) {
              ret.push(adjustedDate(start.getFullYear(), start.getMonth(), start.getDate()));
              start.setDate(start.getDate() + 1);
            }
          } else {
            ret.push(v);
          }
        }

        return ret;
      }

      return arr;
    }

    function step(v, st, min, max) {
      return Math.min(max, Math.floor(v / st) * st + min);
    }

    function getMax(step, min, max) {
      return Math.floor((max - min) / step) * step + min;
    }

    function getYear(d) {
      return s.getYear(d);
    }

    function getMonth(d) {
      return s.getMonth(d);
    }

    function getDay(d) {
      return s.getDay(d);
    }

    function getHours(d) {
      var hour = d.getHours();
      hour = hasAmPm && hour >= 12 ? hour - 12 : hour;
      return step(hour, stepHour, minHour, maxHour);
    }

    function getMinutes(d) {
      return step(d.getMinutes(), stepMinute, minMinute, maxMinute);
    }

    function getSeconds(d) {
      return step(d.getSeconds(), stepSecond, minSecond, maxSecond);
    }

    function getMilliseconds(d) {
      return d.getMilliseconds();
    }

    function getAmPm(d) {
      return d.getHours() > 11 ? 1 : 0;
    } // --- TRIAL SERVER CODE START ---


    function getFullDate(d) {
      return d.getFullYear() + '-' + pad(d.getMonth() + 1) + '-' + pad(d.getDate());
    } // --- TRIAL SERVER CODE END ---


    function getFullTime(d) {
      return step(Math.round((d.getTime() - new Date(d).setHours(0, 0, 0, 0)) / 1000), timeStep || 1, 0, 86400);
    }

    function getArrayPart(data, part, d, def) {
      var ret;

      if (wheelOrder[part] !== undefined) {
        ret = +data[wheelOrder[part]];

        if (!isNaN(ret)) {
          return ret;
        }
      }

      if (d) {
        return getDatePart[part](d);
      }

      if (innerValues[part] !== undefined) {
        return innerValues[part];
      }

      return getDatePart[part](def);
    }

    function getDate(data) {
      var d,
          def = new Date(new Date().setHours(0, 0, 0, 0));

      if (data === null) {
        return data;
      }

      if (wheelOrder.dd !== undefined) {
        d = data[wheelOrder.dd].split('-');
        d = new Date(d[0], d[1] - 1, d[2]);
      }

      if (wheelOrder.tt !== undefined) {
        d = d || def;
        d = new Date(d.getTime() + data[wheelOrder.tt] % 86400 * 1000);
      }

      var year = getArrayPart(data, 'y', d, def),
          month = getArrayPart(data, 'm', d, def),
          day = Math.min(getArrayPart(data, 'd', d, def), s.getMaxDayOfMonth(year, month)),
          hour = getArrayPart(data, 'h', d, def);
      return s.getDate(year, month, day, hasAmPm && getArrayPart(data, 'a', d, def) ? hour + 12 : hour, getArrayPart(data, 'i', d, def), getArrayPart(data, 's', d, def), getArrayPart(data, 'u', d, def));
    }

    function getArray(d, fillInner) {
      var i,
          part,
          parts = ['y', 'm', 'd', 'a', 'h', 'i', 's', 'u', 'dd', 'tt'],
          ret = [];

      if (d === null || d === undefined) {
        return d;
      }

      for (i = 0; i < parts.length; i++) {
        part = parts[i];

        if (wheelOrder[part] !== undefined) {
          ret[wheelOrder[part]] = getDatePart[part](d);
        }

        if (fillInner) {
          innerValues[part] = getDatePart[part](d);
        }
      }

      return ret;
    } // --- TRIAL SERVER CODE START ---


    function getDateIndex(d, hasDay) {
      return hasDay ? // Number of days since 1970-01-01
      Math.floor(new Date(d) / 8.64e7) : // Number of month since 1970-01-01
      d.getMonth() + 12 * (d.getFullYear() - 1970);
    }
    /*
    function getYearValue(i) {
        return {
            value: i,
            display: (/yy/i.test(dateDisplay) ? i : (i + '').substr(2, 2)) + (s.yearSuffix || '')
        };
    }
      function getYearIndex(v) {
        return v;
    }
      function getDateWheel(template) {
        var hasDay = /d/i.test(template);
        return {
            label: '',
            cssClass: 'mbsc-dt-whl-date',
            min: minDate ? getDateIndex(getFullDate(minDate), hasDay) : undefined,
            max: maxDate ? getDateIndex(getFullDate(maxDate), hasDay) : undefined,
            data: function (i) {
                var today = new Date(new Date().setHours(0, 0, 0, 0)),
                    d = hasDay ? new Date(i * 8.64e7) : new Date(1970, i, 1);
                  if (hasDay) {
                    d = new Date(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());
                }
                  return {
                    invalid: hasDay && !isValid(d, true),
                    value: getFullDate(d),
                    display: today.getTime() == d.getTime() ? s.todayText : formatDate(template, d, s)
                };
            },
            getIndex: function (v) {
                return getDateIndex(v, hasDay);
            }
        };
    }
      function getTimeWheel(template) {
        var i,
            step,
            time,
            values = [];
          if (/s/i.test(template)) {
            step = stepSecond;
        } else if (/i/i.test(template)) {
            step = stepMinute * 60;
        } else if (/h/i.test(template)) {
            step = stepHour * 3600;
        }
          timeStep = steps.tt = step;
          for (i = 0; i < 86400; i += step) {
            time = new Date(new Date().setHours(0, 0, 0, 0) + i * 1000);
            values.push({
                value: i,
                display: formatDate(template, time, s)
            });
        }
          return {
            label: '',
            cssClass: 'mbsc-dt-whl-time',
            data: values
        };
    }
      function getWheels() {
        var dateParts,
            timeParts,
            template,
            i,
            j,
            types,
            values,
            monthStr,
            nr = 0,
            wheels = [],
            dateGroup = [],
            timeGroup = [];
          if (/date/i.test(preset)) {
            dateParts = dateWheels.split(/\|/.test(dateWheels) ? '|' : '');
              for (i = 0; i < dateParts.length; i++) {
                template = dateParts[i];
                types = 0;
                if (template.length) {
                    // If contains different characters
                    if (/y/i.test(template)) {
                        isoParts.y = 1;
                        types++;
                    }
                      if (/m/i.test(template)) {
                        isoParts.y = 1;
                        isoParts.m = 1;
                        types++;
                    }
                      if (/d/i.test(template)) {
                        isoParts.y = 1;
                        isoParts.m = 1;
                        isoParts.d = 1;
                        types++;
                    }
                      if (types > 1 && wheelOrder.dd === undefined) {
                        wheelOrder.dd = nr;
                        nr++;
                        dateGroup.push(getDateWheel(template));
                        timeGroup = dateGroup; // TODO ???
                        oneDateWheel = true;
                    } else if (/y/i.test(template) && wheelOrder.y === undefined) {
                        wheelOrder.y = nr;
                        nr++;
                          // Year wheel
                        dateGroup.push({
                            cssClass: 'mbsc-dt-whl-y',
                            label: s.yearText,
                            min: minDate ? s.getYear(minDate) : undefined,
                            max: maxDate ? s.getYear(maxDate) : undefined,
                            data: getYearValue,
                            getIndex: getYearIndex
                        });
                    } else if (/m/i.test(template) && wheelOrder.m === undefined) {
                        // Month wheel
                        wheelOrder.m = nr;
                        values = [];
                        nr++;
                          for (j = 0; j < 12; j++) {
                            monthStr = dateDisplay
                                .replace(/[dy|]/gi, '')
                                .replace(/mm/, pad(j + 1) + (s.monthSuffix || ''))
                                .replace(/m/, j + 1 + (s.monthSuffix || ''));
                              values.push({
                                value: j,
                                display: /MM/.test(monthStr) ?
                                    monthStr.replace(/MM/, '<span class="mbsc-dt-month">' + s.monthNames[j] + '</span>') : monthStr.replace(/M/, '<span class="mbsc-dt-month">' + s.monthNamesShort[j] + '</span>')
                            });
                        }
                          dateGroup.push({
                            cssClass: 'mbsc-dt-whl-m',
                            label: s.monthText,
                            data: values
                        });
                    } else if (/d/i.test(template) && wheelOrder.d === undefined) {
                        // Day wheel
                        wheelOrder.d = nr;
                        values = [];
                        nr++;
                          for (j = 1; j < 32; j++) {
                            values.push({
                                value: j,
                                display: (/dd/i.test(dateDisplay) ? pad(j) : j) + (s.daySuffix || '')
                            });
                        }
                          dateGroup.push({
                            cssClass: 'mbsc-dt-whl-d',
                            label: s.dayText,
                            data: values
                        });
                    }
                }
            }
              wheels.push(dateGroup);
        }
          if (/time/i.test(preset)) {
            timeParts = timeWheels.split(/\|/.test(timeWheels) ? '|' : '');
              for (i = 0; i < timeParts.length; i++) {
                template = timeParts[i];
                types = 0;
                if (template.length) {
                    // If contains different characters
                    if (/h/i.test(template)) {
                        isoParts.h = 1;
                        types++;
                    }
                      if (/i/i.test(template)) {
                        isoParts.i = 1;
                        types++;
                    }
                      if (/s/i.test(template)) {
                        isoParts.s = 1;
                        types++;
                    }
                      if (/a/i.test(template)) {
                        types++;
                    }
                }
                  if (types > 1 && wheelOrder.tt === undefined) {
                    wheelOrder.tt = nr;
                    nr++;
                    timeGroup.push(getTimeWheel(template));
                } else if (/h/i.test(template) && wheelOrder.h === undefined) {
                    // Hours wheel
                    values = [];
                    wheelOrder.h = nr;
                    isoParts.h = 1;
                    nr++;
                      for (j = minHour; j < (hasAmPm ? 12 : 24); j += stepHour) {
                        values.push({
                            value: j,
                            display: hasAmPm && j === 0 ? 12 : /hh/i.test(timeDisplay) ? pad(j) : j
                        });
                    }
                      timeGroup.push({
                        cssClass: 'mbsc-dt-whl-h',
                        label: s.hourText,
                        data: values
                    });
                } else if (/i/i.test(template) && wheelOrder.i === undefined) {
                    // Minutes wheel
                    values = [];
                    wheelOrder.i = nr;
                    isoParts.i = 1;
                    nr++;
                      for (j = minMinute; j < 60; j += stepMinute) {
                        values.push({
                            value: j,
                            display: /ii/i.test(timeDisplay) ? pad(j) : j
                        });
                    }
                      timeGroup.push({
                        cssClass: 'mbsc-dt-whl-i',
                        label: s.minuteText,
                        data: values
                    });
                } else if (/s/i.test(template) && wheelOrder.s === undefined) {
                    // Seconds wheel
                    values = [];
                    wheelOrder.s = nr;
                    isoParts.s = 1;
                    nr++;
                      for (j = minSecond; j < 60; j += stepSecond) {
                        values.push({
                            value: j,
                            display: /ss/i.test(timeDisplay) ? pad(j) : j
                        });
                    }
                      timeGroup.push({
                        cssClass: 'mbsc-dt-whl-s',
                        label: s.secText,
                        data: values
                    });
                } else if (/a/i.test(template) && wheelOrder.a === undefined) {
                    wheelOrder.a = nr;
                    nr++;
                      timeGroup.push({
                        cssClass: 'mbsc-dt-whl-a',
                        label: s.ampmText,
                        data: /A/.test(template) ? [{
                            value: 0,
                            display: s.amText.toUpperCase()
                        }, {
                            value: 1,
                            display: s.pmText.toUpperCase()
                        }] : [{
                            value: 0,
                            display: s.amText
                        }, {
                            value: 1,
                            display: s.pmText
                        }]
                    });
                }
            }
              if (timeGroup != dateGroup) {
                wheels.push(timeGroup);
            }
        }
          return wheels;
    }
    */


    function getHtml5Options($elm) {
      var format,
          min,
          max,
          ret = {}; // Force format for html5 date inputs (experimental)

      if ($elm.is('input')) {
        switch ($elm.attr('type')) {
          case 'date':
            format = 'yy-mm-dd';
            break;

          case 'datetime':
            format = 'yy-mm-ddTHH:ii:ssZ';
            break;

          case 'datetime-local':
            format = 'yy-mm-ddTHH:ii:ss';
            break;

          case 'month':
            format = 'yy-mm';
            ret.dateOrder = 'mmyy';
            break;

          case 'time':
            format = 'HH:ii:ss';
            break;
        }

        ret.format = format; // Check for min/max attributes

        min = $elm.attr('min');
        max = $elm.attr('max');

        if (min && min != 'undefined') {
          ret.min = parseDate(format, min);
        }

        if (max && max != 'undefined') {
          ret.max = parseDate(format, max);
        }
      }

      return ret;
    }

    function getClosestValidDate(d, dir) {
      var next,
          prev,
          nextValid = false,
          prevValid = false,
          up = 0,
          down = 0,
          // Normalize min and max dates for comparing later (set default values where there are no values from wheels)
      mind = minDate ? getDate(getArray(minDate)) : -Infinity,
          maxd = maxDate ? getDate(getArray(maxDate)) : Infinity;

      if (isValid(d)) {
        return d;
      }

      if (d < mind) {
        d = mind;
      }

      if (d > maxd) {
        d = maxd;
      }

      next = d;
      prev = d;

      if (dir !== 2) {
        nextValid = isValid(next, true);

        while (!nextValid && next < maxd && up < 100) {
          next = new Date(next.getTime() + 1000 * 60 * 60 * 24);
          nextValid = isValid(next, true);
          up++;
        }
      }

      if (dir !== 1) {
        prevValid = isValid(prev, true);

        while (!prevValid && prev > mind && down < 100) {
          prev = new Date(prev.getTime() - 1000 * 60 * 60 * 24);
          prevValid = isValid(prev, true);
          down++;
        }
      }

      if (dir === 1 && nextValid) {
        return next;
      }

      if (dir === 2 && prevValid) {
        return prev;
      }

      if (isSameMonth(d, next)) {
        return next;
      }

      if (isSameMonth(d, prev)) {
        return prev;
      }

      return down <= up && prevValid ? prev : next;
    }

    function isSameMonth(d1, d2) {
      return s.getYear(d1) === s.getYear(d2) && s.getMonth(d1) === s.getMonth(d2);
    }

    function isValid(d, skip) {
      if (!skip && d < minDate) {
        return false;
      }

      if (!skip && d > maxDate) {
        return false;
      }

      if (isInObj(d, valid)) {
        return true;
      }

      if (isInObj(d, invalid)) {
        return false;
      }

      return true;
    }

    function isInObj(d, obj) {
      var curr, j, v, val;

      if (obj) {
        for (j = 0; j < obj.length; j++) {
          curr = obj[j];
          val = curr.d || curr;
          v = val + '';

          if (!curr.start) {
            if (DAY_OF_WEEK.test(v)) {
              // Day of week
              v = +v.replace('w', '');

              if (v == d.getDay()) {
                return true;
              }
            } else if (DAY_OF_MONTH.test(v)) {
              // Day of month: '2' or '12/24'
              v = v.split('/');

              if (v[1]) {
                if (v[0] - 1 == d.getMonth() && v[1] == d.getDate()) {
                  return true;
                }
              } else if (v[0] == d.getDate()) {
                return true;
              }
            } else {
              // Exact date
              curr = makeDate(val, format, s);

              if (d.getFullYear() == curr.getFullYear() && d.getMonth() == curr.getMonth() && d.getDate() == curr.getDate()) {
                return true;
              }
            }
          }
        }
      }

      return false;
    }

    function validateDates(obj, y, m, first, maxdays, invalids, val) {
      var d, dd, j, k, v;

      if (obj) {
        for (j = 0; j < obj.length; j++) {
          d = obj[j];
          dd = d.d || d;
          v = dd + '';

          if (!d.start) {
            if (DAY_OF_WEEK.test(v)) {
              // Day of week
              v = +v.replace('w', '');

              for (k = v - first; k < maxdays; k += 7) {
                if (k >= 0) {
                  invalids[k + 1] = val;
                }
              }
            } else if (DAY_OF_MONTH.test(v)) {
              // Day of month: '2' or '12/24'
              v = v.split('/');

              if (v[1]) {
                if (v[0] - 1 == m) {
                  invalids[v[1]] = val;
                }
              } else {
                invalids[v[0]] = val;
              }
            } else {
              // Exact date
              d = makeDate(dd, format, s);

              if (s.getYear(d) == y && s.getMonth(d) == m) {
                invalids[s.getDay(d)] = val;
              }
            }
          }
        }
      }
    }

    function validateTimes(vobj, index, v, y, m, d, invalids, valid) {
      var add,
          all,
          dd,
          hours1,
          hours2,
          hours3,
          i,
          i1,
          i2,
          j,
          obj,
          parts1,
          parts2,
          prop1,
          prop2,
          remove,
          ss,
          str,
          v1,
          v2,
          spec = {},
          day = s.getDate(y, m, d),
          w = ['a', 'h', 'i', 's'];

      if (vobj) {
        // Check if rules apply to the selected date
        for (i = 0; i < vobj.length; i++) {
          obj = vobj[i];

          if (obj.start) {
            obj.apply = false;
            dd = obj.d;
            ss = dd + '';
            str = ss.split('/');

            if (dd && (dd.getTime && y == s.getYear(dd) && m == s.getMonth(dd) && d == s.getDay(dd) || // Exact date
            !DAY_OF_WEEK.test(ss) && (str[1] && d == str[1] && m == str[0] - 1 || !str[1] && d == str[0]) || // Day of month
            DAY_OF_WEEK.test(ss) && day.getDay() == +ss.replace('w', '') // Day of week
            )) {
              obj.apply = true;
              spec[day] = true; // Prevent applying generic rule on day, if specific exists
            }
          }
        } // Apply rules


        for (i = 0; i < vobj.length; i++) {
          obj = vobj[i];
          add = 0;
          remove = 0;
          i1 = mins[v];
          i2 = maxs[v];
          prop1 = true;
          prop2 = true;
          all = false;

          if (obj.start && (obj.apply || !obj.d && !spec[day])) {
            // Define time parts
            parts1 = obj.start.split(':');
            parts2 = obj.end.split(':');

            for (j = 0; j < 3; j++) {
              if (parts1[j] === undefined) {
                parts1[j] = 0;
              }

              if (parts2[j] === undefined) {
                parts2[j] = 59;
              }

              parts1[j] = +parts1[j];
              parts2[j] = +parts2[j];
            }

            if (v == 'tt') {
              // Wheel containing full time
              i1 = step(Math.round((new Date(day).setHours(parts1[0], parts1[1], parts1[2]) - new Date(day).setHours(0, 0, 0, 0)) / 1000), timeStep, 0, 86400);
              i2 = step(Math.round((new Date(day).setHours(parts2[0], parts2[1], parts2[2]) - new Date(day).setHours(0, 0, 0, 0)) / 1000), timeStep, 0, 86400);
            } else {
              parts1.unshift(parts1[0] > 11 ? 1 : 0);
              parts2.unshift(parts2[0] > 11 ? 1 : 0);

              if (hasAmPm) {
                if (parts1[1] >= 12) {
                  parts1[1] = parts1[1] - 12;
                }

                if (parts2[1] >= 12) {
                  parts2[1] = parts2[1] - 12;
                }
              } // Look behind


              for (j = 0; j < index; j++) {
                if (validValues[j] !== undefined) {
                  v1 = step(parts1[j], steps[w[j]], mins[w[j]], maxs[w[j]]);
                  v2 = step(parts2[j], steps[w[j]], mins[w[j]], maxs[w[j]]);
                  hours1 = 0;
                  hours2 = 0;
                  hours3 = 0;

                  if (hasAmPm && j == 1) {
                    hours1 = parts1[0] ? 12 : 0;
                    hours2 = parts2[0] ? 12 : 0;
                    hours3 = validValues[0] ? 12 : 0;
                  }

                  if (!prop1) {
                    v1 = 0;
                  }

                  if (!prop2) {
                    v2 = maxs[w[j]];
                  }

                  if ((prop1 || prop2) && v1 + hours1 < validValues[j] + hours3 && validValues[j] + hours3 < v2 + hours2) {
                    all = true;
                  }

                  if (validValues[j] != v1) {
                    prop1 = false;
                  }

                  if (validValues[j] != v2) {
                    prop2 = false;
                  }
                }
              } // Look ahead


              if (!valid) {
                for (j = index + 1; j < 4; j++) {
                  if (parts1[j] > 0) {
                    add = steps[v];
                  }

                  if (parts2[j] < maxs[w[j]]) {
                    remove = steps[v];
                  }
                }
              }

              if (!all) {
                // Calculate min and max values
                v1 = step(parts1[index], steps[v], mins[v], maxs[v]) + add;
                v2 = step(parts2[index], steps[v], mins[v], maxs[v]) - remove;

                if (prop1) {
                  i1 = v1;
                }

                if (prop2) {
                  i2 = v2;
                }
              }
            } // Disable values


            if (prop1 || prop2 || all) {
              for (j = i1; j <= i2; j += steps[v]) {
                invalids[j] = !valid;
              }
            }
          }
        }
      }
    } // --- TRIAL SERVER CODE START ---


    var timeStep,
        oneDateWheel,
        wheels,
        wheelOrder = {},
        innerValues = {},
        isoParts = {},
        validValues = [],
        html5def = getHtml5Options($$1(this)),
        orig = extend$1({}, inst.settings),
        calendarSystem = calendars[orig.calendarSystem],
        s = extend$1(inst.settings, dateTimeDefaults, calendarSystem, defaults$1, html5def, orig),
        preset = s.preset,
        displayFormat = preset == 'datetime' ? s.dateFormat + s.separator + s.timeFormat : preset == 'time' ? s.timeFormat : s.dateFormat,
        format = html5def.format || displayFormat,
        dateWheels = s.dateWheels || s.dateFormat,
        timeWheels = s.timeWheels || s.timeFormat,
        //dateWheels = '|D M d|', // TODO settings
    //timeWheels = '|h|ii|A|',
    dateDisplay = s.dateWheels || s.dateDisplay,
        timeDisplay = timeWheels,
        baseTheme = s.baseTheme || s.theme,
        invalid = convertRanges(s.invalid),
        valid = convertRanges(s.valid),
        minDate = makeDate(s.min, format, s),
        maxDate = makeDate(s.max, format, s),
        hasTime = /time/i.test(preset),
        hasAmPm = /h/.test(timeDisplay),
        genDayNames = /D/.test(dateDisplay),
        stepParts = s.steps || {},
        stepHour = stepParts.hour || s.stepHour || 1,
        stepMinute = stepParts.minute || s.stepMinute || 1,
        stepSecond = stepParts.second || s.stepSecond || 1,
        zeroBased = stepParts.zeroBased,
        minHour = zeroBased || !minDate ? 0 : minDate.getHours() % stepHour,
        minMinute = zeroBased || !minDate ? 0 : minDate.getMinutes() % stepMinute,
        minSecond = zeroBased || !minDate ? 0 : minDate.getSeconds() % stepSecond,
        maxHour = getMax(stepHour, minHour, hasAmPm ? 11 : 23),
        maxMinute = getMax(stepMinute, minMinute, 59),
        maxSecond = getMax(stepMinute, minMinute, 59),
        mins = {
      y: minDate ? minDate.getFullYear() : -Infinity,
      m: 0,
      d: 1,
      h: minHour,
      i: minMinute,
      s: minSecond,
      a: 0,
      tt: 0
    },
        maxs = {
      y: maxDate ? maxDate.getFullYear() : Infinity,
      m: 11,
      d: 31,
      h: maxHour,
      i: maxMinute,
      s: maxSecond,
      a: 1,
      tt: 86400
    },
        steps = {
      y: 1,
      m: 1,
      d: 1,
      h: stepHour,
      i: stepMinute,
      s: stepSecond,
      a: 1,
      tt: 1
    },
        widths = {
      bootstrap: 46,
      ios: 50,
      material: 46,
      mobiscroll: 46,
      windows: 50
    },
        getDatePart = {
      y: getYear,
      m: getMonth,
      d: getDay,
      h: getHours,
      i: getMinutes,
      s: getSeconds,
      u: getMilliseconds,
      a: getAmPm,
      dd: getFullDate,
      tt: getFullTime
    }; // --- TRIAL SERVER CODE END ---
    // Extended methods
    // ---

    inst.getVal = function (temp) {
      return inst._hasValue || temp ? returnDate(getDate(inst.getArrayVal(temp)), s, format) : null;
    };
    /**
     * Returns the selected date.
     *
     * @param {Boolean} [temp=false] If true, return the currently shown date on the picker, otherwise the last selected one.
     * @return {Date}
     */


    inst.getDate = function (temp) {
      return inst._hasValue || temp ? getDate(inst.getArrayVal(temp)) : null;
    };
    /**
     * Sets the selected date
     *
     * @param {Date} d Date to select.
     * @param {Boolean} [fill=false] Also set the value of the associated input element. Default is true.
     * @param {Number} [time=0] Animation time to scroll to the selected date.
     * @param {Boolean} [temp=false] Set temporary value only.
     * @param {Boolean} [change=fill] Trigger change on input element.
     */


    inst.setDate = function (d, fill, time, temp, change) {
      inst.setArrayVal(getArray(d, true), fill, change, temp, time);
    }; // ---
    // Initializations
    // ---

    /*
    wheels = getWheels();
      s.isoParts = isoParts;
    */
    // --- REMOTE TRIAL CODE START ---


    wheelOrder = inst.remote.datetime.wheelOrder;
    oneDateWheel = inst.remote.datetime.oneDateWheel;
    timeStep = inst.remote.datetime.timeStep;
    wheels = inst.remote.datetime.wheels;
    s.isoParts = isoParts = inst.remote.datetime.isoParts;
    s.dateDisplay = dateDisplay;
    inst.remote.datetime.isValid = isValid;
    inst.remote.datetime.getFullDate = getFullDate;
    inst.remote.datetime.getDateIndex = getDateIndex;
    inst.remote.datetime.datetime = {
      formatDate: formatDate
    }; // --- REMOTE TRIAL CODE END ---

    inst._format = displayFormat;
    inst._order = wheelOrder;

    inst.handlers.now = function () {
      inst.setDate(new Date(), inst.live, 1000, true, true);
    };

    inst.buttons.now = {
      text: s.nowText,
      icon: s.nowIcon,
      handler: 'now'
    }; // ---

    return {
      minWidth: oneDateWheel && hasTime ? widths[baseTheme] : undefined,
      compClass: 'mbsc-dt mbsc-sc',
      wheels: wheels,
      headerText: s.headerText ? function () {
        return formatDate(displayFormat, getDate(inst.getArrayVal(true)), s);
      } : false,
      formatValue: function formatValue(d) {
        return formatDate(format, getDate(d), s);
      },
      parseValue: function parseValue(val) {
        if (!val) {
          innerValues = {};
          inst._hasValue = false;
        }

        return getArray(makeDate(val || s.defaultValue || new Date(), format, s, isoParts), !!val);
      },
      validate: function validate(data) {
        var i,
            j,
            dayStr,
            weekDay,
            values = data.values,
            index = data.index,
            dir = data.direction,
            dayWheel = s.wheels[0][wheelOrder.d],
            validated = getClosestValidDate(getDate(values), dir),
            temp = getArray(validated),
            disabled = [],
            wheels = {},
            y = getDatePart.y(validated),
            //get(temp, 'y'),
        m = getDatePart.m(validated),
            //get(temp, 'm'),
        maxdays = s.getMaxDayOfMonth(y, m),
            minprop = true,
            maxprop = true;
        $$1.each(['dd', 'y', 'm', 'd', 'tt', 'a', 'h', 'i', 's'], function (x, i) {
          var min = mins[i],
              max = maxs[i],
              val = getDatePart[i](validated);
          disabled[wheelOrder[i]] = [];

          if (minprop && minDate) {
            min = getDatePart[i](minDate);
          }

          if (maxprop && maxDate) {
            max = getDatePart[i](maxDate);
          }

          if (val < min) {
            val = min;
          }

          if (val > max) {
            val = max;
          }

          if (i !== 'dd' && i !== 'tt') {
            if (minprop) {
              minprop = val == min;
            }

            if (maxprop) {
              maxprop = val == max;
            }
          }

          if (wheelOrder[i] !== undefined) {
            if (i != 'y' && i != 'dd') {
              for (j = mins[i]; j <= maxs[i]; j += steps[i]) {
                if (j < min || j > max) {
                  disabled[wheelOrder[i]].push(j);
                }
              }
            } // Disable some days


            if (i == 'd') {
              var first = s.getDate(y, m, 1).getDay(),
                  invalids = {}; // Set invalid indexes

              validateDates(invalid, y, m, first, maxdays, invalids, 1); // Delete indexes which are valid

              validateDates(valid, y, m, first, maxdays, invalids, 0);
              $$1.each(invalids, function (j, v) {
                if (v) {
                  disabled[wheelOrder[i]].push(j);
                }
              });
            }
          }
        }); // Invalid times

        if (hasTime) {
          $$1.each(['a', 'h', 'i', 's', 'tt'], function (i, v) {
            var val = getDatePart[v](validated),
                d = getDatePart.d(validated),
                invalids = {};

            if (wheelOrder[v] !== undefined) {
              validateTimes(invalid, i, v, y, m, d, invalids, 0);
              validateTimes(valid, i, v, y, m, d, invalids, 1);
              $$1.each(invalids, function (j, x) {
                if (x) {
                  disabled[wheelOrder[v]].push(j);
                }
              }); // Get valid value

              validValues[i] = inst.getValidValue(wheelOrder[v], val, dir, invalids);
            }
          });
        } // Regenerate day wheel if number of days in month changes
        // or if day names needs to be regenerated


        if (dayWheel && (dayWheel.data.length !== maxdays || genDayNames && (index === undefined || index === wheelOrder.y || index === wheelOrder.m))) {
          wheels[wheelOrder.d] = dayWheel;
          dayWheel.data = [];

          for (i = 1; i <= maxdays; i++) {
            weekDay = s.getDate(y, m, i).getDay();
            dayStr = dateDisplay.replace(/[my|]/gi, '').replace(/dd/, (i < 10 ? '0' + i : i) + (s.daySuffix || '')).replace(/d/, i + (s.daySuffix || ''));
            dayWheel.data.push({
              value: i,
              display: /DD/.test(dayStr) ? dayStr.replace(/DD/, '<span class="mbsc-dt-day">' + s.dayNames[weekDay] + '</span>') : dayStr.replace(/D/, '<span class="mbsc-dt-day">' + s.dayNamesShort[weekDay] + '</span>')
            });
          } // Need to update day value, if out of month


          inst._tempWheelArray[wheelOrder.d] = temp[wheelOrder.d];
          inst.changeWheel(wheels);
        }

        return {
          disabled: disabled,
          valid: temp
        };
      }
    };
  };

  var id$1 = 0;

  function jsonp$1(url, callback) {
    var script = document.createElement('script'),
        unique = 'mbscjsonp' + ++id$1;

    window[unique] = function (data) {
      script.parentNode.removeChild(script);
      delete window[unique];

      if (!data) {
        return;
      }

      callback(data);
    };

    script.src = url + (url.indexOf('?') >= 0 ? '&' : '?') + 'callback=' + unique;
    document.body.appendChild(script);
  }

  function ajaxGet(url, callback) {
    var request = new XMLHttpRequest();
    request.open('GET', url, true);

    request.onload = function () {
      if (this.status >= 200 && this.status < 400) {
        // Success!
        callback(JSON.parse(this.response));
      } //else {
      // We reached our target server, but it returned an error
      //}

    };

    request.onerror = function () {// There was a connection error of some sort
    };

    request.send();
  }

  function getJson(url, callback, type) {
    if (type == 'jsonp') {
      jsonp$1(url, callback);
    } else {
      ajaxGet(url, callback);
    }
  }

  util.getJson = getJson;

  // eslint-disable-next-line no-unused-vars

  var defaults$2 = {
    controls: ['calendar'],
    firstDay: 0,
    weekDays: 'short',
    maxMonthWidth: 170,
    breakPointMd: 768,
    months: 1,
    pageBuffer: 1,
    weeks: 6,
    highlight: true,
    outerMonthChange: true,
    quickNav: true,
    yearChange: true,
    tabs: 'auto',
    // CSS classes
    todayClass: 'mbsc-cal-today',
    btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left6',
    btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right6',
    // Localization
    dateText: 'Date',
    timeText: 'Time',
    todayText: 'Today',
    fromText: 'Start',
    toText: 'End',
    moreEventsText: '{count} more',
    prevMonthText: 'Previous Month',
    nextMonthText: 'Next Month',
    prevYearText: 'Previous Year',
    nextYearText: 'Next Year'
  }; // --- TRIAL SERVER CODE END ---

  var CalendarBase = function CalendarBase(inst) {
    var $calendar,
        $markup,
        $monthHdr,
        $monthPicker,
        $tabPaneCont,
        $tabPanes,
        $yearHdr,
        $yearPicker,
        activeDate,
        base,
        calRows,
        calSize,
        calWidth,
        context,
        controls,
        controlsArray,
        cssDisabled,
        cssSelected,
        cssSelectedTab,
        currFirstDay,
        dayLabels,
        dayProps,
        dayScroll,
        displayFormat,
        firstWeekDay,
        hasCal,
        hasLabels,
        hasMarks,
        hasTabs,
        // hasText,
    hasQuickNav,
        hoverTimer,
        invalidObj,
        isCellHover,
        isDayClick,
        isLiquid,
        isMonthView,
        isPageMove,
        isRTL,
        isVertical,
        labelsObj,
        markedObj,
        colorsObj,
        maxDate,
        maxFirstYear,
        maxLabels,
        maxMonth,
        maxYear,
        minDate,
        minFirstYear,
        minMonth,
        minYear,
        monthIndex,
        monthNames,
        monthScroll,
        needsSlide,
        needsRefresh,
        pageBuffer,
        pageNr,
        pageOffset,
        pageTotal,
        rtl,
        s,
        selectedDate,
        showOuterDays,
        trigger,
        validObj,
        visibleTab,
        wasTouched,
        weekCounter,
        weekDays,
        yearChange,
        yearIndex,
        yearScroll,
        yearSuffix,
        labelIdx = 1,
        elm = this;

    function showCont($cont) {
      if ($cont.hasClass('mbsc-cal-h')) {
        $cont.removeClass('mbsc-cal-h');
      }
    }

    function hideCont($cont) {
      if (!$cont.hasClass('mbsc-cal-h')) {
        $cont.addClass('mbsc-cal-h');
      }
    }

    function toggleCont($cont) {
      if ($cont.hasClass('mbsc-cal-h')) {
        showCont($cont);
      } else {
        hideCont($cont);
      }
    }

    function preProcessSettings() {
      var ctrls, layout, orig;
      controls = {};
      controlsArray = [];
      dayLabels = {};
      trigger = inst.trigger;
      orig = extend$1({}, inst.settings);
      s = extend$1(inst.settings, defaults$2, orig);
      ctrls = s.controls.join(',');
      firstWeekDay = s.firstDay;
      isRTL = s.rtl;
      pageBuffer = s.pageBuffer;
      weekCounter = s.weekCounter;
      calRows = s.weeks;
      isMonthView = calRows == 6;
      isVertical = s.calendarScroll == 'vertical';
      context = inst._getRespCont();
      weekDays = s.weekDays == 'full' ? '' : s.weekDays == 'min' ? 'Min' : 'Short';
      layout = s.layout || (s.display == 'inline' || /top|bottom/.test(s.display) && s.touchUi ? 'liquid' : '');
      isLiquid = layout == 'liquid'; // && s.display !== 'bubble';

      calWidth = isLiquid ? null : s.calendarWidth;
      rtl = isRTL && !isVertical ? -1 : 1;
      cssDisabled = 'mbsc-disabled ' + (s.disabledClass || '');
      cssSelectedTab = 'mbsc-selected ' + (s.selectedTabClass || '');
      cssSelected = 'mbsc-selected ' + (s.selectedClass || '');
      maxLabels = Math.max(1, Math.floor(((s.calendarHeight || 0) / calRows - 45) / 18));

      if (ctrls.match(/calendar/)) {
        controls.calendar = 1;
        hasCal = true;
      } // Allow date scroller only if calendar not present


      if (ctrls.match(/date/) && !hasCal) {
        controls.date = 1;
      }

      if (ctrls.match(/time/)) {
        controls.time = 1;
      }

      s.controls.forEach(function (v) {
        if (controls[v]) {
          controlsArray.push(v);
        }
      }); // Disable quick nav for week view

      hasQuickNav = s.quickNav && hasCal && isMonthView; // Disable year change for week view

      yearChange = s.yearChange && isMonthView; // Fullscreen mode

      if (isLiquid && hasCal && s.display == 'center') {
        inst._isFullScreen = true;
      }

      s.layout = layout; // Pass back to core if set to liquid

      s.preset = (controls.date || hasCal ? 'date' : '') + (controls.time ? 'time' : '');
    }

    function postProcessSettings() {
      monthNames = yearChange ? s.monthNamesShort : s.monthNames;
      yearSuffix = s.yearSuffix || '';
      monthIndex = (s.dateWheels || s.dateFormat).search(/m/i);
      yearIndex = (s.dateWheels || s.dateFormat).search(/y/i);
      displayFormat = inst._format;

      if (s.min) {
        minDate = getDateOnly(makeDate(s.min, displayFormat, s));
        minYear = s.getYear(minDate);
        minMonth = s.getMonth(minDate);
        minFirstYear = s.getDate(Math.floor(minYear / 12) * 12, 0, 1);
      }

      if (s.max) {
        maxDate = getDateOnly(makeDate(s.max, displayFormat, s));
        maxYear = s.getYear(maxDate);
        maxMonth = s.getMonth(maxDate);
        maxFirstYear = s.getDate(Math.floor(maxYear / 12) * 12, 0, 1);
      }

      inst._minDate = minDate;
      inst._maxDate = maxDate;
    }

    function addToList(obj, d, ev) {
      obj[d] = obj[d] || [];
      obj[d].push(ev);
    }

    function prepareObj(list, start, end) {
      var d,
          v,
          year,
          month,
          day,
          maxDays,
          endTime,
          startTime,
          getDate = s.getDate,
          getYear = s.getYear,
          getMonth = s.getMonth,
          getDay = s.getDay,
          getMaxDayOfMonth = s.getMaxDayOfMonth,
          startYear = getYear(start),
          startMonth = getMonth(start),
          obj = {};

      if (list) {
        $$1.each(list, function (i, ev) {
          d = ev.d || ev.start || ev;
          v = d + '';

          if (ev.start && ev.end) {
            startTime = getDateOnly(makeDate(ev.start, displayFormat, s));
            endTime = getDateOnly(makeDate(ev.end, displayFormat, s));

            while (startTime <= endTime) {
              addToList(obj, startTime, ev);
              startTime = getDate(getYear(startTime), getMonth(startTime), getDay(startTime) + 1);
            }
          } else if (DAY_OF_WEEK.test(v)) {
            // Day of week
            startTime = getFirstDay(start, false, +v.replace('w', ''));

            while (startTime <= end) {
              addToList(obj, startTime, ev);
              startTime = getDate(getYear(startTime), getMonth(startTime), getDay(startTime) + 7);
            }
          } else if (DAY_OF_MONTH.test(v)) {
            // Day of month: '2' or '12/24'
            v = v.split('/');
            var hasMonth = !!v[1],
                yearInc = hasMonth ? 1 : 0,
                monthInc = hasMonth ? 0 : 1,
                vMonth = hasMonth ? v[0] - 1 : startMonth,
                vDay = hasMonth ? +v[1] : +v[0];
            maxDays = getMaxDayOfMonth(startYear, vMonth);
            startTime = getDate(startYear, vMonth, Math.min(vDay, maxDays));

            while (startTime <= end) {
              year = getYear(startTime);
              month = getMonth(startTime);
              day = getDay(startTime);

              if (day === vDay) {
                addToList(obj, startTime, ev);
              }

              maxDays = getMaxDayOfMonth(year + yearInc, month + monthInc);
              startTime = getDate(year + yearInc, month + monthInc, Math.min(vDay, maxDays));
            }
          } else {
            // Exact date
            addToList(obj, getDateOnly(makeDate(d, displayFormat, s)), ev);
          }
        });
      }

      return obj;
    }

    function isValidDate(d) {
      if (d < minDate) {
        return false;
      }

      if (d > maxDate) {
        return false;
      }

      return invalidObj[d] === undefined || validObj[d] !== undefined;
    }

    function getDayProps(d) {
      var i,
          mark,
          markedMarkup,
          props,
          marked = markedObj[d] ? markedObj[d] : false,
          colors = colorsObj[d] ? colorsObj[d] : false,
          background = colors && colors[0].background ? colors[0].background : marked && marked[0].background,
          cssClass = '';

      if (colors) {
        for (i = 0; i < colors.length; i++) {
          cssClass += (colors[i].cssClass || '') + ' ';
        }
      }

      if (marked) {
        // Marks
        markedMarkup = '<div class="mbsc-cal-marks">';

        for (i = 0; i < marked.length; i++) {
          mark = marked[i];
          cssClass += (mark.cssClass || '') + ' ';
          markedMarkup += '<div class="mbsc-cal-mark"' + (mark.color ? ' style="background:' + mark.color + ';"' : '') + '></div>';
        }

        markedMarkup += '</div>';
      }

      props = {
        marked: marked,
        background: background,
        cssClass: cssClass,
        // ariaLabel: hasText ? txt : '',
        markup: dayLabels[d] ? dayLabels[d].join('') : hasMarks ? markedMarkup : ''
      };
      return extend$1(props, inst._getDayProps(d, props));
    }

    function getOffsetStyle(offset) {
      return ' style="' + (isVertical ? 'transform: translateY(' + offset * 100 + '%)' : 'left:' + offset * 100 * rtl + '%') + '"';
    }

    function calcMonthNr() {
      // Calculate pageNr
      pageNr = s.months == 'auto' ? // Exact month number from setting
      Math.max(1, // Min 1 month
      Math.min(3, // Max 3 months
      Math.floor((calWidth || getWidth(context)) / 280))) : +s.months;
      pageTotal = pageNr + 2 * pageBuffer;
      pageOffset = 0; //Math.round(pageNr / 2) - 1;
      // Don't allow vertical scroll with multiple months

      isVertical = isVertical && pageNr < 2; // Don't show outer days by default for multiple months or vertical scroll

      showOuterDays = s.showOuterDays === undefined ? pageNr < 2 && !isVertical || !isMonthView : s.showOuterDays;
    }

    function constrain(d) {
      if (getPageDay(d, pageNr - 1) > maxDate) {
        d = getPageDay(maxDate, 1 - pageNr);
      }

      if (d < minDate) {
        d = minDate;
      }

      return d;
    }

    function getLabelMarkup(event, i, showText) {
      var noBg = event.background === 'none';
      var color = noBg ? 'none' : event.color;
      var txtColor = noBg ? event.color : getTextColor(color);
      var txt = event.text;
      return '<div data-id="' + event._id + '" data-index="' + i + '" class="mbsc-cal-txt' + (noBg ? ' mbsc-cal-txt-only' : '') + '" title="' + $$1('<div>' + txt + '</div>').text() + '"' + (color ? ' style="background:' + color + (showText && txtColor ? ';color:' + txtColor : '') + ';"' : '') + '>' + (showText ? txt : '') + '</div>';
    }

    function compareEvents(a, b) {
      var start1 = a.start ? makeDate(a.start) : null,
          start2 = b.start ? makeDate(b.start) : null,
          end1 = a.end ? makeDate(a.end) : null,
          end2 = b.end ? makeDate(b.end) : null,
          isRepeating1 = DAY_OF_WEEK.test(a.d) || DAY_OF_MONTH.test(a.d),
          isRepeating2 = DAY_OF_WEEK.test(b.d) || DAY_OF_MONTH.test(b.d),
          dt1 = a.d ? isRepeating1 ? a.d : makeDate(a.d) : start1,
          dt2 = b.d ? isRepeating2 ? b.d : makeDate(b.d) : start2,
          weight1 = !dt1.getTime ? 0 : a.allDay ? 1 : dt1.getTime(),
          weight2 = !dt2.getTime ? 0 : b.allDay ? 1 : dt2.getTime();

      if (weight1 == weight2) {
        return a.text > b.text ? 1 : -1;
      }

      return weight1 - weight2;
    }

    function sortEvents(events) {
      return events.slice(0).sort(s.eventOrder);
    }

    function onGenMonth(d) {
      var start = getFirstDay(getPageDay(d, -pageOffset - pageBuffer), false);
      var end = getFirstDay(getPageDay(d, -pageOffset + pageNr + pageBuffer - 1), false);
      end = s.getDate(s.getYear(end), s.getMonth(end), s.getDay(end) + calRows * 7);

      inst._onGenMonth(start, end);

      invalidObj = prepareObj(s.invalid, start, end);
      validObj = prepareObj(s.valid, start, end);
      markedObj = prepareObj(s.labels || s.events || s.marked, start, end);
      colorsObj = prepareObj(s.colors, start, end);
      labelsObj = inst._labels || markedObj || colorsObj;
      hasLabels = s.labels || inst._labels; // Multiple labels

      if (hasLabels) {
        (function () {
          dayLabels = {};
          var eventRows = {};
          var day = start;

          var _loop = function _loop() {
            if (day.getDay() == firstWeekDay) {
              eventRows = {};
            }

            var maxRows = maxLabels;
            var events = sortEvents(labelsObj[day] || []);
            var eventsNr = events.length;
            var labels = [];
            var prevEvent = void 0;
            var prevIndex = void 0;
            var row = 0;
            var displayed = 0;
            var i = 0;
            var width = void 0;

            while (row < maxRows) {
              prevEvent = null; // Check  if there are any events already in this row

              events.forEach(function (ev, j) {
                if (eventRows[row] == ev) {
                  prevEvent = ev;
                  prevIndex = j;
                }
              });

              if (row == maxRows - 1 && (displayed < eventsNr - 1 || eventsNr && i == eventsNr && !prevEvent)) {
                var nr = eventsNr - displayed;
                var txt = (nr > 1 ? s.moreEventsPluralText || s.moreEventsText : s.moreEventsText).replace(/{count}/, nr);

                if (nr) {
                  labels.push('<div class="mbsc-cal-txt-more">' + txt + '</div>');
                } // Remove event from previous days and replace it with more label


                if (prevEvent) {
                  eventRows[row] = null;

                  prevEvent._days.forEach(function (d) {
                    dayLabels[d][row] = '<div class="mbsc-cal-txt-more">' + s.moreEventsText.replace(/{count}/, 1) + '</div>';
                  });
                }

                displayed++;
                row++;
              } else if (prevEvent) {
                if (prevIndex == i) {
                  i++;
                }

                if (isSameDay(day, makeDate(prevEvent.end))) {
                  eventRows[row] = null;
                }

                labels.push(getLabelMarkup(prevEvent, prevIndex));
                row++;
                displayed++;

                prevEvent._days.push(day);
              } else if (i < eventsNr) {
                var event = events[i];
                var startTime = event.start && makeDate(event.start);
                var endTime = event.end && makeDate(event.end);
                var weekDay = day.getDay();
                var offset = firstWeekDay - weekDay > 0 ? 7 : 0;
                var multiDay = endTime && !isSameDay(startTime, endTime);

                if (!startTime || // all day event
                isSameDay(day, startTime) || // event start day
                weekDay == firstWeekDay // first day of week (if event continues from prev week))
                ) {
                    if (event._id === undefined) {
                      event._id = labelIdx++;
                    }

                    if (multiDay) {
                      eventRows[row] = event;
                    }

                    event._days = [day];
                    width = multiDay ? Math.min(getDayDiff(day, getDateOnly(endTime)) + 1, 7 + firstWeekDay - weekDay - offset) * 100 : 100;
                    labels.push(multiDay ? '<div class="mbsc-cal-txt-w" style="width:' + width + '%">' + getLabelMarkup(event, i, true) + '</div>' + getLabelMarkup(event, i) : getLabelMarkup(event, i, true));
                    row++;
                    displayed++;
                  }

                i++;
              } else {
                labels.push('<div class="mbsc-cal-txt-ph"></div>');
                row++;
              }
            }

            dayLabels[day] = labels;
            day = s.getDate(s.getYear(day), s.getMonth(day), s.getDay(day) + 1);
          };

          while (day < end) {
            _loop();
          }
        })();
      }
    }

    function onBeforeMonthChange(d) {
      var y = s.getYear(d),
          m = s.getMonth(d);
      currFirstDay = d;
      activeDate = d;
      setTitle(d);
      trigger('onMonthChange', {
        year: y,
        month: m
      });
      trigger('onMonthLoading', {
        year: y,
        month: m
      });
      trigger('onPageChange', {
        firstDay: d
      });
      trigger('onPageLoading', {
        firstDay: d
      });
      onGenMonth(d);
    }

    function onAfterMonthChange(d) {
      var y = s.getYear(d),
          m = s.getMonth(d);

      if (needsRefresh === undefined) {
        onPageLoaded(d, y, m);
      } else {
        genAllMonths(d, needsRefresh, true);
      }

      focusDate(activeDate, dayScroll.focus);
      dayScroll.focus = false;
    }

    function onPageLoaded(d, y, m) {
      var $scroller = dayScroll.$scroller;
      $$1('.mbsc-cal-slide', $scroller).removeClass('mbsc-cal-slide-a');
      $$1('.mbsc-cal-slide', $scroller).slice(pageBuffer, pageBuffer + pageNr).addClass('mbsc-cal-slide-a');
      $$1('.mbsc-cal-slide-a .mbsc-cal-day', $scroller).on('mouseenter', function () {
        var $cell = $$1(this);

        if (!wasTouched && !isPageMove) {
          hoverTimer = setTimeout(function () {
            isCellHover = true;
            trigger('onCellHoverIn', getDayInfo($cell));
          }, 150);
        }
      }).on('mouseleave', function () {
        clearTimeout(hoverTimer);

        if (!wasTouched && isCellHover) {
          isCellHover = false;
          trigger('onCellHoverOut', getDayInfo($$1(this)));
        }
      });

      if (hasLabels) {
        $$1('.mbsc-cal-slide-a .mbsc-cal-txt', $scroller).on('mouseenter', function () {
          var id = $$1(this).attr('data-id');
          $$1('.mbsc-cal-txt[data-id="' + id + '"]', $scroller).addClass('mbsc-hover');
        }).on('mouseleave', function () {
          $$1('.mbsc-cal-txt.mbsc-hover', $scroller).removeClass('mbsc-hover');
        });
      }

      trigger('onMonthLoaded', {
        year: y,
        month: m
      });
      trigger('onPageLoaded', {
        firstDay: d
      });
    }

    function genTabMarkup() {
      var html, tabText;
      html = '<div class="mbsc-cal-tabs-c"><div class="mbsc-cal-tabs" role="tablist">';
      controlsArray.forEach(function (v, i) {
        tabText = s[(v == 'calendar' ? 'date' : v) + 'Text'];
        html += '<div role="tab" aria-controls="' + (elm.id + '-mbsc-pnl-' + i) + '" class="mbsc-cal-tab mbsc-fr-btn-e ' + (i ? '' : cssSelectedTab) + '" data-control="' + v + '"' + (s.tabLink ? '><a href="#">' + tabText + '</a>' : ' tabindex="0">' + tabText) + '</div>';
      });
      html += '</div></div>';
      return html;
    }

    function genCalMarkup() {
      var html,
          i,
          j,
          k,
          monthBtns,
          monthsMarkup,
          yearBtns = '',
          btnPrevClass = isRTL ? s.btnCalNextClass : s.btnCalPrevClass,
          btnNextClass = isRTL ? s.btnCalPrevClass : s.btnCalNextClass; // Generate month buttons

      monthBtns = '<div class="mbsc-cal-btn-w"><div data-step="-1" role="button" tabindex="0" aria-label="' + s.prevMonthText + '" class="' + btnPrevClass + ' mbsc-cal-prev mbsc-cal-prev-m mbsc-cal-btn mbsc-fr-btn mbsc-fr-btn-e"></div>';

      for (i = 0; i < (calRows ? pageNr : 1); i++) {
        monthBtns += '<div role="button" class="mbsc-cal-month"></div>';
      }

      monthBtns += '<div data-step="1" role="button" tabindex="0" aria-label="' + s.nextMonthText + '" class="' + btnNextClass + ' mbsc-cal-next mbsc-cal-next-m mbsc-cal-btn mbsc-fr-btn mbsc-fr-btn-e"></div></div>'; // Generate year buttons

      if (yearChange) {
        yearBtns = '<div class="mbsc-cal-btn-w"><div data-step="-12" role="button" tabindex="0" aria-label="' + s.prevYearText + '" class="' + btnPrevClass + ' mbsc-cal-prev mbsc-cal-prev-y mbsc-cal-btn mbsc-fr-btn mbsc-fr-btn-e"></div>' + '<div role="button" class="mbsc-cal-year"></div>' + '<div data-step="12" role="button" tabindex="0" aria-label="' + s.nextYearText + '" class="' + btnNextClass + ' mbsc-cal-next mbsc-cal-next-y mbsc-cal-btn mbsc-fr-btn mbsc-fr-btn-e"></div></div>';
      }

      if (calRows) {
        monthsMarkup = genAllMonths(currFirstDay);
      }

      html = '<div class="mbsc-w-p mbsc-cal-c"><div class="mbsc-cal ' + (isMonthView ? '' : ' mbsc-cal-week-view') + (pageNr > 1 ? ' mbsc-cal-multi ' : '') + (weekCounter ? ' mbsc-cal-weeks ' : '') + (isVertical ? ' mbsc-cal-vertical' : '') + (hasMarks ? ' mbsc-cal-has-marks' : '') + (hasLabels ? ' mbsc-cal-has-labels' : '') + ( // (hasText ? ' mbsc-cal-has-txt' : '') +
      showOuterDays ? '' : ' mbsc-cal-hide-diff ') + (s.calendarClass || '') + '"' + (!isLiquid ? ' style="width:' + (calWidth || 280 * pageNr) + 'px;"' : '') + '>' + '<div class="mbsc-cal-hdr">' + (yearIndex < monthIndex || pageNr > 1 ? yearBtns + monthBtns : monthBtns + yearBtns) + '</div>';

      if (calRows) {
        html += '<div class="mbsc-cal-body"><div class="mbsc-cal-day-picker"><div class="mbsc-cal-days-c">';

        for (j = 0; j < pageNr; j++) {
          // Generate week days
          html += '<div class="mbsc-cal-days">';

          for (i = 0; i < 7; i++) {
            k = (i + firstWeekDay) % 7;
            html += '<div class="mbsc-cal-week-day' + k + '" aria-label="' + s.dayNames[k] + '">' + s['dayNames' + weekDays][k] + '</div>';
          }

          html += '</div>';
        }

        html += '</div>' + '<div class="mbsc-cal-scroll-c mbsc-cal-day-scroll-c ' + (s.calendarClass || '') + '"' + (s.calendarHeight ? ' style="height:' + s.calendarHeight + 'px"' : '') + '>' + '<div class="mbsc-cal-scroll" style="width:' + 100 / pageNr + '%' + '">' + monthsMarkup + '</div></div>';
      }

      html += '</div>';

      if (hasQuickNav) {
        // Generate month picker
        html += '<div class="mbsc-cal-month-picker mbsc-cal-picker mbsc-cal-h"><div class="mbsc-cal-scroll-c ' + (s.calendarClass || '') + '">' + '<div class="mbsc-cal-scroll">';

        for (i = 0; i < 3; i++) {
          html += '<div class="mbsc-cal-slide"' + getOffsetStyle(i - 1) + '><div role="grid" class="mbsc-cal-table"><div role="row" class="mbsc-cal-row">';

          for (j = 0; j < 12; j++) {
            if (j && j % 3 === 0) {
              html += '</div><div role="row" class="mbsc-cal-row">';
            }

            html += '<div role="gridcell"' + (i == 1 ? ' tabindex="-1" aria-label="' + s.monthNames[j] + '" data-val="' + j + '"' : '') + ' class="mbsc-cal-cell' + (i == 1 ? ' mbsc-btn-e' : '') + '"><div class="mbsc-cal-cell-i mbsc-cal-cell-txt">' + (i == 1 ? s.monthNamesShort[j] : '&nbsp;') + '</div></div>';
          }

          html += '</div></div></div>';
        }

        html += '</div></div></div>'; // Generate year picker

        html += '<div class="mbsc-cal-year-picker mbsc-cal-picker mbsc-cal-h"><div class="mbsc-cal-scroll-c ' + (s.calendarClass || '') + '">' + '<div class="mbsc-cal-scroll">';

        for (i = -1; i < 2; i++) {
          html += genYears(getPageYear(currFirstDay, i), i);
        }

        html += '</div></div></div>';
      } // Closing


      html += '</div></div></div>';
      return html;
    }

    function genYears(d, off) {
      var i,
          year = s.getYear(d),
          html = '<div class="mbsc-cal-slide"' + getOffsetStyle(off) + '><div role="grid" class="mbsc-cal-table"><div role="row" class="mbsc-cal-row">';

      for (i = 0; i < 12; i++) {
        if (i && i % 3 === 0) {
          html += '</div><div role="row" class="mbsc-cal-row">';
        }

        html += '<div role="gridcell" tabindex="-1" aria-label="' + year + '" data-val="' + year + '"' + ' class="mbsc-cal-cell mbsc-btn-e ' + (year < minYear || year > maxYear ? ' mbsc-disabled ' : '') + (year == s.getYear(currFirstDay) ? cssSelected : '') + '"><div class="mbsc-cal-cell-i mbsc-cal-cell-txt">' + year + yearSuffix + '</div></div>';
        year++;
      }

      html += '</div></div></div>';
      return html;
    }

    function genMonth(firstDay, off) {
      var bg,
          curr,
          cssClass,
          y,
          m,
          d,
          displayMonth,
          displayDate,
          fullDate,
          props,
          isValid,
          isSelected,
          isToday,
          isOuterDay,
          maxDays,
          i,
          j,
          k = 1,
          year = s.getYear(firstDay),
          month = s.getMonth(firstDay),
          day = s.getDay(firstDay),
          selected = s.defaultValue === null && !inst._hasValue ? null : inst.getDate(true),
          weekDay = s.getDate(year, month, day).getDay(),
          // Get the weekday of the month
      offset = firstWeekDay - weekDay > 0 ? 7 : 0,
          html = '<div class="mbsc-cal-slide"' + getOffsetStyle(off) + '><div role="grid" class="mbsc-cal-table"><div role="row" class="mbsc-cal-row">';

      for (j = 0; j < 7 * calRows; j++) {
        i = j + firstWeekDay - offset;
        curr = s.getDate(year, month, i - weekDay + day);
        y = curr.getFullYear();
        m = curr.getMonth();
        d = curr.getDate();
        displayMonth = s.getMonth(curr);
        displayDate = s.getDay(curr);
        maxDays = s.getMaxDayOfMonth(y, m);
        fullDate = y + '-' + (m + 1) + '-' + d;
        props = extend$1({
          valid: isValidDate(curr),
          selected: selected && isSameDay(selected, curr)
        }, getDayProps(curr));
        bg = props.background === 'none' ? false : props.background;
        isValid = props.valid;
        isSelected = props.selected;
        cssClass = props.cssClass; // Compare dates at noon, in some timezones 0:00 doesn't exists on daylight saving day

        isToday = new Date(curr).setHours(12, 0, 0, 0) === new Date().setHours(12, 0, 0, 0);
        isOuterDay = displayMonth !== month; // Day is from another month

        dayProps[fullDate] = props;

        if (j && j % 7 === 0) {
          html += '</div><div role="row" class="mbsc-cal-row">';
        }

        if (weekCounter && j % 7 === 0) {
          // If displaying days from next month, reset month counter
          if (weekCounter == 'month' && isOuterDay && k > 1) {
            k = d == 1 ? 1 : 2;
          } else if (weekCounter == 'year') {
            k = s.getWeekNumber(s.getDate(y, m, d + (7 - firstWeekDay + 1) % 7));
          }

          html += '<div role="gridcell" class="mbsc-cal-cell mbsc-cal-week-nr">' + k + '</div>';
          k++;
        }

        html += '<div role="gridcell"' + // Aria attributes
        ' aria-label="' + (isToday ? s.todayText + ', ' : '') + s.dayNames[curr.getDay()] + ', ' + s.monthNames[displayMonth] + ' ' + displayDate + ' ' + (props.ariaLabel ? ', ' + props.ariaLabel : '') + '"' + (isOuterDay && !showOuterDays ? ' aria-hidden="true"' : ' data-full="' + fullDate + '"') + (isOuterDay || !isValid ? ' aria-disabled="true"' : '') + (isSelected ? ' aria-selected="true"' : '') + (isValid ? ' tabindex="-1"' : '') + // Classes
        ' class="mbsc-cal-cell mbsc-cal-day mbsc-cal-day' + i % 7 + ' ' + (s.dayClass || '') + ' ' + (isSelected ? cssSelected : '') + (isToday ? ' ' + s.todayClass : '') + (cssClass ? ' ' + cssClass : '') + (displayDate == 1 ? ' mbsc-cal-day-first' : '') + (displayDate == maxDays ? ' mbsc-cal-day-last' : '') + (isOuterDay ? ' mbsc-cal-day-diff' : '') + (isValid ? ' mbsc-btn-e' : ' mbsc-disabled') + (props.marked ? ' mbsc-cal-day-marked' : '') + (bg ? ' mbsc-cal-day-colored' : '') + '"><div class="mbsc-cal-cell-i mbsc-cal-day-i"><div class="mbsc-cal-day-date mbsc-cal-cell-txt"' + (bg ? ' style="background:' + bg + ';color:' + getTextColor(bg) + '"' : '') + '>' + displayDate + '</div>' + inst._getText(mobiscroll, 0.06) + ( // Extra markup (extra div is needed in RTL mode for Chrome, otherwise labels and marks appear at the top of the cell)
        props.markup ? '<div class="mbsc-cal-day-markup">' + props.markup + '</div>' : '') + '</div></div>';
      }

      html += '</div></div></div>';
      return html;
    }

    function genAllMonths(firstDay, render, insert) {
      var i,
          y = s.getYear(firstDay),
          m = s.getMonth(firstDay),
          pos = dayScroll ? dayScroll.pos : 0,
          html = '';
      dayProps = {};

      if (calRows) {
        if (!render) {
          trigger('onMonthLoading', {
            year: y,
            month: m
          });
          trigger('onPageLoading', {
            firstDay: firstDay
          });
        }

        onGenMonth(firstDay);

        for (i = 0; i < pageTotal; i++) {
          html += genMonth(getPageDay(firstDay, i - pageOffset - pageBuffer), pos * rtl + i - pageBuffer);
        }
      } //activateMonth(); // TODO: ???


      needsRefresh = undefined;

      if (insert && dayScroll) {
        dayScroll.$active = null;
        dayScroll.$scroller.html(html);
        onPageLoaded(firstDay, y, m);
      }

      return html;
    }

    function focusDate(d, focus) {
      if (dayScroll) {
        var $active = dayScroll.$active;

        if ($active && $active.length) {
          $active[0].blur();

          if ($active.hasClass('mbsc-disabled')) {
            $active.removeAttr('tabindex');
          } else {
            $active.attr('tabindex', '-1');
          }
        }

        dayScroll.$active = $$1('.mbsc-cal-slide-a .mbsc-cal-day[data-full="' + getDateStr(d) + '"]', dayScroll.$scroller).attr('tabindex', '0');

        if (focus && dayScroll.$active.length) {
          dayScroll.$active[0].focus();
        }
      }
    }

    function highlightDate(d) {
      var $ctx = dayScroll && dayScroll.$scroller;

      if (s.highlight && dayScroll) {
        $$1('.mbsc-selected', $ctx).removeClass(cssSelected).removeAttr('aria-selected');

        if (s.defaultValue !== null || inst._hasValue) {
          $$1('.mbsc-cal-day[data-full="' + getDateStr(d) + '"]', $ctx).addClass(cssSelected).attr('aria-selected', 'true');
        }
      }
    }

    function highlightSelected(v, $ctx) {
      $$1('.mbsc-selected', $ctx).removeClass(cssSelected).removeAttr('aria-selected');
      $$1('.mbsc-cal-cell[data-val="' + v + '"]', $ctx).addClass(cssSelected).attr('aria-selected', 'true');
    }

    function setDate(d, nav, anim, focus) {
      var diff, newFirstDay;

      if (!visibleTab) {
        return;
      }

      if (d < minDate) {
        d = minDate;
      }

      if (d > maxDate) {
        d = maxDate;
      }

      if (visibleTab === 'calendar' || !hasTabs || nav) {
        inst._isSetDate = !nav;

        if (hasCal && calRows) {
          newFirstDay = getFirstDay(constrain(d), isMonthView);

          if (needsSlide && (d < getPageDay(currFirstDay, -pageOffset) || d >= getPageDay(currFirstDay, pageNr - pageOffset))) {
            diff = isMonthView ? s.getMonth(newFirstDay) - s.getMonth(currFirstDay) + (s.getYear(newFirstDay) - s.getYear(currFirstDay)) * 12 : Math.floor(getDayDiff(currFirstDay, newFirstDay) / (7 * calRows));

            if (diff) {
              // Clear queue to navigate immediately
              dayScroll.queue = [];
              dayScroll.focus = focus && anim;
              changePageQueue(dayScroll, diff, anim);
            }
          }

          if (!diff || !anim) {
            focusDate(d, focus);
          }

          if (!nav) {
            highlightDate(d);
          }

          if (!isMonthView && !diff) {
            setTitle(currFirstDay, true);
          }

          activeDate = d;
          needsSlide = true;
        }

        inst._onSetDate(d, diff);

        inst._isSetDate = false;
      }
    }

    function setTitle(d, skipButtons) {
      var i,
          year,
          month,
          dd,
          y = s.getYear(d),
          m = s.getMonth(d),
          yy = y + yearSuffix;

      if (hasQuickNav) {
        // Highlight month
        highlightSelected(m, monthScroll.$scroller); // Highlight year

        highlightSelected(y, yearScroll.$scroller); // Scroll to selected year

        changePageQueue(yearScroll, Math.floor(y / 12) - Math.floor(s.getYear(yearScroll.first) / 12), true); // Disable out of range months

        $$1('.mbsc-cal-cell', monthScroll.$scroller).removeClass('mbsc-disabled');

        if (y === minYear) {
          for (i = 0; i < minMonth; i++) {
            $$1('.mbsc-cal-cell[data-val="' + i + '"]', monthScroll.$scroller).addClass('mbsc-disabled');
          }
        }

        if (y === maxYear) {
          for (i = maxMonth + 1; i <= 12; i++) {
            $$1('.mbsc-cal-cell[data-val="' + i + '"]', monthScroll.$scroller).addClass('mbsc-disabled');
          }
        }
      }

      if (!skipButtons) {
        // Disable/enable prev/next buttons
        checkBtn($$1('.mbsc-cal-prev-m', $markup), getPageDay(d, -pageOffset) <= minDate);
        checkBtn($$1('.mbsc-cal-next-m', $markup), getPageDay(d, pageNr - pageOffset) > maxDate);
        checkBtn($$1('.mbsc-cal-prev-y', $markup), s.getDate(y - 1, m + 1, 1) <= minDate);
        checkBtn($$1('.mbsc-cal-next-y', $markup), s.getDate(y + 1, m, 1) > maxDate);
      } // Update year in header


      $yearHdr.attr('aria-label', y).html(yy); // Update month in header

      for (i = 0; i < pageNr; i++) {
        dd = getPageDay(d, i - pageOffset);

        if (selectedDate >= dd && selectedDate < getPageDay(dd, 1)) {
          dd = selectedDate;
        }

        year = s.getYear(dd);
        month = s.getMonth(dd);
        yy = year + yearSuffix;
        $monthHdr.eq(i).attr('aria-label', s.monthNames[month] + (yearChange ? '' : ' ' + y)).html((!yearChange && yearIndex < monthIndex ? yy + ' ' : '') + monthNames[month] + (!yearChange && yearIndex > monthIndex ? ' ' + yy : ''));
      }
    }

    function checkBtn($btn, disable) {
      if (disable) {
        $btn.addClass(cssDisabled).attr('aria-disabled', 'true');
      } else {
        $btn.removeClass(cssDisabled).removeAttr('aria-disabled');
      }
    }

    function getDayInfo($day) {
      var day = $day[0],
          full = $day.attr('data-full'),
          parts = full ? full.split('-') : [],
          d = adjustedDate(parts[0], parts[1] - 1, parts[2]),
          selected = $day.hasClass('mbsc-selected');
      return extend$1(dayProps ? dayProps[full] : {}, {
        date: d,
        target: day,
        selected: selected
      });
    }

    function selectDay($day, ev) {
      var curr = inst.getDate(true),
          props = getDayInfo($day),
          day = $day[0],
          d = props.date,
          dtime = adjustedDate(d.getFullYear(), d.getMonth(), d.getDate(), curr.getHours(), curr.getMinutes(), curr.getSeconds()),
          $target = $$1(ev.target),
          target = $target[0];

      if (!dayProps || !showOuterDays && $day.hasClass('mbsc-cal-day-diff')) {
        return;
      }

      props.date = dtime; // Check if a label was tapped

      if (hasLabels && day.contains(target)) {
        while (target != day) {
          if ($target.hasClass('mbsc-cal-txt') || $target.hasClass('mbsc-cal-txt-more')) {
            var index = $target.attr('data-index');
            var labels = labelsObj[d];

            if (trigger('onLabelTap', {
              date: dtime,
              domEvent: ev,
              target: $target[0],
              labels: labels,
              label: labels[index]
            }) === false) {
              return;
            }

            break;
          }

          $target = $target.parent();
          target = $target[0];
        }
      }

      if (trigger('onDayChange', props) !== false && !s.readonly && !$day.hasClass('mbsc-disabled')) {
        inst._selectDay($day, d, dtime, props.selected);
      }
    }

    function selectMonth($month) {
      hideCont($monthPicker);
      setDate(s.getDate(s.getYear(dayScroll.first), $month.attr('data-val'), 1), true, true);
    }

    function selectYear($year) {
      hideCont($yearPicker);
      setDate(s.getDate($year.attr('data-val'), s.getMonth(dayScroll.first), 1), true, true);
    }

    function getFirstDay(d, isMonth, w) {
      var y = s.getYear(d),
          m = s.getMonth(d),
          weekDay = d.getDay(),
          offset = firstWeekDay - weekDay > 0 ? 7 : 0;
      return isMonth ? s.getDate(y, m, 1) : s.getDate(y, m, (w === undefined ? firstWeekDay : w) - offset - weekDay + s.getDay(d));
    }

    function getPageDay(d, diff) {
      var year = s.getYear(d),
          month = s.getMonth(d),
          day = s.getDay(d);
      return isMonthView ? s.getDate(year, month + diff, 1) : s.getDate(year, month, day + diff * calRows * 7);
    }

    function getPageYear(d, diff) {
      var year = Math.floor(s.getYear(d) / 12) * 12;
      return s.getDate(year + diff * 12, 0, 1);
    }

    function changePageQueue(props, diff, anim, callback) {
      if (!diff || !inst._isVisible) {
        return;
      }

      props.queue.push(arguments);

      if (props.queue.length == 1) {
        changePage(props, diff, anim, callback);
      }
    }

    function changePage(props, diff, anim, callback) {
      var i,
          inc,
          html = '',
          $scroller = props.$scroller,
          pageBuffer = props.buffer,
          pageOffset = props.offset,
          pageNr = props.pages,
          pageTotal = props.total,
          firstDay = props.first,
          genPage = props.genPage,
          getFirst = props.getFirst,
          move = diff > 0 ? Math.min(diff, pageBuffer) : Math.max(diff, -pageBuffer),
          pos = props.pos * rtl + move - diff + pageOffset,
          load = Math.abs(diff) > pageBuffer; // Call any pending callback

      if (props.callback) {
        props.load();
        props.callback(true);
      }

      props.first = getFirst(firstDay, diff);
      props.pos += move * rtl;
      props.changing = true;

      props.load = function () {
        if (load) {
          for (i = 0; i < pageNr; i++) {
            inc = diff + i - pageOffset; // ???

            html += genPage(getFirst(firstDay, inc), pos + inc);
          }

          if (diff > 0) {
            $$1('.mbsc-cal-slide', $scroller).slice(-pageNr).remove();
            $scroller.append(html);
          } else if (diff < 0) {
            $$1('.mbsc-cal-slide', $scroller).slice(0, pageNr).remove();
            $scroller.prepend(html);
          }
        }
      };

      props.callback = function (forceStop) {
        var nr = Math.abs(move),
            html = '';

        if (!inst._isVisible) {
          return;
        }

        for (i = 0; i < nr; i++) {
          inc = diff + i - pageOffset - pageBuffer + (diff > 0 ? pageTotal - nr : 0); // ???

          html += genPage(getFirst(firstDay, inc), pos + inc);
        }

        if (diff > 0) {
          $scroller.append(html);
          $$1('.mbsc-cal-slide', $scroller).slice(0, move).remove();
        } else if (diff < 0) {
          $scroller.prepend(html);
          $$1('.mbsc-cal-slide', $scroller).slice(move).remove();
        }

        if (load) {
          html = '';

          for (i = 0; i < nr; i++) {
            inc = diff + i - pageOffset - pageBuffer + (diff > 0 ? 0 : pageTotal - nr); // ???

            html += genPage(getFirst(firstDay, inc), pos + inc);
          }

          if (diff > 0) {
            $$1('.mbsc-cal-slide', $scroller).slice(0, move).remove();
            $scroller.prepend(html);
          } else if (diff < 0) {
            $$1('.mbsc-cal-slide', $scroller).slice(move).remove();
            $scroller.append(html);
          }
        }

        refreshScroller(props);

        if (callback && !forceStop) {
          callback();
        }

        props.callback = null;
        props.load = null;
        props.queue.shift();
        load = false;

        if (props.queue.length) {
          changePage.apply(this, props.queue[0]);
        } else {
          props.changing = false;
          props.onAfterChange(props.first);
        }
      };

      props.onBeforeChange(props.first);

      if (props.load) {
        props.load();
        props.scroller.scroll(-props.pos * props.size, anim ? 200 : 0, false, props.callback);
      }
    }

    function createScroller(cont, min, max, buffer, offset, pages, total, first, onTap, onBeforeChange, onAfterChange, genPage, getFirst) {
      var axis = isVertical ? 'Y' : 'X',
          props = {
        $scroller: $$1('.mbsc-cal-scroll', cont),
        queue: [],
        buffer: buffer,
        offset: offset,
        pages: pages,
        first: first,
        total: total,
        pos: 0,
        min: min,
        max: max,
        genPage: genPage,
        getFirst: getFirst,
        onBeforeChange: onBeforeChange,
        onAfterChange: onAfterChange
      };
      props.scroller = new ScrollViewBase(cont, {
        axis: axis,
        easing: '',
        contSize: 0,
        maxSnapScroll: buffer,
        mousewheel: s.mousewheel === undefined ? isVertical : s.mousewheel,
        time: 200,
        lock: true,
        rtl: isRTL,
        stopProp: false,
        minScroll: 0,
        maxScroll: 0,
        onBtnTap: function onBtnTap(ev) {
          if (ev.domEvent.type == 'touchend') {
            preventClick();
          }

          onTap($$1(ev.target), ev.domEvent);
        },
        onStart: function onStart() {
          clearTimeout(hoverTimer);
        },
        onGestureStart: function onGestureStart() {
          isPageMove = true;
        },
        onAnimationStart: function onAnimationStart() {
          props.changing = true;
        },
        onAnimationEnd: function onAnimationEnd(ev) {
          isPageMove = false;

          if (genPage) {
            changePageQueue(props, Math.round((-props.pos * props.size - ev['pos' + axis]) / props.size) * rtl);
          }
        }
      });

      inst._scrollers.push(props.scroller);

      return props;
    }

    function refreshScroller(props, check) {
      var size,
          plus = 0,
          minus = 0,
          firstDay = props.first;

      if (props.changing && check) {
        return;
      }

      if (props.getFirst) {
        plus = props.buffer;
        minus = props.buffer; //while (minus && s.getDate(y, m + minus + monthNr - moveMonth - 1, 1) > maxDate) { ???

        while (minus && props.getFirst(firstDay, minus + props.pages - props.offset - 1) > props.max) {
          minus--;
        } //while (plus && s.getDate(y, m - plus - moveMonth, 1) < minDate) { ???


        while (plus && props.getFirst(firstDay, 1 - plus - props.offset) <= props.min) {
          plus--;
        }
      }

      size = Math.round(calSize / props.pages); // Page size might be a fractional value in case of multiple months
      // so we need to explicitly set the rounded value

      if (isLiquid && size && props.size != size) {
        props.$scroller[isVertical ? 'height' : 'width'](size);
      }

      extend$1(props.scroller.settings, {
        snap: size,
        minScroll: (-props.pos * rtl - minus) * size,
        maxScroll: (-props.pos * rtl + plus) * size
      });
      props.size = size;
      props.scroller.refresh();
    }

    function refresh(render) {
      inst._onRefresh(render);

      if (inst._isVisible && hasCal && calRows) {
        if (dayScroll && dayScroll.changing) {
          needsRefresh = render;
        } else {
          genAllMonths(currFirstDay, render, true);
          focusDate(activeDate);
        }
      }
    }

    function onTouchStart(ev) {
      wasTouched = ev.type === 'touchstart';
    }

    function attachEvents() {
      if (hasCal && calRows) {
        var $scrollers = $$1('.mbsc-cal-scroll-c', $markup); // Day selector

        dayScroll = createScroller($scrollers[0], minDate, maxDate, pageBuffer, pageOffset, pageNr, pageTotal, currFirstDay, selectDay, onBeforeMonthChange, onAfterMonthChange, genMonth, getPageDay);

        if (hasQuickNav) {
          // Month selector
          monthScroll = createScroller($scrollers[1], null, null, 1, 0, 1, 3, currFirstDay, selectMonth); // Year selector

          yearScroll = createScroller($scrollers[2], minFirstYear, maxFirstYear, 1, 0, 1, 3, currFirstDay, selectYear, noop, noop, genYears, getPageYear); // Show / hide month picker

          inst.tap($monthHdr, function () {
            toggleCont($monthPicker);
            hideCont($yearPicker);
          }); // Show / hide year picker

          inst.tap($yearHdr, function () {
            toggleCont($yearPicker);
            hideCont($monthPicker);
          });
        } // Init navigation arrows


        createStepper($$1('.mbsc-cal-btn', $markup), function (i, diff, ev, next) {
          changePageQueue(dayScroll, diff, true, next);
        }); // Triggers onMonthLoaded on initial render

        onAfterMonthChange(currFirstDay); // Focus on the selected date on show

        if ((s.defaultValue !== null || inst._hasValue) && !inst._multiple) {
          inst._activeElm = dayScroll.$active[0];
        }

        listen($calendar[0], 'touchstart', onTouchStart, {
          passive: true
        });
        listen($calendar[0], 'mousedown', onTouchStart);
        $calendar // Keyboard navigation
        .on('keydown', function (ev) {
          var year = s.getYear(activeDate),
              month = s.getMonth(activeDate),
              day = s.getDay(activeDate),
              newDate;

          switch (ev.keyCode) {
            case 32:
              //SPACE
              selectDay(dayScroll.$active, ev);
              break;

            case 37:
              //LEFT_ARROW:
              newDate = s.getDate(year, month, day - 1 * rtl);
              break;

            case 39:
              //RIGHT_ARROW:
              newDate = s.getDate(year, month, day + 1 * rtl);
              break;

            case 38:
              //UP_ARROW:
              newDate = s.getDate(year, month, day - 7);
              break;

            case 40:
              //DOWN_ARROW:
              newDate = s.getDate(year, month, day + 7);
              break;

            case 36:
              //HOME:
              newDate = s.getDate(year, month, 1);
              break;

            case 35:
              //END:
              newDate = s.getDate(year, month + 1, 0);
              break;

            case 33:
              //PAGE_UP:
              newDate = ev.altKey ? s.getDate(year - 1, month, day) : isMonthView ? s.getDate(year, month - 1, day) : s.getDate(year, month, day - calRows * 7);
              break;

            case 34:
              //PAGE_DOWN:
              newDate = ev.altKey ? s.getDate(year + 1, month, day) : isMonthView ? s.getDate(year, month + 1, day) : s.getDate(year, month, day + calRows * 7);
              break;
          }

          if (newDate) {
            ev.preventDefault();
            setDate(newDate, true, false, true);
          }
        });
      } // Tabs


      inst.tap($$1('.mbsc-cal-tab', $markup), function () {
        inst.changeTab($$1(this).attr('data-control'));
      });
    }

    preProcessSettings();
    base = DateTime.call(this, inst);
    postProcessSettings(); // Public functions
    // ---

    inst.refresh = function () {
      refresh(false);
    };

    inst.redraw = function () {
      refresh(true);
    };

    inst.navigate = function (d, anim) {
      setDate(makeDate(d, displayFormat, s), true, anim);
    };

    inst.changeTab = function (tab) {
      if (!inst._isVisible || !controls[tab] || visibleTab == tab) {
        return;
      }

      visibleTab = tab;
      $$1('.mbsc-cal-tab', $markup).removeClass(cssSelectedTab).removeAttr('aria-selected');
      $$1('.mbsc-cal-tab[data-control="' + tab + '"]', $markup).addClass(cssSelectedTab).attr('aria-selected', 'true');

      if (hasTabs) {
        $tabPanes.addClass('mbsc-cal-h');
        controls[visibleTab].removeClass('mbsc-cal-h');
      }

      if (visibleTab == 'calendar') {
        // Set the date of the calendar if date changed from the scroller
        setDate(inst.getDate(true), false, true);
      } // Hide


      inst._showDayPicker();

      inst.trigger('onTabChange', {
        tab: visibleTab
      });
    }; // ---
    // Protected functions
    // ---


    inst._checkSize = true;
    inst._onGenMonth = noop;
    inst._onSetDate = noop;
    inst._onRefresh = noop;
    inst._getDayProps = noop;
    inst._prepareObj = prepareObj;

    inst._showDayPicker = function () {
      if (hasQuickNav) {
        hideCont($yearPicker);
        hideCont($monthPicker);
      }
    };

    inst._selectDay = inst.__selectDay = function ($day, d, dtime) {
      var fill = inst.live; // Prevents month slide in setDate

      needsSlide = s.outerMonthChange;
      isDayClick = true; // Set date on scroller

      inst.setDate(dtime, fill, 1000, !fill, true);

      if (fill) {
        trigger('onSet', {
          valueText: inst._value
        });
      }
    };

    inst._checkBtn = checkBtn; // ---

    return extend$1(base, {
      labels: null,
      // Overrides labels coming from language files
      compClass: 'mbsc-calendar mbsc-dt mbsc-sc',
      eventOrder: compareEvents,
      onMarkupReady: function onMarkupReady(ev) {
        var j = 0;
        $markup = $$1(ev.target);
        $tabPaneCont = $$1('.mbsc-fr-c', $markup);
        activeDate = inst.getDate(true);
        calSize = 0;

        if (hasCal) {
          hasMarks = !!(s.marked || s.data) && !s.labels && !s.multiLabel && !s.showEventCount; // hasText = s.showEventCount || !!(s.events || s.labels);

          needsSlide = true;
          visibleTab = 'calendar';
          calcMonthNr();
          currFirstDay = getFirstDay(constrain(activeDate), isMonthView);
          $tabPaneCont.append(genCalMarkup());
          $monthHdr = $$1('.mbsc-cal-month', $markup);
          $yearHdr = $$1('.mbsc-cal-year', $markup);
          $calendar = $$1('.mbsc-cal-day-scroll-c', $markup);
        }

        if (hasQuickNav) {
          $yearPicker = $$1('.mbsc-cal-year-picker', $markup);
          $monthPicker = $$1('.mbsc-cal-month-picker', $markup);
        }

        $tabPanes = $$1('.mbsc-w-p', $markup); // Insert tab markup

        if (controlsArray.length > 1) {
          $tabPaneCont.before(genTabMarkup());
        } // Find markup for controls


        ['date', 'time', 'calendar'].forEach(function (v) {
          if (controls[v]) {
            controls[v] = $tabPanes.eq(j);
            j++;
          } else if (v == 'date' && !controls.date && hasCal) {
            $tabPanes.eq(j).remove();
            j++;
          }
        }); // Insert controls in correct order

        controlsArray.forEach(function (v) {
          $tabPaneCont.append(controls[v]);
        }); // TODO: this is an ugly solution

        if (!hasCal && controls.date) {
          controls.date.css('position', 'relative');
        }

        inst._scrollers = [];
        attachEvents();
      },
      onShow: function onShow() {
        if (hasCal && calRows) {
          setTitle(currFirstDay);
        }
      },
      onHide: function onHide() {
        clearTimeout(hoverTimer);

        inst._scrollers.forEach(function (v) {
          v.destroy();
        });

        dayProps = null;
        dayScroll = null;
        monthScroll = null;
        yearScroll = null;
        visibleTab = null;
      },
      onValidated: function onValidated(ev) {
        var ctrl,
            d,
            i = ev.index,
            order = inst._order;
        d = inst.getDate(true);
        selectedDate = d; // Find out on which control was the selection made

        if (isDayClick) {
          ctrl = 'calendar';
        } else if (i !== undefined) {
          ctrl = order.dd == i || order.d == i || order.m == i || order.y == i ? 'date' : 'time';
        }

        trigger('onSetDate', {
          date: d,
          control: ctrl
        }); // Set date on calendar

        if (ctrl !== 'time') {
          setDate(d, false, !!ev.time, isDayClick && !inst._multiple);
        }

        isDayClick = false;
      },
      onPosition: function onPosition(ev) {
        var i,
            y,
            m,
            doRefresh,
            modalHeight,
            newCalSize,
            availableHeight,
            oldHeight = ev.oldHeight,
            windowHeight = ev.windowHeight;
        hasTabs = (ev.hasTabs || s.tabs === true || s.tabs !== false && isLiquid) && controlsArray.length > 1;

        if (isLiquid) {
          if (ev.windowWidth >= s.breakPointMd) {
            $$1(ev.target).addClass('mbsc-fr-md');
          } else {
            $$1(ev.target).removeClass('mbsc-fr-md');
          }
        } // Show/hide tabs


        if (hasTabs) {
          $markup.addClass('mbsc-cal-tabbed');
          visibleTab = $$1('.mbsc-cal-tab.mbsc-selected', $markup).attr('data-control');
          $tabPanes.addClass('mbsc-cal-h');
          controls[visibleTab].removeClass('mbsc-cal-h');
        } else {
          // visibleTab = 'calendar';
          $markup.removeClass('mbsc-cal-tabbed');
          $tabPanes.removeClass('mbsc-cal-h');
        } // Full screen mode


        if (inst._isFullScreen) {
          // Reset height
          $calendar.height('');
          modalHeight = ev.popup.offsetHeight; // Get available height

          availableHeight = windowHeight - modalHeight + $calendar[0].offsetHeight; // Only set fixed height if calendar height is bigger than viewport height

          if (windowHeight >= modalHeight) {
            $calendar.height(availableHeight);
          }
        }

        if (hasLabels && calRows && windowHeight != oldHeight) {
          // Check how many labels can we display on a day
          var calHeight = availableHeight || $calendar[0].offsetHeight;
          var ph = $calendar.find('.mbsc-cal-txt,.mbsc-cal-txt-ph')[0];
          var numberHeight = ph.offsetTop;
          var txtHeight = ph.offsetHeight;
          var newMaxLabels = Math.max(1, Math.floor((calHeight / calRows - numberHeight) / (txtHeight + 2))); // Redraw the calendar, if max labels changed

          if (maxLabels != newMaxLabels) {
            maxLabels = newMaxLabels;
            inst.redraw();
          }
        } // Refresh scrollviews


        if (hasCal && calRows) {
          // Need to calculate size
          if (isLiquid || isVertical || hasTabs) {
            newCalSize = $calendar[0][isVertical ? 'offsetHeight' : 'offsetWidth'];
          } else {
            newCalSize = calWidth || pageNr * 280;
          }

          doRefresh = newCalSize != calSize;
          calSize = newCalSize; // Use long or short month names

          if (isLiquid && doRefresh) {
            if (yearChange) {
              monthNames = s.maxMonthWidth > $monthHdr[0].offsetWidth ? s.monthNamesShort : s.monthNames;
              y = s.getYear(currFirstDay);
              m = s.getMonth(currFirstDay);

              for (i = 0; i < pageNr; i++) {
                $monthHdr.eq(i).text(monthNames[s.getMonth(s.getDate(y, m - pageOffset + i, 1))]);
              }
            }
          }

          if (doRefresh) {
            refreshScroller(dayScroll, true);
          }
        }

        if (hasQuickNav && doRefresh) {
          refreshScroller(monthScroll, true);
          refreshScroller(yearScroll, true);
        }
      }
    });
  };

  var Calendar = Scroller;
  var defaults$3 = {};

  presets.calendar = function (inst) {
    function getDateOnly(d) {
      return adjustedDate(d.getFullYear(), d.getMonth(), d.getDate());
    }

    function setValues(values) {
      var d,
          i,
          first = null;
      selectedValues = {};

      if (values && values.length) {
        for (i = 0; i < values.length; i++) {
          d = makeDate(values[i], displayFormat, s, s.isoParts);
          first = first || d;
          selectedValues[getDateOnly(d)] = d;
        }
      }

      return first;
    }

    function redraw() {
      inst.redraw();
    } // ---


    var base,
        ctx,
        displayFormat,
        firstSelectDay,
        origValues,
        orig = extend$1({}, inst.settings),
        s = extend$1(inst.settings, defaults$3, orig),
        cssSelected = 'mbsc-selected ' + (s.selectedClass || ''),
        defaultValue = s.defaultValue,
        multi = s.select == 'multiple' || s.select > 1 || s.selectType == 'week',
        maxSelect = isNumeric(s.select) ? s.select : Infinity,
        selectedValues = {};
    base = CalendarBase.call(this, inst);
    firstSelectDay = s.firstSelectDay === undefined ? s.firstDay : s.firstSelectDay;
    displayFormat = inst._format;

    if (multi) {
      setValues(defaultValue);
    } // Extended methods
    // ---


    inst._multiple = multi;

    inst._getDayProps = function (d) {
      return {
        selected: multi ? selectedValues[d] !== undefined : undefined
      };
    };

    inst._selectDay = function ($day, d, dtime, selected) {
      var isSingleSelect = s.select == 'single' || s.select == 1 || s.select === undefined; // Single select with instant close

      if (s.setOnDayTap && isSingleSelect && s.display != 'inline') {
        inst.setDate(dtime);
        inst.select();
        return;
      }

      if (multi) {
        // Multiple day selection
        if (s.selectType == 'week') {
          // Select whole week
          var i,
              sel,
              diff = d.getDay() - firstSelectDay;
          diff = diff < 0 ? 7 + diff : diff;

          if (isSingleSelect) {
            // Only one week can be selected
            selectedValues = {};
          }

          for (i = 0; i < 7; i++) {
            sel = adjustedDate(d.getFullYear(), d.getMonth(), d.getDate() - diff + i);

            if (selected) {
              delete selectedValues[sel];
            } else if (objectToArray(selectedValues).length / 7 < maxSelect) {
              selectedValues[sel] = sel;
            }
          }

          redraw();
        } else {
          // Select day only
          var days = $$1('.mbsc-cal-day[data-full="' + $day.attr('data-full') + '"]', ctx);

          if (selected) {
            days.removeClass(cssSelected).removeAttr('aria-selected');
            delete selectedValues[d];
          } else if (objectToArray(selectedValues).length < maxSelect) {
            days.addClass(cssSelected).attr('aria-selected', 'true');
            selectedValues[d] = d;
          }
        }
      } // Standard selection


      inst.__selectDay($day, d, dtime);
    };

    inst.setVal = function (val, fill, change, temp, time) {
      if (multi) {
        val = setValues(val);
      }

      inst._setVal(val, fill, change, temp, time);

      if (multi) {
        redraw();
      }
    };

    inst.getVal = function (temp) {
      var i,
          ret = [];

      if (multi) {
        for (i in selectedValues) {
          ret.push(returnDate(selectedValues[i], s, displayFormat));
        }

        return ret;
      }

      return returnDate(inst.getDate(temp), s, displayFormat);
    }; // ---


    return extend$1({}, base, {
      highlight: !multi,
      outerMonthChange: !multi,
      parseValue: function parseValue(v) {
        if (multi && v && typeof v === 'string') {
          v = setValues(v.split(','));
        }

        if (multi && defaultValue && defaultValue.length) {
          s.defaultValue = defaultValue[0];
        }

        return base.parseValue.call(this, v);
      },
      formatValue: function formatValue(d) {
        var i,
            ret = [];

        if (multi) {
          for (i in selectedValues) {
            ret.push(formatDate(displayFormat, selectedValues[i], s));
          }

          return ret.join(', ');
        }

        return base.formatValue.call(this, d, inst);
      },
      onClear: function onClear() {
        if (multi) {
          selectedValues = {};
          redraw();
        }
      },
      onBeforeShow: function onBeforeShow() {
        if (s.setOnDayTap === undefined && (!s.buttons || !s.buttons.length) && s.controls.length == 1) {
          s.setOnDayTap = true;
        }

        if (s.setOnDayTap && s.display != 'inline') {
          s.outerMonthChange = false;
        }

        if (s.counter && multi) {
          s.headerText = function () {
            var length = 0,
                w = s.selectType == 'week' ? 7 : 1;
            $$1.each(selectedValues, function () {
              length++;
            });
            length = Math.round(length / w);
            return (length > 1 ? s.selectedPluralText || s.selectedText : s.selectedText).replace(/{count}/, length);
          };
        }
      },
      onMarkupReady: function onMarkupReady(ev) {
        base.onMarkupReady.call(this, ev);
        ctx = $$1(ev.target);

        if (multi) {
          $$1('.mbsc-fr-hdr', ctx).attr('aria-live', 'off');
          origValues = extend$1({}, selectedValues);
        }
      },
      onCancel: function onCancel() {
        if (!inst.live && multi) {
          selectedValues = extend$1({}, origValues);
        }
      }
    });
  };

  var MbscDatetimeBase = (function (_super) {
      __extends(MbscDatetimeBase, _super);
      function MbscDatetimeBase(initialElem, zone, control, inputService, view) {
          return _super.call(this, initialElem, zone, control, inputService, view) || this;
      }
      MbscDatetimeBase.decorators = [
          { type: core.Directive, args: [{ selector: '[mbsc-dt-b' },] },
      ];
      MbscDatetimeBase.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, },
          { type: MbscInputService, },
          { type: core.ViewContainerRef, },
      ]; };
      MbscDatetimeBase.propDecorators = {
          'defaultValue': [{ type: core.Input },],
          'invalid': [{ type: core.Input },],
          'max': [{ type: core.Input },],
          'min': [{ type: core.Input },],
          'returnFormat': [{ type: core.Input },],
          'steps': [{ type: core.Input },],
          'valid': [{ type: core.Input },],
          'calendarSystem': [{ type: core.Input },],
          'ampmText': [{ type: core.Input },],
          'amText': [{ type: core.Input },],
          'dateFormat': [{ type: core.Input },],
          'dateWheels': [{ type: core.Input },],
          'dayNames': [{ type: core.Input },],
          'dayNamesShort': [{ type: core.Input },],
          'dayText': [{ type: core.Input },],
          'hourText': [{ type: core.Input },],
          'minuteText': [{ type: core.Input },],
          'monthNames': [{ type: core.Input },],
          'monthNamesShort': [{ type: core.Input },],
          'monthSuffix': [{ type: core.Input },],
          'monthText': [{ type: core.Input },],
          'nowText': [{ type: core.Input },],
          'pmText': [{ type: core.Input },],
          'secText': [{ type: core.Input },],
          'timeFormat': [{ type: core.Input },],
          'timeWheels': [{ type: core.Input },],
          'yearSuffix': [{ type: core.Input },],
          'yearText': [{ type: core.Input },],
      };
      return MbscDatetimeBase;
  }(MbscScrollerBase));
  var MbscDatetimeBaseModule = (function () {
      function MbscDatetimeBaseModule() {
      }
      MbscDatetimeBaseModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule, MbscScrollerBaseModule],
                      declarations: [MbscDatetimeBase],
                  },] },
      ];
      MbscDatetimeBaseModule.ctorParameters = function () { return []; };
      return MbscDatetimeBaseModule;
  }());

  var MbscCalBase = (function (_super) {
      __extends(MbscCalBase, _super);
      function MbscCalBase(initialElem, zone, control, inputService, view) {
          var _this = _super.call(this, initialElem, zone, control, inputService, view) || this;
          _this.onTabChange = new core.EventEmitter();
          _this.onLabelTap = new core.EventEmitter();
          _this.onMonthChange = new core.EventEmitter();
          _this.onMonthLoading = new core.EventEmitter();
          _this.onMonthLoaded = new core.EventEmitter();
          _this.onPageChange = new core.EventEmitter();
          _this.onPageLoaded = new core.EventEmitter();
          _this.onPageLoading = new core.EventEmitter();
          return _this;
      }
      MbscCalBase.prototype.ngOnInit = function () {
          this.cloneDictionary.colors = [];
          this.cloneDictionary.labels = [];
          this.cloneDictionary.marked = [];
          _super.prototype.ngOnInit.call(this);
      };
      MbscCalBase.decorators = [
          { type: core.Directive, args: [{ selector: '[mbsc-cal-b' },] },
      ];
      MbscCalBase.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, },
          { type: MbscInputService, },
          { type: core.ViewContainerRef, },
      ]; };
      MbscCalBase.propDecorators = {
          'calendarHeight': [{ type: core.Input },],
          'calendarWidth': [{ type: core.Input },],
          'calendarScroll': [{ type: core.Input },],
          'colors': [{ type: core.Input },],
          'counter': [{ type: core.Input },],
          'defaultValue': [{ type: core.Input },],
          'events': [{ type: core.Input },],
          'eventOrder': [{ type: core.Input },],
          'labels': [{ type: core.Input },],
          'marked': [{ type: core.Input },],
          'months': [{ type: core.Input },],
          'mousewheel': [{ type: core.Input },],
          'outerMonthChange': [{ type: core.Input },],
          'showOuterDays': [{ type: core.Input },],
          'tabs': [{ type: core.Input },],
          'weekCounter': [{ type: core.Input },],
          'weekDays': [{ type: core.Input },],
          'weeks': [{ type: core.Input },],
          'yearChange': [{ type: core.Input },],
          'dateText': [{ type: core.Input },],
          'dayNamesMin': [{ type: core.Input },],
          'firstDay': [{ type: core.Input },],
          'timeText': [{ type: core.Input },],
          'moreEventsPluralText': [{ type: core.Input },],
          'moreEventsText': [{ type: core.Input },],
          'onTabChange': [{ type: core.Output },],
          'onLabelTap': [{ type: core.Output },],
          'onMonthChange': [{ type: core.Output },],
          'onMonthLoading': [{ type: core.Output },],
          'onMonthLoaded': [{ type: core.Output },],
          'onPageChange': [{ type: core.Output },],
          'onPageLoaded': [{ type: core.Output },],
          'onPageLoading': [{ type: core.Output },],
      };
      return MbscCalBase;
  }(MbscDatetimeBase));
  var MbscCalBaseModule = (function () {
      function MbscCalBaseModule() {
      }
      MbscCalBaseModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule, MbscDatetimeBaseModule],
                      declarations: [MbscCalBase],
                  },] },
      ];
      MbscCalBaseModule.ctorParameters = function () { return []; };
      return MbscCalBaseModule;
  }());

  var MbscCalendar = (function (_super) {
      __extends(MbscCalendar, _super);
      function MbscCalendar(initialElement, zone, control, inputService, optionService, view) {
          var _this = _super.call(this, initialElement, zone, control, inputService, view) || this;
          _this.optionService = optionService;
          _this.onSetDate = new core.EventEmitter();
          _this.onCellHoverIn = new core.EventEmitter();
          _this.onCellHoverOut = new core.EventEmitter();
          _this.onDayChange = new core.EventEmitter();
          _this.options = {};
          _this.isMulti = undefined;
          _this.onChangeEmitter = new core.EventEmitter();
          return _this;
      }
      Object.defineProperty(MbscCalendar.prototype, "value", {
          set: function (v) {
              if (!this.control) {
                  this.setNewValueProxy(v);
              }
          },
          enumerable: true,
          configurable: true
      });
      MbscCalendar.prototype.setNewValue = function (v) {
          if (this.instance) {
              var changed = void 0;
              if (this.isMulti) {
                  changed = !deepEqualsArray(v, this.instance.getVal());
              }
              else {
                  var innerValue = this.instance.getVal();
                  changed = ((!innerValue && v) ||
                      (innerValue && !v) ||
                      (innerValue && v && innerValue.toString() !== v.toString()));
              }
              if (changed) {
                  this.instance.setVal(v, true, false);
                  if (this._inputService && this._inputService.input) {
                      this._inputService.input.innerValue = this.instance._value;
                  }
              }
          }
      };
      MbscCalendar.prototype.initControl = function () {
          var options = extend$1({ preset: 'calendar' }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
          this.instance = new Calendar(this.element, options);
          if (this.initialValue !== undefined && this.initialValue !== "") {
              this.instance.setVal(this.initialValue, true, false);
          }
      };
      MbscCalendar.prototype.ngOnInit = function () {
          this.isMulti = this.options && ((this.options.select && this.options.select !== 'single') || (this.options.selectType == 'week'));
          this.cloneDictionary.marked = [];
          this.cloneDictionary.invalid = [];
          _super.prototype.ngOnInit.call(this);
      };
      MbscCalendar.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mbsc-calendar]',
                      exportAs: 'mobiscroll'
                  },] },
      ];
      MbscCalendar.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: core.ViewContainerRef, },
      ]; };
      MbscCalendar.propDecorators = {
          'controls': [{ type: core.Input },],
          'firstSelectDay': [{ type: core.Input },],
          'selectType': [{ type: core.Input },],
          'select': [{ type: core.Input },],
          'setOnDayTap': [{ type: core.Input },],
          'onSetDate': [{ type: core.Output },],
          'onCellHoverIn': [{ type: core.Output },],
          'onCellHoverOut': [{ type: core.Output },],
          'onDayChange': [{ type: core.Output },],
          'options': [{ type: core.Input, args: ['mbsc-options',] },],
          'value': [{ type: core.Input, args: ['mbsc-calendar',] },],
          'onChangeEmitter': [{ type: core.Output, args: ['mbsc-calendarChange',] },],
      };
      return MbscCalendar;
  }(MbscCalBase));
  var MbscCalendarComponent = (function (_super) {
      __extends(MbscCalendarComponent, _super);
      function MbscCalendarComponent(initialElem, zone, control, inputService, optionService) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
          _this.placeholder = '';
          _this.errorMessage = '';
          return _this;
      }
      MbscCalendarComponent.prototype.ngAfterViewInit = function () {
          _super.prototype.ngAfterViewInit.call(this);
          this.setThemeClasses();
      };
      MbscCalendarComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-calendar',
                      exportAs: 'mobiscroll',
                      template: INPUT_TEMPLATE
                  },] },
      ];
      MbscCalendarComponent.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscCalendarComponent.propDecorators = {
          'inputIcon': [{ type: core.Input, args: ['icon',] },],
          'iconAlign': [{ type: core.Input, args: ['icon-align',] },],
          'name': [{ type: core.Input },],
          'placeholder': [{ type: core.Input },],
          'error': [{ type: core.Input },],
          'errorMessage': [{ type: core.Input },],
          'options': [{ type: core.Input },],
      };
      return MbscCalendarComponent;
  }(MbscCalendar));
  var MbscCalendarModule = (function () {
      function MbscCalendarModule() {
      }
      MbscCalendarModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule, MbscCalBaseModule, MbscInputModule],
                      declarations: [MbscCalendar, MbscCalendarComponent],
                      exports: [MbscCalendar, MbscCalendarComponent]
                  },] },
      ];
      MbscCalendarModule.ctorParameters = function () { return []; };
      return MbscCalendarModule;
  }());

  var Button =
  /*#__PURE__*/
  function (_FormControl) {
    _inheritsLoose(Button, _FormControl);

    function Button(elm, settings) {
      var _this;

      _this = _FormControl.call(this, elm, settings) || this;
      var $elm = _this._$elm;
      var hasIcon = $elm.attr('data-icon');
      $elm.addClass('mbsc-btn mbsc-no-touch').find('.mbsc-btn-ic').remove();

      if (hasIcon) {
        $elm.prepend('<span class="mbsc-btn-ic mbsc-ic mbsc-ic-' + hasIcon + '"></span>');

        if ($elm.text() === "") {
          $elm.addClass('mbsc-btn-icon-only');
        }
      }

      _this._$rippleElm = $elm;
      return _this;
    }

    var _proto = Button.prototype;

    _proto.getClassElm = function getClassElm() {
      return this._$elm;
    };

    return Button;
  }(FormControl); // Init mbsc-button elements on page load

  autoInit('[mbsc-button]', Button);

  var CheckBox =
  /*#__PURE__*/
  function (_FormControl) {
    _inheritsLoose(CheckBox, _FormControl);

    function CheckBox(elm, settings) {
      var _this;

      _this = _FormControl.call(this, elm, settings) || this;

      _this._$parent.prepend(_this._$elm).addClass('mbsc-checkbox mbsc-control-w').find('.mbsc-checkbox-box').remove();

      _this._$elm.after('<span class="mbsc-checkbox-box"></span>');

      return _this;
    }

    return CheckBox;
  }(FormControl); // Init mbsc-checkbox elements on page load

  autoInit('[mbsc-checkbox]', CheckBox);

  var Radio =
  /*#__PURE__*/
  function (_FormControl) {
    _inheritsLoose(Radio, _FormControl);

    function Radio(elm, settings) {
      var _this;

      _this = _FormControl.call(this, elm, settings) || this;

      _this._$parent.addClass('mbsc-radio mbsc-control-w').find('.mbsc-radio-box').remove();

      _this._$elm.after('<span class="mbsc-radio-box"><span></span></span>');

      return _this;
    }

    return Radio;
  }(FormControl); // Init mbsc-radio elements on page load

  autoInit('[mbsc-radio]', Radio);

  var Select =
  /*#__PURE__*/
  function (_Input) {
    _inheritsLoose(Select, _Input);

    function Select(elm, settings) {
      var _this;

      _this = _Input.call(this, elm, settings) || this;
      var $elm = _this._$elm;
      var $parent = _this._$parent;
      var $existing = $parent.find('.mbsc-select-input');
      var $input = $existing.length ? $existing : $$1('<input tabindex="-1" class="mbsc-select-input mbsc-control" readonly>');
      _this._$input = $input;
      _this._delm = $input[0];
      _this._setText = _this._setText.bind(_assertThisInitialized(_this));
      $parent.addClass('mbsc-select' + (_this._$frame ? ' mbsc-select-inline' : ''));
      $elm.after($input);
      $input.after('<span class="mbsc-select-ic mbsc-ic mbsc-ic-arrow-down5"></span>'); // Update dummy input text on change

      $elm.on('change', _this._setText);

      _this._setText();

      return _this;
    }

    var _proto = Select.prototype;

    _proto.destroy = function destroy() {
      _Input.prototype.destroy.call(this);

      this._$parent.find('.mbsc-select-ic').remove();

      this._$elm.off('change', this._setText);
    };

    _proto._setText = function _setText() {
      var elm = this._elm;
      var $elm = $$1(elm); // Check if select and mobiscroll select was not initialized

      if ($elm.is('select') && !$elm.hasClass('mbsc-comp')) {
        this._$input.val(elm.selectedIndex != -1 ? elm.options[elm.selectedIndex].text : '');
      } // Check floating label


      this.refresh();
    };

    return Select;
  }(Input); // Init mbsc-select elements on page load

  autoInit('[mbsc-dropdown]', Select);

  var events$2 = ['change', 'keydown', 'input', 'scroll'];
  var sizeDebounce;

  function sizeTextAreas() {
    clearTimeout(sizeDebounce);
    sizeDebounce = setTimeout(function () {
      $$1('textarea.mbsc-control').each(function () {
        sizeTextArea(this);
      });
    }, 100);
  }

  function sizeTextArea(control) {
    var height,
        lineNr,
        line,
        rowNr = $$1(control).attr('rows') || 6;

    if (control.offsetHeight) {
      control.style.height = '';
      line = control.scrollHeight - control.offsetHeight;
      height = control.offsetHeight + (line > 0 ? line : 0);
      lineNr = Math.round(height / 24);

      if (lineNr > rowNr) {
        //control.scrollTop = height;
        height = 24 * rowNr + (height - lineNr * 24);
        $$1(control).addClass('mbsc-textarea-scroll');
      } else {
        $$1(control).removeClass('mbsc-textarea-scroll');
      }

      if (height) {
        control.style.height = height + 'px';
      }
    }
  }

  function scrollTextArea(elm) {
    var $elm = $$1(elm);

    if (!$elm.hasClass('mbsc-textarea-scroll')) {
      var line = elm.scrollHeight - elm.offsetHeight,
          height = elm.offsetHeight + line,
          lineNr = Math.round(height / 24),
          rowNr = $elm.attr('rows') || 6;

      if (lineNr <= rowNr) {
        elm.scrollTop = 0;
        elm.style.height = height + 'px';
      }
    }
  }

  if (isBrowser) {
    // Set height of textareas on viewport size changes
    $$1(window).on('resize orientationchange', sizeTextAreas);
  }

  var TextArea =
  /*#__PURE__*/
  function (_Input) {
    _inheritsLoose(TextArea, _Input);

    function TextArea(elm, settings) {
      var _this;

      _this = _Input.call(this, elm, settings) || this;

      _this._$parent.addClass('mbsc-textarea');

      events$2.forEach(function (ev) {
        _this._$elm.on(ev, _this._handle);
      });
      sizeTextArea(elm);
      return _this;
    }

    var _proto = TextArea.prototype;

    _proto.destroy = function destroy() {
      var _this2 = this;

      _Input.prototype.destroy.call(this);

      events$2.forEach(function (ev) {
        _this2._$elm.off(ev, _this2._handle);
      });
    };

    _proto.refresh = function refresh() {
      _Input.prototype.refresh.call(this);

      clearTimeout(this._debounce);
      sizeTextArea(this._elm);
    };

    _proto._handle = function _handle(ev) {
      _Input.prototype._handle.call(this, ev);

      switch (ev.type) {
        case 'change':
          sizeTextArea(this._elm);
          break;

        case 'keydown':
        case 'input':
          this._onInput(ev);

          break;

        case 'scroll':
          scrollTextArea(this._elm);
      }
    };

    _proto._onInput = function _onInput() {
      var _this3 = this;

      clearTimeout(this._debounce);
      this._debounce = setTimeout(function () {
        sizeTextArea(_this3._elm);
      }, 100);
    };

    return TextArea;
  }(Input);

  autoInit('[mbsc-textarea]', TextArea);

  var SegmentedItem =
  /*#__PURE__*/
  function (_FormControl) {
    _inheritsLoose(SegmentedItem, _FormControl);

    function SegmentedItem(elm, settings) {
      var _this;

      _this = _FormControl.call(this, elm, settings) || this;
      var $segmentCont;
      var $segment;
      var $elm = _this._$elm;
      var $parent = _this._$parent;

      if (!$parent.hasClass('mbsc-segmented-item-ready')) {
        $segmentCont = $$1('<div class="mbsc-segmented mbsc-segmented-group mbsc-no-touch"></div>');
        $parent.after($segmentCont);
        $parent.parent().find('input[name="' + $elm.attr('name') + '"]').each(function () {
          var $input = $$1(this);
          $segment = $input.parent().addClass('mbsc-segmented-item mbsc-segmented-item-ready');
          $$1('<span class="mbsc-segmented-content">' + ($input.attr('data-icon') ? '<span class="mbsc-ic mbsc-ic-' + $input.attr('data-icon') + '"></span>' : '') + '</span>').append($segment.contents()).appendTo($segment);
          $segment.prepend($input);
          $segmentCont.append($segment);
        });
      }

      _this._$rippleElm = $elm.next();
      return _this;
    }

    var _proto = SegmentedItem.prototype;

    _proto.getClassElm = function getClassElm() {
      return this._$elm.closest('.mbsc-segmented');
    };

    return SegmentedItem;
  }(FormControl); // Init mbsc-segmented elements on page load

  autoInit('[mbsc-segmented]', SegmentedItem);

  var Stepper = function Stepper(control, settings) {
    var $btnPlus,
        $btnMinus,
        $controls,
        cssClass = '',
        displayValue,
        max,
        min,
        inputStyle,
        ripple,
        scale,
        step,
        stepper,
        s,
        theme,
        val,
        that = this,
        $control = $$1(control),
        ready,
        $parent,
        old = val;

    function onChange() {
      var v;

      if (!control.disabled) {
        v = parseFloat($$1(this).val());
        setValue(isNaN(v) ? val : v);
      }
    }

    function checkDisabled() {
      return control.disabled;
    }

    function stepValue(index, dir) {
      setValue(val + dir * step);
    }

    function setValue(v, fill, change) {
      old = val;

      if (fill === undefined) {
        fill = true;
      }

      if (change === undefined) {
        change = fill;
      }

      val = round(v);
      $controls.removeClass('mbsc-disabled');

      if (fill) {
        $control.val(val);
      }

      if (val == min) {
        $btnMinus.addClass('mbsc-disabled');
      }

      if (val == max) {
        $btnPlus.addClass('mbsc-disabled');
      }

      if (val !== old && change) {
        $control.trigger('change');
      }
    }

    function getAttr(attr, def, str) {
      var v = $control.attr(attr);
      return v === undefined || v === '' ? def : str ? v : +v;
    }

    function round(v) {
      return +Math.min(max, Math.max(Math.round(v / step) * step, min)).toFixed(scale);
    } // Call the parent constructor


    Base.call(this, control, settings, true);
    /* TRIALFUNC */

    that.getVal = function () {
      var v = parseFloat($control.val());
      v = isNaN(v) ? val : v;
      return round(v);
    };

    that.setVal = function (v, fill, change) {
      v = parseFloat(v);
      setValue(isNaN(v) ? val : v, fill, change);
    };

    that._init = function () {
      ready = $control.parent().hasClass('mbsc-stepper');
      $parent = ready ? $control.closest('.mbsc-stepper-cont') : $control.parent();
      s = that.settings;
      min = settings.min === undefined ? getAttr('min', s.min) : settings.min;
      max = settings.max === undefined ? getAttr('max', s.max) : settings.max;
      step = settings.step === undefined ? getAttr('step', s.step) : settings.step;
      scale = Math.abs(step) < 1 ? (step + '').split('.')[1].length : 0;
      inputStyle = settings.inputStyle === undefined ? getAttr('data-input-style', s.inputStyle, true) : settings.inputStyle;
      displayValue = $control.attr('data-val') || s.val;
      val = round(+control.value || 0);
      theme = mobiscroll.themes.form[s.theme];
      ripple = theme && theme.addRipple ? theme : null;

      if (!ready) {
        $parent.addClass('mbsc-stepper-cont mbsc-no-touch mbsc-control-w').addClass(inputStyle == 'box' ? 'mbsc-input-box' : '').addClass(inputStyle == 'outline' ? 'mbsc-input-outline' : '').append('<span class="mbsc-segmented mbsc-stepper' + '"></span>').find('.mbsc-stepper').append('<span class="mbsc-segmented-item mbsc-stepper-control mbsc-stepper-minus ' + (val == min ? 'mbsc-disabled' : '') + '" data-step="-1" tabindex="0"><span class="mbsc-segmented-content"><span class="mbsc-ic mbsc-ic-minus"></span></span></span>').append('<span class="mbsc-segmented-item mbsc-stepper-control mbsc-stepper-plus ' + (val == max ? 'mbsc-disabled' : '') + '"  data-step="1" tabindex="0"><span class="mbsc-segmented-content"> <span class="mbsc-ic mbsc-ic-plus"></span></span></span>').prepend($control);
      }

      if (cssClass) {
        $parent.removeClass(cssClass).find('.mbsc-segmented').removeClass(cssClass);
      }

      cssClass = 'mbsc-' + s.theme + (theme.baseTheme ? ' mbsc-' + theme.baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr');
      $parent.addClass(cssClass).find('.mbsc-segmented').addClass(cssClass);
      $btnMinus = $$1('.mbsc-stepper-minus', $parent);
      $btnPlus = $$1('.mbsc-stepper-plus', $parent);
      $controls = $$1('.mbsc-stepper-control', $parent);

      if (!ready) {
        if (displayValue == 'left') {
          $parent.addClass('mbsc-stepper-val-left');
          $control.after('<span class="mbsc-segmented-item"><span class="mbsc-segmented-content"></span></span>');
        } else if (displayValue == 'right') {
          $parent.addClass('mbsc-stepper-val-right');
          $btnPlus.after('<span class="mbsc-segmented-item"><span class="mbsc-segmented-content"></span></span>');
        } else {
          $btnMinus.after('<span class="mbsc-segmented-item"><span class="mbsc-segmented-content mbsc-stepper-val"></span></span>');
        }
      }

      if (!stepper) {
        $control.on('change', onChange);
        stepper = createStepper($controls, stepValue, 150, checkDisabled, false, ripple);
      }

      $control.val(val).attr('data-role', 'stepper').attr('min', min).attr('max', max).attr('step', step).addClass('mbsc-control');
      control.mbscInst = that;
    };

    that._destroy = function () {
      $control.removeClass('mbsc-control').off('change', onChange);
      stepper.destroy();
      delete control.mbscInst;
    };

    that.init();
  };
  Stepper.prototype = {
    _class: 'stepper',
    _hasDef: true,
    _hasTheme: true,
    _hasLang: true,
    _defaults: {
      min: 0,
      max: 100,
      step: 1
    }
  };
  classes.Stepper = Stepper; // Init mbsc-stepper elements on page load

  autoInit('[mbsc-stepper]', Stepper);

  var ProgressBase = function ProgressBase(elm, settings, inherit) {
    var $elm,
        $parent,
        cssClass,
        s,
        that = this; // Call the parent constructor

    Base.call(this, elm, settings, true);
    that.__init = noop;
    that.__destroy = noop;

    that._init = function () {
      var wasInit;
      s = that.settings;
      $elm = $$1(elm); // Check if the element was already initialized

      wasInit = !!$parent;
      $parent = $elm.parent();
      $parent = $parent.hasClass('mbsc-input-wrap') ? $parent.parent() : $parent;
      that._$parent = $parent;

      if (cssClass) {
        $parent.removeClass(cssClass);
      }

      cssClass = that._css + ' mbsc-progress-w mbsc-control-w ' + getCssClass(s);
      $parent.addClass(cssClass);
      $elm.addClass('mbsc-control');

      that.__init();

      if (!wasInit) {
        that._attachChange();
      } // Show initial value


      that.refresh();
      elm.mbscInst = that;
    };

    that._destroy = function () {
      that.__destroy();

      $parent.removeClass(cssClass);
      $elm.removeClass('mbsc-control');
      delete elm.mbscInst;
    };

    if (!inherit) {
      that.init();
    }
  };

  var SliderBase = function SliderBase(elm, settings, inherit) {
    var $elm,
        $handle,
        $handleCont,
        $handles,
        $listeners,
        $parent,
        $track,
        action,
        base,
        changed,
        diffX,
        diffY,
        diff,
        endX,
        endY,
        handleIndex,
        isHover,
        isPressed,
        isRtl,
        live,
        max,
        min,
        moved,
        multiple,
        oldValue,
        step,
        s,
        scale,
        startX,
        startY,
        stepDecimal,
        timer,
        totalWidth,
        value,
        that = this,
        lastUpdate = new Date();

    function onStart(ev) {
      if (ev.type === 'mousedown') {
        ev.preventDefault();
      }

      if (testTouch(ev, this) && (!action || isHover) && !elm.disabled && !elm.readOnly
      /* TRIALCOND */
      ) {
          if (s.stopProp) {
            ev.stopPropagation();
          }

          action = true;
          moved = false;
          changed = false;
          startX = getCoord(ev, 'X');
          startY = getCoord(ev, 'Y');
          endX = startX;
          $track.removeClass('mbsc-progress-anim');
          $handle = multiple ? $$1('.mbsc-slider-handle', this) : $handles;

          if ($handleCont) {
            $handleCont.removeClass('mbsc-handle-curr');
          }

          $handleCont = $handle.parent().addClass('mbsc-active mbsc-handle-curr');
          $elm.addClass('mbsc-active');
          handleIndex = +$handle.attr('data-index');
          totalWidth = $track[0].offsetWidth;
          diff = $track[0].getBoundingClientRect().left;

          if (ev.type === 'mousedown') {
            isPressed = true;
            $$1(document).on('mousemove', onMove).on('mouseup', onEnd);
          }

          if (ev.type === 'mouseenter') {
            isHover = true;
            $$1(document).on('mousemove', onMove);
          }
        }
    }

    function onMove(ev) {
      if (action) {
        endX = getCoord(ev, 'X');
        endY = getCoord(ev, 'Y');
        diffX = endX - startX;
        diffY = endY - startY;

        if (Math.abs(diffX) > 5) {
          moved = true;
        }

        if (moved || isPressed || isHover) {
          if (Math.abs(lastUpdate - new Date()) > 50) {
            lastUpdate = new Date();
            updateSlider(endX, s.round, live && (!isHover || isPressed));
          }
        }

        if (moved) {
          ev.preventDefault();
        } else if (Math.abs(diffY) > 7 && ev.type == 'touchmove') {
          cleanUp();
        }
      }
    }

    function onEnd(ev) {
      if (action) {
        ev.preventDefault();

        if (!multiple) {
          $track.addClass('mbsc-progress-anim');
        }

        if (isHover && !isPressed) {
          updateValue(value[handleIndex], handleIndex, false, false, true);
        } else {
          updateSlider(endX, true, true);
        }

        if (!moved && !changed) {
          if (ev.type == 'touchend') {
            // Prevent ghost click
            preventClick();
          }

          that._onTap(value[handleIndex]);
        }

        if (ev.type == 'mouseup') {
          isPressed = false;
        }

        if (ev.type == 'mouseleave') {
          isHover = false;
        }

        if (!isHover) {
          cleanUp();
        }
      }
    }

    function onCancel() {
      if (action) {
        cleanUp();
      }
    }

    function onChange() {
      var v = that._readValue($$1(this)),
          i = +$$1(this).attr('data-index');

      if (v !== value[i]) {
        value[i] = v;
        oldValue[i] = v;
        updateValue(v, i);
      }
    }

    function onClick(ev) {
      // Prevent propagating click to label
      ev.stopPropagation();
    }

    function onLabelClick(ev) {
      // Prevent change on label click for swithes
      ev.preventDefault();
    }

    function onKeyDown(ev) {
      var dir;

      if (!elm.disabled) {
        switch (ev.keyCode) {
          case 38:
          case 39:
            dir = 1;
            break;

          case 40:
          case 37:
            dir = -1;
            break;
        }

        if (dir) {
          ev.preventDefault();

          if (!timer) {
            handleIndex = +$$1(this).attr('data-index');
            updateValue(value[handleIndex] + step * dir, handleIndex, true);
            timer = setInterval(function () {
              updateValue(value[handleIndex] + step * dir, handleIndex, true);
            }, 200);
          }
        }
      }
    }

    function onKeyUp(ev) {
      ev.preventDefault();
      clearInterval(timer);
      timer = null;
    }

    function cleanUp() {
      action = false;
      $handleCont.removeClass('mbsc-active');
      $elm.removeClass('mbsc-active'); // Detach document events

      $$1(document).off('mousemove', onMove).off('mouseup', onEnd);
    }

    function updateSlider(pos, round, fill) {
      var percent = round ? Math.min(Math[that._rounding || 'round'](Math.max((pos - diff) * 100 / totalWidth, 0) / scale / step) * step * 100 / (max - min + base), 100) : Math.max(0, Math.min((pos - diff) * 100 / totalWidth, 100));

      if (isRtl) {
        percent = 100 - percent;
      }

      updateValue(Math.round((min - base + percent / scale) * stepDecimal) / stepDecimal, handleIndex, fill, percent);
    }

    function updateValue(v, index, fill, percent, refresh, change) {
      var $handle = $handles.eq(index),
          $handleCont = $handle.parent();
      v = Math.min(max, Math.max(v, min));

      if (change === undefined) {
        change = fill;
      }

      if (that._update) {
        v = that._update(v, value, index, percent, multiple, refresh, $handleCont);
      } else {
        $handleCont.css({
          left: isRtl ? 'auto' : (percent || getPercent(v, min, max)) + '%',
          right: isRtl ? (percent || getPercent(v, min, max)) + '%' : 'auto'
        });
      }

      if (v > min) {
        $handleCont.removeClass('mbsc-slider-start');
      } else if (value[index] > min || refresh) {
        $handleCont.addClass('mbsc-slider-start');
      } // Store new value


      if (fill) {
        value[index] = v;
      } // Check if value changed


      if (fill && oldValue[index] != v) {
        changed = true;
        oldValue[index] = v; // Set new value to the input

        that._fillValue(v, index, change);
      }

      $handle.attr('aria-valuenow', v);
    } // Call the parent constructor


    ProgressBase.call(this, elm, settings, true);
    that._onTap = noop;
    that.___init = noop;
    that.___destroy = noop;

    that._attachChange = function () {
      $elm.on(s.changeEvent, onChange);
    };

    that.__init = function () {
      var wasInit;

      if ($handles) {
        wasInit = true;
        $handles.parent().remove();
      }

      that.___init();

      $parent = that._$parent;
      $track = that._$track;
      $elm = $parent.find('input');
      s = that.settings;
      min = that._min;
      max = that._max;
      base = that._base || 0;
      step = that._step;
      live = that._live;
      stepDecimal = step % 1 !== 0 ? 100 / (+(step % 1).toFixed(2) * 100) : 1;
      scale = 100 / (max - min + base) || 100;
      multiple = $elm.length > 1;
      isRtl = s.rtl;
      value = [];
      oldValue = []; // Read values

      $elm.each(function (i) {
        value[i] = that._readValue($$1(this));
        $$1(this).attr('data-index', i);
      });
      $handles = $parent.find('.mbsc-slider-handle');
      $listeners = $parent.find(multiple ? '.mbsc-slider-handle-cont' : '.mbsc-progress-cont'); // Attach events

      $handles.on('keydown', onKeyDown).on('keyup', onKeyUp).on('blur', onKeyUp);
      $listeners.each(function (i, listener) {
        listen(listener, 'touchstart', onStart, {
          passive: true
        });
        listen(listener, 'mousedown', onStart);
        listen(listener, 'touchend', onEnd);
        listen(listener, 'touchcancel', onEnd);
        listen(listener, 'pointercancel', onCancel);

        if (s.hover) {
          listen(listener, 'mouseenter', onStart);
          listen(listener, 'mouseleave', onEnd);
        }
      });

      if (!wasInit) {
        $elm.on('click', onClick);
        $parent.on('click', onLabelClick); // Attach to document to avoid non-passive listener warnings

        listen(document, 'touchmove', onMove, {
          passive: false
        });
      }
    };

    that.__destroy = function () {
      $parent.off('click', onLabelClick);
      $elm.off(s.changeEvent, onChange).off('click', onClick);
      $handles.off('keydown', onKeyDown).off('keyup', onKeyUp).off('blur', onKeyUp);
      $listeners.each(function (i, listener) {
        unlisten(listener, 'touchstart', onStart, {
          passive: true
        });
        unlisten(listener, 'mousedown', onStart);
        unlisten(listener, 'touchend', onEnd);
        unlisten(listener, 'touchcancel', onEnd);
        unlisten(listener, 'pointercancel', onCancel);
        unlisten(listener, 'mouseenter', onStart);
        unlisten(listener, 'mouseleave', onEnd);
        unlisten(document, 'touchmove', onMove, {
          passive: false
        });
      });

      that.___destroy();
    };

    that.refresh = function () {
      $elm.each(function (i) {
        updateValue(that._readValue($$1(this)), i, true, false, true, false);
      });
    };

    that.getVal = function () {
      return multiple ? value.slice(0) : value[0];
    };

    that.setVal = that._setVal = function (val, fill, change) {
      if (!$$1.isArray(val)) {
        val = [val];
      }

      $$1.each(val, function (i, v) {
        value[i] = v;
      });
      $$1.each(val, function (i, v) {
        updateValue(v, i, true, false, true, change);
      });
    };

    if (!inherit) {
      that.init();
    }
  };

  var Switch = function Switch(elm, settings) {
    var $elm,
        $parent,
        s,
        formControl,
        that = this;
    settings = settings || {};
    extend$1(settings, {
      changeEvent: 'click',
      round: false
    }); // Call the parent constructor

    SliderBase.call(this, elm, settings, true);

    that._readValue = function () {
      return elm.checked ? 1 : 0;
    };

    that._fillValue = function (v, index, change) {
      $elm.prop('checked', !!v);

      if (change) {
        $elm.trigger('change');
      }
    };

    that._onTap = function (v) {
      that._setVal(v ? 0 : 1);
    };

    that.___init = function () {
      s = that.settings;
      $elm = $$1(elm);
      $parent = $elm.parent();
      $parent.find('.mbsc-switch-track').remove();
      $parent.prepend($elm);
      $elm.attr('data-role', 'switch').after('<span class="mbsc-progress-cont mbsc-switch-track">' + '<span class="mbsc-progress-track mbsc-progress-anim">' + '<span class="mbsc-slider-handle-cont">' + '<span class="mbsc-slider-handle mbsc-switch-handle" data-index="0">' + '<span class="mbsc-switch-txt-off">' + s.offText + '</span>' + '<span class="mbsc-switch-txt-on">' + s.onText + '</span>' + '</span></span></span></span>');

      if (formControl) {
        formControl.destroy();
      }

      formControl = new FormControl(elm, s);
      that._$track = $parent.find('.mbsc-progress-track');
      that._min = 0;
      that._max = 1;
      that._step = 1;
    };

    that.___destroy = function () {
      formControl.destroy();
    };

    that.getVal = function () {
      return elm.checked;
    };

    that.setVal = function (val, fill, change) {
      that._setVal(val ? 1 : 0, fill, change);
    };

    that.init();
  };
  Switch.prototype = {
    _class: 'switch',
    _css: 'mbsc-switch',
    _hasTheme: true,
    _hasLang: true,
    _hasDef: true,
    _defaults: {
      stopProp: true,
      offText: 'Off',
      onText: 'On'
    }
  };
  classes.Switch = Switch; // Init mbsc-switch elements on page load

  autoInit('[mbsc-switch]', Switch);

  // eslint-disable-next-line no-unused-vars
  var Progress = function Progress(elm, settings, inherit) {
    var $display,
        $elm,
        $parent,
        $progress,
        $target,
        $track,
        min,
        max,
        inputStyle,
        labelStyle,
        s,
        template,
        value,
        valueText,
        that = this;

    function onChange() {
      var v = getAttr('value', min);

      if (v !== value) {
        updateValue(v);
      }
    }

    function getAttr(attr, def, str) {
      var v = $elm.attr(attr);
      return v === undefined || v === '' ? def : str ? v : +v;
    }

    function updateValue(v, refresh, fill, change) {
      v =
      /* TRIALCONDREV */
      Math.min(max, Math.max(v, min));
      $progress.css('width', (v - min) * 100 / (max - min) + '%');

      if (fill === undefined) {
        fill = true;
      }

      if (change === undefined) {
        change = fill;
      }

      if (v !== value || refresh) {
        // Display value
        that._display(v);
      }

      if (v !== value) {
        // Set new value
        value = v; // Put new value in the progress element

        if (fill) {
          $elm.attr('value', value);
        } // Trigger change on the element


        if (change) {
          $elm.trigger('change');
        }
      }
    } // Call the parent constructor


    ProgressBase.call(this, elm, settings, true);

    that._display = function (v) {
      valueText = template && s.returnAffix ? template.replace(/\{value\}/, v).replace(/\{max\}/, max) : v;

      if ($target) {
        $target.html(valueText);
      }

      if ($display) {
        $display.html(valueText);
      }
    };

    that._attachChange = function () {
      $elm.on('change', onChange);
    };

    that.__init = function () {
      var displayValue, i, stepLabels, wasInit;
      s = that.settings;
      $elm = $$1(elm); // Check if the element was already initialized

      wasInit = !!$parent;
      $parent = that._$parent; // Read settings from data attributes or settings object

      min = that._min = settings.min === undefined ? getAttr('min', s.min) : settings.min;
      max = that._max = settings.max === undefined ? getAttr('max', s.max) : settings.max;
      inputStyle = settings.inputStyle === undefined ? getAttr('data-input-style', s.inputStyle, true) : settings.inputStyle;
      labelStyle = settings.labelStyle === undefined ? getAttr('data-label-style', s.labelStyle, true) : settings.labelStyle;
      value = getAttr('value', min);
      displayValue = $elm.attr('data-val') || s.val;
      stepLabels = $elm.attr('data-step-labels');
      stepLabels = stepLabels ? JSON.parse(stepLabels) : s.stepLabels;
      template = $elm.attr('data-template') || (max == 100 && !s.template ? '{value}%' : s.template);

      if (!wasInit) {
        wrapLabel($parent, null, inputStyle, labelStyle, elm);
        addIcon($elm); // Generate track and progress

        $parent.find('.mbsc-input-wrap').append('<span class="mbsc-progress-cont"><span class="mbsc-progress-track mbsc-progress-anim"><span class="mbsc-progress-bar"></span></span></span>');
        $progress = that._$progress = $parent.find('.mbsc-progress-bar');
        $track = that._$track = $parent.find('.mbsc-progress-track');
      } else {
        if (displayValue) {
          $display.remove();
          $parent.removeClass('mbsc-progress-value-' + (displayValue == 'right' ? 'right' : 'left'));
        }

        if (stepLabels) {
          $$1('.mbsc-progress-step-label', $track).remove();
        }
      } // Set attributes


      $elm.attr('min', min).attr('max', max); // Generate value container on left or right side

      if (displayValue) {
        $display = $$1('<span class="mbsc-progress-value"></span>');
        $parent.addClass('mbsc-progress-value-' + (displayValue == 'right' ? 'right' : 'left')).find('.mbsc-input-wrap').append($display);
      } // Generate step labels


      if (stepLabels) {
        for (i = 0; i < stepLabels.length; ++i) {
          $track.append('<span class="mbsc-progress-step-label" style="' + (s.rtl ? 'right' : 'left') + ': ' + (stepLabels[i] - min) * 100 / (max - min) + '%" >' + stepLabels[i] + '</span>');
        }
      }

      $target = $$1($elm.attr('data-target') || s.target);
    };

    that.__destroy = function () {
      $parent.removeClass('mbsc-ic-left mbsc-ic-right').find('.mbsc-progress-cont').remove();
      $parent.find('.mbsc-input-ic').remove();
      $elm.off('change', onChange);
    };

    that.refresh = function () {
      updateValue(getAttr('value', min), true, false);
    };

    that.getVal = function () {
      return value;
    };

    that.setVal = function (v, fill, change) {
      updateValue(v, true, fill, change);
    };

    if (!inherit) {
      that.init();
    }
  };
  Progress.prototype = {
    _class: 'progress',
    _css: 'mbsc-progress',
    _hasTheme: true,
    _hasLang: true,
    _hasDef: true,
    _defaults: {
      min: 0,
      max: 100,
      returnAffix: true
    }
  };
  classes.Progress = Progress; // Init mbsc-progress elements on page load

  autoInit('[mbsc-progress]', Progress);

  var Slider = function Slider(elm, settings, inherit) {
    var $elm,
        $parent,
        $progress,
        $tooltips,
        $track,
        hasProgress,
        hasTooltip,
        isRange,
        isRtl,
        max,
        min,
        step,
        s,
        that = this; // Call the parent constructor

    Progress.call(this, elm, settings, true);
    var progressInit = that.__init,
        progressDestroy = that.__destroy;
    SliderBase.call(this, elm, settings, true);
    var sliderInit = that.__init,
        sliderDestroy = that.__destroy; // ---

    that.__init = function () {
      progressInit();
      sliderInit();
    };

    that.__destroy = function () {
      progressDestroy();
      sliderDestroy();
    };

    that._update = function (v, value, index, percent, multiple, refresh, $handleCont) {
      if (isRange) {
        if (index === 0) {
          v = Math.min(v, value[1]);
          $progress.css({
            width: getPercent(value[1], min, max) - getPercent(v, min, max) + '%',
            left: isRtl ? 'auto' : getPercent(v, min, max) + '%',
            right: isRtl ? getPercent(v, min, max) + '%' : 'auto'
          });
        } else {
          v = Math.max(v, value[0]);
          $progress.css({
            width: getPercent(v, min, max) - getPercent(value[0], min, max) + '%'
          });
        }
      } else if (multiple || !hasProgress) {
        $handleCont.css({
          left: isRtl ? 'auto' : (percent || getPercent(v, min, max)) + '%',
          right: isRtl ? (percent || getPercent(v, min, max)) + '%' : 'auto'
        });
      } else {
        $progress.css('width', (percent || getPercent(v, min, max)) + '%');
      }

      if (hasTooltip) {
        $tooltips.eq(index).html(v);
      } // Display value in the specified container(s)


      if (!multiple && (value[index] != v || refresh)) {
        that._display(v);
      } // Return validated value


      return v;
    };

    that._readValue = function ($elm) {
      return +$elm.val();
    };

    that._fillValue = function (v, index, change) {
      $elm.eq(index).val(v);

      if (change) {
        $elm.eq(index).trigger('change');
      }
    };

    that._markupReady = function () {
      var i, stepNr;

      if (hasTooltip) {
        $parent.addClass('mbsc-slider-has-tooltip');
      } // Generate step marks


      if (step != 1) {
        stepNr = (max - min) / step;

        for (i = 0; i <= stepNr; ++i) {
          $track.append('<span class="mbsc-slider-step" style="' + (isRtl ? 'right' : 'left') + ':' + 100 / stepNr * i + '%"></span>');
        }
      } // Generate slider handles


      $elm.each(function (i, elm) {
        var value = +elm.value;

        if (elm.type == 'range') {
          // Set min / max / step properties for all inputs
          $$1(elm).attr('min', min).attr('max', max).attr('step', step);
        }

        (hasProgress ? $progress : $track).append('<span class="mbsc-slider-handle-cont' + (isRange && !i ? ' mbsc-slider-handle-left' : '') + (isRange && !i && value > (max - min) / 2 ? ' mbsc-handle-curr' : '') + '">' + '<span tabindex="0" class="mbsc-slider-handle" aria-valuemin="' + min + '" aria-valuemax="' + max + '" data-index="' + i + '"></span>' + (hasTooltip ? '<span class="mbsc-slider-tooltip"></span>' : '') + '</span>');
      });
      $tooltips = $parent.find('.mbsc-slider-tooltip');
    };

    that.___init = function () {
      if ($parent) {
        $parent.removeClass('mbsc-slider-has-tooltip');

        if (step != 1) {
          $$1('.mbsc-slider-step', $track).remove();
        }
      }

      $parent = that._$parent;
      $track = that._$track;
      $progress = that._$progress;
      $elm = $parent.find('input');
      s = that.settings;
      min = that._min;
      max = that._max;
      that._step = step = settings.step === undefined ? +$elm.attr('step') || s.step : settings.step;
      that._live = getBoolAttr('data-live', s.live, $elm);
      hasTooltip = getBoolAttr('data-tooltip', s.tooltip, $elm);
      hasProgress = getBoolAttr('data-highlight', s.highlight, $elm) && $elm.length < 3;
      isRange = hasProgress && $elm.length == 2;
      isRtl = s.rtl;

      that._markupReady();
    };

    if (!inherit) {
      that.init();
    }
  };
  Slider.prototype = {
    _class: 'progress',
    _css: 'mbsc-progress mbsc-slider',
    _hasTheme: true,
    _hasLang: true,
    _hasDef: true,
    _defaults: {
      changeEvent: 'change',
      stopProp: true,
      min: 0,
      max: 100,
      step: 1,
      live: true,
      highlight: true,
      round: true,
      returnAffix: true
    }
  };
  classes.Slider = Slider; // Init mbsc-slider elements on page load

  autoInit('[mbsc-slider]', Slider);

  var Rating = function Rating(elm, settings, inherit) {
    var $progress,
        $track,
        max,
        min,
        empty,
        filled,
        s,
        that = this,
        $elm = $$1(elm); // Call the parent constructor

    Slider.call(this, elm, settings, true);

    that._update = function (v, value, index, percent, multiple, refresh) {
      $progress.css('width', getPercent(v, 0, max) + '%'); // Display value in the specified container(s)

      if (!multiple && (value[index] != v || refresh)) {
        that._display(v);
      } // Return validated value


      return v;
    };

    that._markupReady = function () {
      var i,
          emptyString = '',
          filledString = '';
      $track = that._$track;
      $progress = that._$progress;
      s = that.settings;
      min = that._min;
      max = that._max;
      that._base = min;
      that._rounding = s.rtl ? 'floor' : 'ceil';
      empty = $elm.attr('data-empty') || s.empty;
      filled = $elm.attr('data-filled') || s.filled;

      for (i = 0; i < max; ++i) {
        emptyString += '<span class="mbsc-ic mbsc-ic-' + empty + '"></span>';
        filledString += '<span class="mbsc-ic mbsc-ic-' + filled + '"></span>';
      }

      $track.html(emptyString);
      $track.append($progress);
      $progress.html(filledString);
      $track.append('<span class="mbsc-rating-handle-cont' + '">' + '<span tabindex="0" class="mbsc-slider-handle" aria-valuemin="' + min + '" aria-valuemax="' + max + '" data-index="0"></span>' + '</span>');
    };

    if (!inherit) {
      that.init();
    }
  };
  Rating.prototype = {
    _class: 'progress',
    _css: 'mbsc-progress mbsc-rating',
    _hasTheme: true,
    _hasLang: true,
    _hasDef: true,
    _defaults: {
      changeEvent: 'change',
      stopProp: true,
      min: 1,
      max: 5,
      step: 1,
      live: true,
      round: true,
      hover: true,
      highlight: true,
      returnAffix: true,
      empty: 'star',
      filled: 'star3'
    }
  };
  classes.Rating = Rating; // Init mbsc-rating elements on page load

  autoInit('[mbsc-rating]', Rating);

  var nr = 1;
  var CollapsibleBase =
  /*#__PURE__*/
  function () {
    function CollapsibleBase(elm, settings) {
      var _this = this;

      var content;
      var $header;
      var $content;
      var $elm = $$1(elm);
      this.settings = settings;
      this._isOpen = settings.isOpen || false;
      $elm.addClass('mbsc-collapsible ' + (this._isOpen ? 'mbsc-collapsible-open' : ''));

      if ($elm.hasClass('mbsc-card')) {
        // card enhance
        $header = $elm.find('.mbsc-card-header').eq(0).addClass('mbsc-collapsible-header');
        $content = $elm.find('.mbsc-card-content').eq(0).addClass('mbsc-collapsible-content');
      } else if ($elm.hasClass('mbsc-form-group') || $elm.hasClass('mbsc-form-group-inset')) {
        // form group enhance
        $header = $elm.find('.mbsc-form-group-title').eq(0).addClass('mbsc-collapsible-header');
        $content = $elm.find('.mbsc-form-group-content').eq(0).addClass('mbsc-collapsible-content');
      } else {
        // if it is used independently
        $header = $elm.find('.mbsc-collapsible-header').eq(0);
        $content = $elm.find('.mbsc-collapsible-content').eq(0);
      }

      content = $content[0];

      if (content && !content.id) {
        content.id = 'mbsc-collapsible-' + nr++;
      }

      if ($header.length && content) {
        var $collapsibleIcon = $$1('<span class="mbsc-collapsible-icon mbsc-ic mbsc-ic-arrow-down5"></span>');
        tap(this, $header, function () {
          _this.collapse();
        });
        $header.attr('role', 'button').attr('aria-expanded', this._isOpen).attr('aria-controls', content.id).attr('tabindex', '0').on('mousedown', this.onMouseDown).on('keydown', this.onKeyDown).append($collapsibleIcon);
      }

      elm.mbscInst = this;
      this._$header = $header;
      this._$content = $content;
      this._$elm = $elm;
      this._$accordionParent = $elm.parent('[mbsc-accordion], mbsc-accordion, .mbsc-accordion');
      this.show = this.show.bind(this);
      this.hide = this.hide.bind(this);
      this.toggle = this.toggle.bind(this);
      this.onKeyDown = this.onKeyDown.bind(this);
      this.onMouseDown = this.onMouseDown.bind(this);
    }

    var _proto = CollapsibleBase.prototype;

    _proto.collapse = function collapse(show) {
      var $elm = this._$elm;
      var $content = this._$content;

      var removeHeight = function removeHeight() {
        $content.off('transitionend', removeHeight).css('height', '');
      };

      if (show === undefined) {
        show = !this._isOpen;
      }

      if (show && this._isOpen || !show && !this._isOpen || !$content.length) {
        return;
      }

      if (show) {
        if (hasTransition) {
          $content.on('transitionend', removeHeight).css('height', $content[0].scrollHeight);
        }

        $elm.addClass('mbsc-collapsible-open');
      } else {
        if (hasTransition) {
          $content.css('height', getComputedStyle($content[0]).height);
        }

        setTimeout(function () {
          $content.css('height', 0);
          $elm.removeClass('mbsc-collapsible-open');
        }, 50);
      }

      if (show && this._$accordionParent) {
        this._$accordionParent.find('.mbsc-collapsible-open').each(function () {
          if (this !== $elm[0]) {
            this.mbscInst.hide();
          }
        });
      }

      this._isOpen = show;

      this._$header.attr('aria-expanded', this._isOpen);
    };

    _proto.show = function show() {
      this.collapse(true);
    };

    _proto.hide = function hide() {
      this.collapse(false);
    };

    _proto.toggle = function toggle() {
      this.collapse();
    };

    _proto.destroy = function destroy() {
      this._$elm.removeClass('mbsc-collapsible mbsc-collapsible-open');

      this._$content.removeClass('mbsc-collapsible-content');

      this._$header.removeClass('mbsc-collapsible-header').off('mousedown', this.onMouseDown).off('keydown', this.onKeyDown).find('.mbsc-collapsible-icon').remove();

      tapOff(this._$header);
    };

    _proto.onKeyDown = function onKeyDown(ev) {
      if (ev.which === 32 || ev.keyCode == 13) {
        //space or enter 
        ev.preventDefault();
        this.collapse();
      }
    };

    _proto.onMouseDown = function onMouseDown(ev) {
      // prevent focus on mouse down
      ev.preventDefault();
    };

    return CollapsibleBase;
  }();
  classes.CollapsibleBase = CollapsibleBase;

  var id$2 = 0;

  function initControls($ctx, controls, s, shallow) {
    $$1('input,select,textarea,progress,button', $ctx).each(function () {
      var control = this,
          $control = $$1(control),
          //$parent = $control.parent(),
      type = getControlType($control); // Skip elements with data-enhance="false"

      if ($control.attr('data-enhance') != 'false'
      /* TRIALCOND */
      ) {
          if ($control.hasClass('mbsc-control')) {
            if (control.mbscInst) {
              control.mbscInst.option({
                theme: s.theme,
                lang: s.lang,
                rtl: s.rtl,
                onText: s.onText,
                offText: s.offText,
                stopProp: s.stopProp
              });
            }
          } else {
            if (!control.id) {
              control.id = 'mbsc-form-control-' + ++id$2;
            }

            switch (type) {
              case 'button':
              case 'submit':
                controls[control.id] = new Button(control, {
                  theme: s.theme,
                  rtl: s.rtl,
                  tap: s.tap
                });
                break;

              case 'switch':
                controls[control.id] = new Switch(control, {
                  theme: s.theme,
                  lang: s.lang,
                  rtl: s.rtl,
                  tap: s.tap,
                  onText: s.onText,
                  offText: s.offText,
                  stopProp: s.stopProp
                });
                break;

              case 'checkbox':
                controls[control.id] = new CheckBox(control, {
                  tap: s.tap,
                  theme: s.theme,
                  rtl: s.rtl
                });
                break;

              case 'range':
                if (!$$1(control).parent().hasClass('mbsc-slider')) {
                  controls[control.id] = new Slider(control, {
                    theme: s.theme,
                    lang: s.lang,
                    rtl: s.rtl,
                    stopProp: s.stopProp,
                    labelStyle: s.labelStyle
                  });
                }

                break;

              case 'rating':
                controls[control.id] = new Rating(control, {
                  theme: s.theme,
                  lang: s.lang,
                  rtl: s.rtl,
                  stopProp: s.stopProp
                });
                break;

              case 'progress':
                controls[control.id] = new Progress(control, {
                  theme: s.theme,
                  lang: s.lang,
                  rtl: s.rtl,
                  labelStyle: s.labelStyle
                });
                break;

              case 'radio':
                controls[control.id] = new Radio(control, {
                  tap: s.tap,
                  theme: s.theme,
                  rtl: s.rtl
                });
                break;

              case 'select':
              case 'select-one':
              case 'select-multiple':
                controls[control.id] = new Select(control, {
                  tap: s.tap,
                  inputStyle: s.inputStyle,
                  labelStyle: s.labelStyle,
                  theme: s.theme,
                  rtl: s.rtl
                });
                break;

              case 'textarea':
                controls[control.id] = new TextArea(control, {
                  tap: s.tap,
                  inputStyle: s.inputStyle,
                  labelStyle: s.labelStyle,
                  theme: s.theme,
                  rtl: s.rtl
                });
                break;

              case 'segmented':
                controls[control.id] = new SegmentedItem(control, {
                  theme: s.theme,
                  rtl: s.rtl,
                  tap: s.tap,
                  inputStyle: s.inputStyle
                });
                break;

              case 'stepper':
                controls[control.id] = new Stepper(control, {
                  theme: s.theme,
                  rtl: s.rtl
                });
                break;

              case 'hidden':
                return;

              default:
                controls[control.id] = new Input(control, {
                  tap: s.tap,
                  inputStyle: s.inputStyle,
                  labelStyle: s.labelStyle,
                  theme: s.theme,
                  rtl: s.rtl
                });
                break;
            }
          }
        }
    });
    $$1('[data-collapsible]:not(.mbsc-collapsible)', $ctx).each(function () {
      var control = this,
          $control = $$1(control),
          isOpen = $control.attr('data-open');

      if (!control.id) {
        control.id = 'mbsc-form-control-' + ++id$2;
      }

      controls[control.id] = new CollapsibleBase(control, {
        isOpen: isOpen !== undefined && isOpen != 'false'
      });
      instances[control.id] = controls[control.id];
    }); // Set initial height for textareas

    if (!shallow) {
      sizeTextAreas();
    }
  }

  // eslint-disable-next-line no-unused-vars
  var Card = function Card(el, settings) {
    var s,
        collapsibleInst,
        cssClass = '',
        $elm = $$1(el),
        controls = {},
        that = this;

    function touched() {
      $elm.removeClass('mbsc-no-touch');
    } // Call the parent constructor


    Base.call(this, el, settings, true);

    that.refresh = function (shallow) {
      initControls($elm, controls, s, shallow);
    };
    /**
     * Card initialization.
     */


    that._init = function () {
      var isCollapsible = s.collapsible !== undefined || $elm.attr('data-collapsible') !== undefined;

      if (!$elm.hasClass('mbsc-card')) {
        $elm.show();
        listen(el, 'touchstart', touched, {
          passive: true
        });
      }

      if (cssClass) {
        $elm.removeClass(cssClass);
      }
      /*
      cssClass = 'mbsc-card mbsc-form mbsc-no-touch mbsc-' + s.theme +
          (halfBorder ? ' mbsc-form-hb' : '') +
          (s.baseTheme ? ' mbsc-' + s.baseTheme : '') +
          (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr');
      */
      // --- REMOTE TRIAL CODE START ---


      cssClass = that.remote.cards.cssClass; // --- REMOTE TRIAL CODE END ---

      $elm.addClass(cssClass).removeClass('mbsc-cloak');

      if (isCollapsible && !collapsibleInst) {
        var isOpen = $elm.attr('data-open');
        collapsibleInst = new CollapsibleBase(el, {
          isOpen: isOpen !== undefined && isOpen != 'false' || s.collapsible === true
        });
      }

      $elm.append(that._getText(mobiscroll, 0.5));
      that.refresh();
    };
    /**
     * Destroys the mobiscroll instance.
     */


    that._destroy = function () {
      $elm.removeClass(cssClass);
      unlisten(el, 'touchstart', touched, {
        passive: true
      });

      for (var id in controls) {
        controls[id].destroy();
      }

      if (collapsibleInst) {
        collapsibleInst.destroy();
      }
    };

    that.toggle = function () {
      if (collapsibleInst) {
        collapsibleInst.toggle();
      }
    };

    that.hide = function () {
      if (collapsibleInst) {
        collapsibleInst.hide();
      }
    };

    that.show = function () {
      if (collapsibleInst) {
        collapsibleInst.show();
      }
    }; // Constructor


    s = that.settings;
    that.init();
  }; // Extend defaults

  Card.prototype = {
    _hasDef: true,
    _hasTheme: true,
    _hasLang: true,
    _class: 'card',
    _defaults: {
      tap: hasGhostClick,
      stopProp: true,
      rtl: false
    }
  };
  classes.Card = Card; // Init mbsc-card elements on page load or when mbsc-enhance event is triggeres

  autoInit('[mbsc-card]', Card, true);

  var SELECTED_CLASS = 'mbsc-selected';
  var ACTIVE_CLASS = 'mbsc-lv-item-active';
  var confirms,
      guid = 1,
      transp = 'transparent';
  var ListView = function ListView(elem, settings) {
    var action,
        actionWidth,
        activeTimer,
        animPos,
        cancel,
        confirmItem,
        confirmIndex,
        cont,
        cont0,
        currIndex,
        currList,
        currPh,
        currParent,
        currSiblings,
        currStage,
        currStageIdx,
        debounce,
        demoMode,
        disabled,
        diffX,
        diffY,
        dropDown,
        dropUp,
        dragged,
        dummyCont,
        endTimer,
        endX,
        endY,
        event,
        fill,
        found,
        groupHeader,
        hadEnhance,
        handlePos,
        hasContext,
        handleDiv,
        hoverDir,
        hoverItem,
        hoverItemOpened,
        hoverTime,
        hoverTimeout,
        hoverTimer,
        htmlLeft,
        htmlRight,
        icon,
        iconc,
        stagec,
        isClick,
        isLoading,
        isTouch,
        itemw,
        item,
        itemHeight,
        itemIndex,
        itemNode,
        itemSelector,
        itemTop,
        listNode,
        listSelector,
        loading,
        maxDrag,
        minDrag,
        multic,
        multiple,
        nextItem,
        nextOffset,
        nextStage,
        nextItems,
        onScrollThrottle,
        onScrollDebounce,
        prevClick,
        preventHover,
        preventTimer,
        prevItems,
        placeholder,
        prevItem,
        prevOffset,
        prevStage,
        quickSwipe,
        rafID,
        rafRunning,
        s,
        scroll,
        selectable,
        simulating,
        slideCont,
        stageNr,
        stages,
        startPos,
        startTime,
        startX,
        startY,
        style,
        swipe,
        swipeInterval,
        swipeTimeout,
        tapHighlight,
        text,
        timer,
        type,
        types,
        undoRef,
        undoAnim,
        wnd,
        wnd0,
        wndHeight,
        wndScroll,
        wndTop,
        that = this,
        e = elem,
        elm = $$1(e),
        transition = 0,
        slideLevel = 0,
        startTop = 0,
        stageObj = {},
        actionQueue = {},
        treeMap = {};

    function onActionStart() {
      quickSwipe = false;
      prevClick = false;
      animPos = 0;
      startPos = 0;
      startTime = new Date();
      itemw = currList.width();
      currSiblings = getChildren(currList);
      itemIndex = currSiblings.index(item);
      itemHeight = item[0].offsetHeight;
      startTop = item[0].offsetTop;
      type = types[item.attr('data-type') || 'defaults'];
      stages = type.stages;
    }

    function onStart(ev) {
      var itm;
      var target = closest(cont0, ev.target, '.mbsc-lv-item');

      if (!target || !cont0.contains(target)) {
        return;
      }

      if (ev.type === 'touchstart') {
        cont.removeClass('mbsc-no-touch');
        preventHover = true;
        clearTimeout(preventTimer);
      }

      if (testTouch(ev, target) && !action && !transition && !confirms && !undoing && mobiscroll.owfBP) {
        action = true;
        cancel = true;
        isClick = false;
        isTouch = ev.type === 'touchstart';
        startX = getCoord(ev, 'X');
        startY = getCoord(ev, 'Y');
        diffX = 0;
        diffY = 0;
        item = $$1(target);
        itm = item; // Local reference

        onActionStart();
        tapHighlight = type.actionable || item.hasClass('mbsc-lv-parent') || item.hasClass('mbsc-lv-back');
        itemTop = item.offset().top;

        if (tapHighlight) {
          activeTimer = setTimeout(function () {
            itm.addClass(isTouch ? ACTIVE_CLASS : '');
            event('onItemActivate', {
              target: itm[0],
              domEvent: ev
            });
          }, 120);
        }

        if (that.sortable && !item.hasClass('mbsc-lv-back')) {
          if (!that.sortable.group) {
            nextItems = item.nextUntil('.mbsc-lv-gr-title').filter('.mbsc-lv-item');
            prevItems = item.prevUntil('.mbsc-lv-gr-title').filter('.mbsc-lv-item');
          }

          minDrag = (!that.sortable.group ? prevItems.length ? prevItems.eq(-1) : item : currList.children(itemSelector).eq(0))[0].offsetTop - startTop;
          maxDrag = (!that.sortable.group ? nextItems.length ? nextItems.eq(-1) : item : currList.children(itemSelector).eq(-1))[0].offsetTop - startTop;

          if (that.sortable.handle) {
            if ($$1(ev.target).hasClass('mbsc-lv-handle')) {
              clearTimeout(activeTimer);
              timer = setTimeout(function () {
                onSortStart();
              }, 100);
            }
          } else {
            timer = setTimeout(function () {
              fill.appendTo(item);
              fill[0].style[jsPrefix + 'Animation'] = 'mbsc-lv-fill ' + (s.sortDelay - 100) + 'ms linear';
              clearTimeout(endTimer);
              clearTimeout(activeTimer);
              cancel = false;
              timer = setTimeout(function () {
                fill[0].style[jsPrefix + 'Animation'] = '';
                onSortStart();
              }, s.sortDelay - 80);
            }, 80);
          }
        }

        if (ev.type == 'mousedown') {
          $$1(document).on('mousemove', onMove).on('mouseup', onEnd);
        }
      }
    }

    function onMove(ev) {
      var sortChange = false,
          dropChange = true,
          prevPos = animPos;

      if (action) {
        endX = getCoord(ev, 'X');
        endY = getCoord(ev, 'Y');
        diffX = endX - startX;
        diffY = endY - startY;
        clearTimeout(endTimer);

        if (!dragged && !swipe && !scroll && !item.hasClass('mbsc-lv-back')) {
          if (Math.abs(diffY) > 10) {
            // It's a scroll
            scroll = true;
            onEnd(extend$1({}, ev, {
              type: ev.type == 'mousemove' ? 'mouseup' : 'touchend'
            }));
            clearTimeout(activeTimer);
          } else if (Math.abs(diffX) > 7) {
            // It's a swipe
            onSwipeStart();
          }
        }

        if (swipe) {
          ev.preventDefault();
          animPos = diffX / itemw * 100;
          onSwipeMove(prevPos);
        } else if (dragged) {
          ev.preventDefault();
          var scrolled,
              st = wnd.scrollTop(),
              diff = Math.max(minDrag, Math.min(diffY + wndScroll, maxDrag)),
              top = hasContext ? itemTop - wndTop + st - wndScroll : itemTop; // Check if scroll is needed

          if (wndHeight + st < top + diff + itemHeight) {
            wnd.scrollTop(top + diff - wndHeight + itemHeight);
            scrolled = true;
          } else if (top + diff < st) {
            wnd.scrollTop(top + diff);
            scrolled = true;
          } // Update scroll values if window was scrolled


          if (scrolled) {
            wndScroll += wnd.scrollTop() - st;
          } // Check overlap with next item


          if (nextOffset) {
            // If subtree exists, drop element on subtree at 1/4, change sort order at 3/4 overlap
            if (that.sortable.multiLevel && nextItem.hasClass('mbsc-lv-parent')) {
              if (startTop + itemHeight / 4 + diff > nextOffset) {
                sortChange = true;
              } else if (startTop + itemHeight - itemHeight / 4 + diff > nextOffset) {
                dropDown = nextItem.addClass('mbsc-lv-item-hl');
                dropChange = false;
              } // Check 1/2 overlap

            } else if (startTop + itemHeight / 2 + diff > nextOffset) {
              // If over back button, highlight to drop to parent level
              if (nextItem.hasClass('mbsc-lv-back')) {
                if (that.sortable.multiLevel) {
                  dropUp = nextItem.addClass('mbsc-lv-item-hl');
                  dropChange = false;
                }
              } else {
                sortChange = true;
              }
            }

            if (sortChange) {
              placeholder.insertAfter(nextItem);
              prevItem = nextItem;
              nextItem = getNextPrev(nextItem, 'next');
              prevOffset = nextOffset;
              nextOffset = nextItem.length && nextItem[0].offsetTop;
              currIndex++;
            }
          } // Check overlap with prev item


          if (!sortChange && prevOffset) {
            // If subtree exists, drop element on subtree at 1/3, change sort order at 2/3 overlap
            if (that.sortable.multiLevel && prevItem.hasClass('mbsc-lv-parent')) {
              if (startTop + itemHeight - itemHeight / 4 + diff < prevOffset) {
                sortChange = true;
              } else if (startTop + itemHeight / 4 + diff < prevOffset) {
                dropDown = prevItem.addClass('mbsc-lv-item-hl');
                dropChange = false;
              } // Check 1/2 overlap

            } else if (startTop + itemHeight / 2 + diff < prevOffset) {
              // If over back button, highlight to drop to parent level
              if (prevItem.hasClass('mbsc-lv-back')) {
                if (that.sortable.multiLevel) {
                  dropUp = prevItem.addClass('mbsc-lv-item-hl');
                  dropChange = false;
                }
              } else {
                sortChange = true;
              }
            }

            if (sortChange) {
              placeholder.insertBefore(prevItem);
              nextItem = prevItem;
              prevItem = getNextPrev(prevItem, 'prev');
              nextOffset = prevOffset;
              prevOffset = prevItem.length && prevItem[0].offsetTop + prevItem[0].offsetHeight;
              currIndex--;
            }
          }

          if (dropChange) {
            if (dropDown) {
              dropDown.removeClass('mbsc-lv-item-hl');
              dropDown = false;
            }

            if (dropUp) {
              dropUp.removeClass('mbsc-lv-item-hl');
              dropUp = false;
            }
          }

          if (sortChange) {
            event('onSortChange', {
              target: item[0],
              index: currIndex
            });
          }

          drag(item, diff);
          event('onSort', {
            target: item[0],
            index: currIndex
          });
        } else if (Math.abs(diffX) > 5 || Math.abs(diffY) > 5) {
          // Cancel dragstart if movement is > 5px
          stopTimer();
        }
      }
    }

    function onEnd(ev) {
      var dist,
          map,
          parent,
          itm = item;

      if (action) {
        action = false;
        stopTimer();

        if (ev.type == 'mouseup') {
          $$1(document).off('mousemove', onMove).off('mouseup', onEnd);
        }

        if (!scroll) {
          preventTimer = setTimeout(function () {
            preventHover = false;
          }, 300);
        }

        if (swipe || scroll || dragged) {
          prevClick = true;
        }

        if (swipe) {
          onSwipeEnd();
        } else if (dragged) {
          // Sort end
          parent = currList;

          if (dropDown) {
            resetItem(item.detach());
            map = treeMap[dropDown.attr('data-ref')];
            currIndex = getChildren(map.child).length;
            dropDown.removeClass('mbsc-lv-item-hl');

            if (s.navigateOnDrop) {
              navigate(dropDown, function () {
                that.add(null, item, null, null, dropDown, true);
                scrollToItem(item);
                onSortEnd(item, itemIndex, parent, true);
              });
            } else {
              that.add(null, item, null, null, dropDown, true);
              onSortEnd(item, itemIndex, parent, true);
            }
          } else if (dropUp) {
            resetItem(item.detach());
            map = treeMap[dropUp.attr('data-back')];
            currIndex = getChildren(map.parent).index(map.item) + 1;
            dropUp.removeClass('mbsc-lv-item-hl');

            if (s.navigateOnDrop) {
              navigate(dropUp, function () {
                that.add(null, item, currIndex, null, currList, true);
                scrollToItem(item);
                onSortEnd(item, itemIndex, parent, true);
              });
            } else {
              that.add(null, item, currIndex, null, map.parent, true);
              onSortEnd(item, itemIndex, parent, true);
            }
          } else {
            dist = placeholder[0].offsetTop - startTop; // Animate item to its place

            drag(item, dist, Math.abs(dist - Math.max(minDrag, Math.min(diffY + wndScroll, maxDrag))) * 6, function () {
              resetItem(item);
              item.insertBefore(placeholder);
              onSortEnd(item, itemIndex, parent, currIndex !== itemIndex);
            });
          }

          dragged = false;
        } else if (!scroll && Math.abs(diffX) < 5 && Math.abs(diffY) < 5) {
          // Tap
          isClick = true; // Trigger click and activate target, if it's a form control

          if (ev.type === 'touchend' && s.tap) {
            activateControl(ev.target, getControlType($$1(ev.target)), ev);
          }
        }

        clearTimeout(activeTimer);
        setTimeout(function () {
          itm.removeClass(ACTIVE_CLASS);
          event('onItemDeactivate', {
            target: itm[0]
          });
        }, 100);
        scroll = false;
        currStage = null;
      }
    }

    function onClick(ev) {
      var isSelected, ret;

      if (isClick) {
        isSelected = item.attr('data-selected') == 'true';

        if (type.tap) {
          ret = type.tap.call(e, {
            target: item,
            index: itemIndex,
            domEvent: ev
          }, that);
        }

        if (tapHighlight && !item.hasClass(ACTIVE_CLASS)) {
          item.addClass(isTouch ? ACTIVE_CLASS : '');
          event('onItemActivate', {
            target: item[0],
            domEvent: ev
          });
        } // select or deselect item on tap


        if (selectable) {
          if (multiple) {
            if (isSelected) {
              deselectItem(item);
            } else {
              selectItem(item);
            }
          } else {
            deselectItem($$1(itemSelector, cont).filter('.' + SELECTED_CLASS));
            selectItem(item);
          }
        }

        ret = event('onItemTap', {
          target: item[0],
          index: itemIndex,
          domEvent: ev,
          selected: isSelected
        });

        if (ret !== false) {
          navigate(item);
        }
      }
    }

    function onIconStart(ev) {
      var target = closest(cont0, ev.target, '.mbsc-lv-ic-m');

      if (!target) {
        return;
      }

      if (!demoMode) {
        ev.stopPropagation();
        ev.preventDefault();
      }

      startX = getCoord(ev, 'X');
      startY = getCoord(ev, 'Y');
    }

    function onSwipeStart() {
      swipe = valueOrFunc(type.swipe, {
        target: item[0],
        index: itemIndex,
        direction: diffX > 0 ? 'right' : 'left'
      });

      if (swipe) {
        stopTimer();
        clearTimeout(activeTimer);

        if (type.actions) {
          // Get the width of the action menu from settings
          // Numeric values are converted to string, because 0 is also accepted, we convert back to number at the end
          actionWidth = getActionWidth(type, diffX); // Show action icons and set width

          multic.html(type.icons).show().children().css('width', actionWidth + '%'); // Hide stage icons

          iconc.hide(); // Set disabled actions

          $$1('.mbsc-lv-ic-m', stagec).removeClass('mbsc-lv-ic-disabled');
          $$1(type.leftMenu).each(disableActions);
          $$1(type.rightMenu).each(disableActions);
        } else {
          iconc.show();
          multic.hide();
          currStageIdx = type.start;
          currStage = stages[currStageIdx];
          prevStage = stages[currStageIdx - 1];
          nextStage = stages[currStageIdx + 1];
        }

        item.addClass('mbsc-lv-item-swiping').removeClass(ACTIVE_CLASS);
        text.css('line-height', itemHeight + 'px');
        stagec.css({
          top: startTop,
          height: itemHeight,
          backgroundColor: getFirstColor(diffX)
        }).addClass('mbsc-lv-stage-c-v').appendTo(currList.parent());

        if (s.iconSlide) {
          item.append(iconc);
        }

        event('onSlideStart', {
          target: item[0],
          index: itemIndex
        });
      }
    }

    function onSwipeMove(prevPos) {
      var stageChanged = false;

      if (!rafRunning) {
        if (type.actions) {
          stagec.attr('class', 'mbsc-lv-stage-c-v mbsc-lv-stage-c mbsc-lv-' + (animPos < 0 ? 'right' : 'left'));
        } else {
          if (prevStage && (animPos < 0 ? animPos <= prevStage.percent : animPos < currStage.percent)) {
            currStageIdx--;
            nextStage = currStage;
            currStage = prevStage;
            prevStage = stages[currStageIdx - 1];
            stageChanged = true;
          } else if (nextStage && (animPos < 0 ? animPos > currStage.percent : animPos >= nextStage.percent)) {
            currStageIdx++;
            prevStage = currStage;
            currStage = nextStage;
            nextStage = stages[currStageIdx + 1];
            stageChanged = true;
          }

          if (currStage) {
            if (stageChanged || animPos > 0 == prevPos <= 0) {
              // Also need to update stage background if swipe direction changed
              setStageProps(currStage, s.iconSlide);
            }

            if (stageChanged) {
              event('onStageChange', {
                target: item[0],
                index: itemIndex,
                stage: currStage
              });
            }
          }
        }

        if (!simulating) {
          rafRunning = true;
          rafID = raf(slideMove);
        }
      }
    }

    function onSwipeEnd(callback) {
      function onCloseActions(ev) {
        var target = closest(cont0, ev.target, '.mbsc-lv-ic-m');

        if (!target) {
          ev.preventDefault();
          slideEnd(item, true, callback);
        }
      }

      var quickSwipeLeft,
          quickSwipeRight,
          timeDiff,
          itm = item[0],
          pending = false,
          revert = true;
      rafc(rafID);
      rafRunning = false; // We need an additional call to set the position in case when
      // requestAnimationFrame did not call it at least once
      // E.g. in a case of a quick swipe animation frame is
      // cancelled before the first call

      if (!simulating) {
        slideMove();
      }

      if (type.actions) {
        if (Math.abs(animPos) > 10 && actionWidth) {
          slide(item, animPos < 0 ? -actionWidth : actionWidth, 200);
          pending = true;
          confirms = true;
          confirmItem = item;
          confirmIndex = itemIndex;

          if (itm.__mbscOff) {
            itm.__mbscOff();
          }

          listen(document, 'touchstart', onCloseActions, {
            passive: false
          });
          listen(document, 'mousedown', onCloseActions);

          itm.__mbscOff = function () {
            unlisten(document, 'touchstart', onCloseActions, {
              passive: false
            });
            unlisten(document, 'mousedown', onCloseActions);
            delete itm.__mbscOff;
          };
        }
      } else if (animPos) {
        if (s.quickSwipe && !simulating) {
          timeDiff = new Date() - startTime;
          quickSwipeLeft = timeDiff < 300 && diffX < -50;
          quickSwipeRight = timeDiff < 300 && diffX > 50;

          if (quickSwipeLeft) {
            quickSwipe = true;
            currStage = type.left;
            setStageProps(currStage, s.iconSlide);
          } else if (quickSwipeRight) {
            quickSwipe = true;
            currStage = type.right;
            setStageProps(currStage, s.iconSlide);
          }
        }

        if (currStage && currStage.action) {
          disabled = valueOrFunc(currStage.disabled, {
            target: item[0],
            index: itemIndex
          });

          if (!disabled) {
            pending = true;
            confirms = simulating || valueOrFunc(currStage.confirm, {
              target: item[0],
              index: itemIndex
            });

            if (confirms) {
              // Slide to text + icon width
              slide(item, (animPos < 0 ? -1 : 1) * iconc[0].offsetWidth * 100 / itemw, 200, true); // Tap to confirm

              setConfirm(currStage, item, itemIndex, false, callback);
            } else {
              runAction(currStage, item, itemIndex, callback);
            }
          }
        }
      }

      if (!pending) {
        slideEnd(item, revert, callback);
      }

      swipe = false;
    }

    function onSortStart() {
      dragged = true;
      dropDown = false;
      dropUp = false;
      wndScroll = 0;
      currIndex = itemIndex;

      if (s.vibrate) {
        vibrate();
      }

      nextItem = getNextPrev(item, 'next');
      nextOffset = nextItem.length && nextItem[0].offsetTop;
      prevItem = getNextPrev(item, 'prev');
      prevOffset = prevItem.length && prevItem[0].offsetTop + prevItem[0].offsetHeight;
      placeholder.height(itemHeight).insertAfter(item); // Item is removed from original list, otherwise messes up striped layout

      item.css({
        top: startTop
      }).addClass('mbsc-lv-item-dragging').removeClass(ACTIVE_CLASS).appendTo(dummyCont);
      event('onSortStart', {
        target: item[0],
        index: currIndex
      });
    }

    function onSortEnd(item, itemIndex, parent, update) {
      item.removeClass('mbsc-lv-item-dragging');
      placeholder.remove();
      event('onSortEnd', {
        target: item[0],
        index: currIndex
      });

      if (s.vibrate) {
        vibrate();
      }

      if (update) {
        that.addUndoAction(function (next) {
          that.move(item, itemIndex, null, next, parent, true);
        }, true);
        event('onSortUpdate', {
          target: item[0],
          index: currIndex
        });
      }
    }

    function onMouseLeave() {
      if (!preventHover) {
        clearTimeout(hoverTimer);

        if (confirms) {
          trigger(document, 'touchstart');
        }

        if (hoverItemOpened) {
          that.close(hoverItem, hoverTime);
          hoverItemOpened = false;
          hoverItem = null;
        }
      }
    }

    function onResize() {
      clearTimeout(debounce);
      debounce = setTimeout(function () {
        wndHeight = wnd0.innerHeight || wnd.innerHeight();
        wndTop = hasContext ? wnd.offset().top : 0;

        if (action) {
          // Reposition stage background, icon and text
          startTop = item[0].offsetTop;
          itemHeight = item[0].offsetHeight;
          stagec.css({
            top: startTop,
            height: itemHeight
          });
        }
      }, 200);
    }

    function onListClick(ev) {
      if (prevClick) {
        ev.stopPropagation();
        ev.preventDefault();
        prevClick = false;
      }
    }

    function onScrollBottom() {
      if (!isLoading) {
        clearTimeout(onScrollDebounce);
        onScrollDebounce = setTimeout(function () {
          var height = hasContext ? wnd0.getBoundingClientRect().top + wnd.innerHeight() : window.innerHeight,
              reachedBottom = loading[0].getBoundingClientRect().top - 3 < height;

          if (!isLoading && reachedBottom) {
            event('onListEnd');
          }
        }, 250);
      }
    }

    function onScroll() {
      if (dragged || !action) {
        var group,
            st = wnd.scrollTop(),
            elmTop = elm.offset().top,
            elmHeight = elm[0].offsetHeight,
            wndTop = hasContext ? wnd.offset().top : st;
        $$1('.mbsc-lv-gr-title', elm).each(function (i, v) {
          if ($$1(v).offset().top < wndTop) {
            group = v;
          }
        });

        if (elmTop < wndTop && elmTop + elmHeight > wndTop) {
          groupHeader.show().empty().append($$1(group).clone());
        } else {
          groupHeader.hide();
        }
      }
    }

    function disableActions(i, v) {
      if (valueOrFunc(v.disabled, {
        target: item[0],
        index: itemIndex
      })) {
        $$1('.mbsc-ic-' + v.icon, stagec).addClass('mbsc-lv-ic-disabled');
      }
    }

    function runAction(stage, item, index, callback) {
      var revert,
          undoStage = {
        icon: 'undo2',
        text: s.undoText,
        action: function action() {
          that.undo();
        }
      };

      if (stage.undo) {
        that.startActionTrack(); // Add user defined undo

        if ($$1.isFunction(stage.undo)) {
          that.addUndoAction(function () {
            stage.undo.call(e, {
              target: item[0],
              index: index
            }, that);
          });
        } // Remember the item where the undo is displayed


        undoRef = item.attr('data-ref');
      }

      revert = stage.action.call(e, {
        target: item[0],
        index: index
      }, that);

      if (stage.undo) {
        that.endActionTrack();

        if (revert !== false) {
          slide(item, +item.attr('data-pos') < 0 ? -100 : 100, 200);
        }

        placeholder.height(itemHeight).insertAfter(item);
        item.css('top', startTop).addClass('mbsc-lv-item-undo');
        multic.hide();
        iconc.show();
        stagec.append(iconc);
        setStageProps(undoStage);
        setConfirm(undoStage, item, index, true, callback);
      } else {
        slideEnd(item, revert, callback);
      }
    }

    function setConfirm(stage, item, index, ph, callback) {
      function onActionCancel(ev) {
        ev.preventDefault();

        if (ph) {
          cleanUndo(item);
        }

        slideEnd(item, true, callback);
      }

      function onActionConfirmStart(ev) {
        ev.stopPropagation();
        startX = getCoord(ev, 'X');
        startY = getCoord(ev, 'Y');
      }

      function onActionConfirmEnd(ev) {
        ev.preventDefault();

        if (ev.type === 'touchend') {
          preventClick();
        } // If movement is less than 10px, it's a tap


        if (Math.abs(getCoord(ev, 'X') - startX) < 10 && Math.abs(getCoord(ev, 'Y') - startY) < 10) {
          runAction(stage, item, index, callback);

          if (ph) {
            undoAnim = null;
            cleanUndo(item);
          }
        }
      }

      var startX,
          startY,
          itm = item[0];
      confirms = true;

      if (itm.__mbscOff) {
        itm.__mbscOff();
      }

      listen(document, 'touchstart', onActionCancel, {
        passive: false
      });
      listen(document, 'mousedown', onActionCancel);

      if (!demoMode) {
        listen(iconc[0], 'touchstart', onActionConfirmStart, {
          passive: true
        });
        listen(iconc[0], 'mousedown', onActionConfirmStart);
        listen(iconc[0], 'touchend', onActionConfirmEnd);
        listen(iconc[0], 'mouseup', onActionConfirmEnd);
      }

      itm.__mbscOff = function () {
        unlisten(document, 'touchstart', onActionCancel, {
          passive: false
        });
        unlisten(document, 'mousedown', onActionCancel);
        unlisten(iconc[0], 'touchstart', onActionConfirmStart, {
          passive: true
        });
        unlisten(iconc[0], 'mousedown', onActionConfirmStart);
        unlisten(iconc[0], 'touchend', onActionConfirmEnd);
        unlisten(iconc[0], 'mouseup', onActionConfirmEnd);
        delete itm.__mbscOff;
      };
    }

    function slideMove() {
      slide(item, startPos + diffX * 100 / itemw);
      rafRunning = false;
    }

    function slideEnd(item, revert, callback) {
      if (item[0].__mbscOff) {
        item[0].__mbscOff();
      }

      if (revert !== false) {
        slide(item, 0, item.attr('data-pos') !== '0' ? 200 : 0, false, function () {
          cleanStage(item, callback);
          resetItem(item);
        });
      } else {
        cleanStage(item, callback);
      }

      confirms = false;
    }

    function slide(item, pos, time, px, callback) {
      pos = Math.max(swipe == 'right' ? 0 : -100, Math.min(pos, swipe == 'left' ? 0 : 100));
      style = item[0].style;
      item.attr('data-pos', pos);
      style[jsPrefix + 'Transform'] = 'translate3d(' + (px ? itemw * pos / 100 + 'px' : pos + '%') + ',0,0)';
      style[jsPrefix + 'Transition'] = cssPrefix + 'transform ' + (time || 0) + 'ms';

      if (callback) {
        transition++;
        setTimeout(function () {
          callback();
          transition--;
        }, time);
      }

      animPos = pos;
    }

    function drag(item, top, time, callback) {
      top = Math.max(minDrag, Math.min(top, maxDrag));
      style = item[0].style;
      style[jsPrefix + 'Transform'] = 'translate3d(0,' + top + 'px,0)';
      style[jsPrefix + 'Transition'] = cssPrefix + 'transform ' + (time || 0) + 'ms ease-out';

      if (callback) {
        transition++;
        setTimeout(function () {
          callback();
          transition--;
        }, time);
      }
    }

    function stopTimer() {
      clearTimeout(timer);

      if (!cancel && that.sortable) {
        cancel = true;
        fill.remove();
      }
    }

    function setStageProps(stage, iconSlide) {
      var txt = valueOrFunc(stage.text, {
        target: item[0],
        index: itemIndex
      }) || '';

      if (valueOrFunc(stage.disabled, {
        target: item[0],
        index: itemIndex
      })) {
        stagec.addClass('mbsc-lv-ic-disabled');
      } else {
        stagec.removeClass('mbsc-lv-ic-disabled');
      }

      stagec.css('background-color', stage.color || (stage.percent === 0 ? getFirstColor(animPos) : transp));
      iconc.attr('class', 'mbsc-lv-ic-c mbsc-lv-ic-' + (iconSlide ? 'move-' : '') + (animPos < 0 ? 'right' : 'left'));
      icon.attr('class', ' mbsc-lv-ic-s mbsc-lv-ic mbsc-ic mbsc-ic-' + (stage.icon || 'none'));
      text.attr('class', 'mbsc-lv-ic-text' + (stage.icon ? '' : ' mbsc-lv-ic-text-only') + (txt ? '' : ' mbsc-lv-ic-only')).html(txt || '&nbsp;');

      if (s.animateIcons) {
        if (quickSwipe) {
          icon.addClass('mbsc-lv-ic-v');
        } else {
          setTimeout(function () {
            icon.addClass('mbsc-lv-ic-a');
          }, 10);
        }
      }
    }

    function cleanStage(item, callback) {
      if (!action) {
        // Don't clean stages if another action started
        icon.attr('class', 'mbsc-lv-ic-s mbsc-lv-ic mbsc-ic mbsc-ic-none');
        stagec.attr('style', '').removeClass('mbsc-lv-stage-c-v');
        text.html('');
      }

      stagec.removeClass('mbsc-lv-left mbsc-lv-right');

      if (item) {
        event('onSlideEnd', {
          target: item[0],
          index: itemIndex
        });

        if (callback) {
          callback();
        }
      }
    }

    function cleanUndo(item) {
      item.css('top', '').removeClass('mbsc-lv-item-undo'); // Remove placeholder

      if (undoAnim) {
        that.animate(placeholder, 'collapse', function () {
          placeholder.remove();
        });
      } else {
        placeholder.remove();
      }

      cleanStage();
      undoRef = null;
      undoAnim = null;
    }

    function resetItem(item) {
      style = item[0].style;
      style[jsPrefix + 'Transform'] = '';
      style[jsPrefix + 'Transition'] = '';
      style.top = '';
      item.removeClass('mbsc-lv-item-swiping');
    }

    function valueOrFunc(val, args) {
      return $$1.isFunction(val) ? val.call(this, args, that) : val;
    }

    function isSelectable(item) {
      return selectable && !item.hasClass('mbsc-lv-parent') && !item.hasClass('mbsc-lv-back');
    }

    function initItem(item) {
      var id = item.attr('data-ref'),
          role = item.attr('data-role'),
          type = types[item.attr('data-type') || 'defaults'],
          selected = isSelectable(item) && item.attr('data-selected') == 'true';

      if (!id) {
        id = guid++;
        item.attr('data-ref', id);
      }

      treeMap[id] = {
        item: item,
        child: item.children(listSelector),
        parent: item.parent(),
        ref: item.parent()[0] === e ? null : item.parent().parent().attr('data-ref')
      };
      item.addClass(role == 'list-divider' ? 'mbsc-lv-gr-title' : 'mbsc-lv-item' + (type.actionable ? ' mbsc-lv-item-actionable' : '') + (selected ? ' ' + SELECTED_CLASS : ''));
      item.attr('aria-selected', selected ? 'true' : 'false'); // Add sort handle

      if (that.sortable.handle && role != 'list-divider' && !item.children('.mbsc-lv-handle-c').length) {
        item.append(handleDiv);
      }

      if (s.enhance && !item.hasClass('mbsc-lv-item-enhanced')) {
        var itemIcon = item.attr('data-icon'),
            itemImg = item.find('img').eq(0).addClass('mbsc-lv-img');

        if (itemImg.is(':first-child')) {
          item.addClass('mbsc-lv-img-' + (s.rtl ? 'right' : 'left'));
        } else if (itemImg.length) {
          item.addClass('mbsc-lv-img-' + (s.rtl ? 'left' : 'right'));
        }

        item.addClass('mbsc-lv-item-enhanced').children().each(function (i, v) {
          v = $$1(v);

          if (v.is('p, h1, h2, h3, h4, h5, h6')) {
            v.addClass('mbsc-lv-txt');
          }
        });

        if (itemIcon) {
          item.addClass('mbsc-lv-item-ic-' + (item.attr('data-icon-align') || (s.rtl ? 'right' : 'left'))).append('<div class="mbsc-lv-item-ic mbsc-ic mbsc-ic-' + itemIcon + '"></div>');
        }
      }

      item.append(that._getText(mobiscroll, 0.2));
    }

    function initBranch(elm) {
      // Create map object
      $$1(itemSelector, elm).not('.mbsc-lv-back').each(function () {
        initItem($$1(this));
      }); // Add extra classes and markup (arrows and back items)

      $$1(listSelector, elm).not('.mbsc-lv').addClass('mbsc-lv').prepend(htmlLeft).parent().addClass('mbsc-lv-parent mbsc-lv-item-actionable').prepend(htmlRight); // Add parent reference for back buttons

      $$1('.mbsc-lv-back', elm).each(function () {
        $$1(this).attr('data-back', $$1(this).parent().parent().attr('data-ref'));
      });
    }

    function getChildren(list) {
      return list.children(itemSelector).not('.mbsc-lv-back').not('.mbsc-lv-removed').not('.mbsc-lv-ph');
    }

    function getItemByID(item) {
      if (typeof item !== 'object') {
        item = $$1(itemSelector, cont).filter('[data-id="' + item + '"]');
      }

      return $$1(item);
    }

    function getItemLevel(item) {
      var level = 0,
          map = treeMap[item.attr('data-ref')];

      while (map && map.ref) {
        level++;
        map = treeMap[map.ref];
      }

      return level;
    }

    function getNextPrev(item, dir) {
      item = item[dir](); // Returns next or previous item filtering out placeholder or currently dragged element

      while (item.length && (!item.hasClass('mbsc-lv-item') || item.hasClass('mbsc-lv-ph') || item.hasClass('mbsc-lv-item-dragging'))) {
        if (!that.sortable.group && item.hasClass('mbsc-lv-gr-title')) {
          return false;
        }

        item = item[dir]();
      }

      return item;
    }

    function getFirstColor(pos) {
      return (pos > 0 ? type.right : type.left).color || transp;
    }

    function getNumStr(s) {
      return isNumeric(s) ? s + '' : 0;
    }

    function getActionWidth(type, diffX) {
      return +(diffX < 0 ? getNumStr((type.actionsWidth || 0).right) || getNumStr(type.actionsWidth) || getNumStr(s.actionsWidth.right) || getNumStr(s.actionsWidth) : getNumStr((type.actionsWidth || 0).left) || getNumStr(type.actionsWidth) || getNumStr(s.actionsWidth.left) || getNumStr(s.actionsWidth));
    }

    function scrollToItem(item, scrollToTop) {
      if (item) {
        var scrollTop = wnd.scrollTop(),
            itemHeight = item.is('.mbsc-lv-item') ? item[0].offsetHeight : 0,
            itemTop = item.offset().top + (hasContext ? scrollTop - wndTop : 0);

        if (scrollToTop) {
          if (itemTop < scrollTop || itemTop + itemHeight > scrollTop + wndHeight) {
            wnd.scrollTop(itemTop);
          }
        } else {
          if (itemTop < scrollTop) {
            wnd.scrollTop(itemTop);
          } else if (itemTop + itemHeight > scrollTop + wndHeight) {
            wnd.scrollTop(Math.min(itemTop, itemTop + itemHeight - wndHeight / 2));
          }
        }
      }
    }

    function drill(dir, list, item, callback, scrollToTop) {
      var parent = list.parent(),
          ph = list.prev();
      callback = callback || noop;

      if (ph[0] === iconc[0]) {
        ph = iconc.prev();
      }

      if (s.rtl) {
        dir = dir === 'l' ? 'r' : 'l';
      }

      if (currList[0] !== list[0]) {
        event('onNavStart', {
          level: slideLevel,
          direction: dir,
          list: list[0]
        });
        slideCont.prepend(list.addClass('mbsc-lv-v mbsc-lv-sl-new')); // If top of the list is not visible, scroll to top

        scrollToItem(cont);
        animate(slideCont, 'mbsc-lv-sl-' + dir, function () {
          currList.removeClass('mbsc-lv-sl-curr');
          list.removeClass('mbsc-lv-sl-new').addClass('mbsc-lv-sl-curr');

          if (currPh && currPh.length) {
            currList.removeClass('mbsc-lv-v').insertAfter(currPh);
          } else {
            currParent.append(currList.removeClass('mbsc-lv-v'));
          } // Remember the previous element where we need to put back the list later
          // We need this because some frameworks like ember js put additional elements (script tags)
          // and appending to parent element is not ok


          currPh = ph;
          currParent = parent;
          currList = list;
          scrollToItem(item, scrollToTop);
          callback.call(e, item);
          event('onNavEnd', {
            level: slideLevel,
            direction: dir,
            list: list[0]
          });
        });
      } else {
        scrollToItem(item, scrollToTop);
        callback.call(e, item);
      }
    }

    function navigate(item, callback) {
      if (!transition) {
        if (item.hasClass('mbsc-lv-parent')) {
          slideLevel++;
          drill('r', treeMap[item.attr('data-ref')].child, null, callback);
        } else if (item.hasClass('mbsc-lv-back')) {
          slideLevel--;
          drill('l', treeMap[item.attr('data-back')].parent, treeMap[item.attr('data-back')].item, callback);
        }
      }
    }

    function animate(el, anim, callback) {
      var timer;

      function onAnimEnd() {
        clearTimeout(timer);
        transition--;
        el.off(animEnd, onAnimEnd).removeClass(anim);
        callback.call(e, el);
      }

      callback = callback || noop;

      if (s.animation && anim !== 'mbsc-lv-item-none') {
        transition++;
        el.on(animEnd, onAnimEnd).addClass(anim); // animEnd event will not execute with some integration plugins, this is a workaround to make sure it's executed

        timer = setTimeout(onAnimEnd, 250);
      } else {
        callback.call(e, el);
      }
    }

    function doAction(el, action) {
      var queue,
          id = el.attr('data-ref');
      queue = actionQueue[id] = actionQueue[id] || [];

      if (action) {
        queue.push(action);
      }

      if (el.attr('data-action')) {
        return;
      }

      action = queue.shift(); // Check this for safety
      // There was a case in angular were the data-ref attribute was lost,
      // so the queue was empty

      if (action) {
        el.attr('data-action', 1);
        action(function () {
          el.removeAttr('data-action');

          if (queue.length) {
            doAction(el);
          } else {
            delete actionQueue[id];
          }
        });
      }
    }

    function processStages(stages, dir, duplicate) {
      var count, temp;

      if (stages && stages.length) {
        count = 100 / (stages.length + 2);
        $$1.each(stages, function (i, stage) {
          if (stage.key === undefined) {
            stage.key = stageNr++;
          }

          if (stage.percent === undefined) {
            // if no percent passed then generate to both sides
            stage.percent = dir * count * (i + 1);

            if (duplicate) {
              temp = extend$1({}, stage);
              temp.key = stageNr++;
              temp.percent = -count * (i + 1);
              stages.push(temp);
              stageObj[temp.key] = temp;
            }
          }

          stageObj[stage.key] = stage;
        });
      }
    }

    function selectItem($item) {
      if (isSelectable($item)) {
        $item.addClass(SELECTED_CLASS).attr('data-selected', 'true').attr('aria-selected', 'true');
      }
    }

    function deselectItem($item) {
      $item.removeClass(SELECTED_CLASS).removeAttr('data-selected').removeAttr('aria-selected');
    } // Call the parent constructor


    Base.call(this, elem, settings, true);
    /**
     * Animate a list item
     */

    that.animate = function (li, anim, callback) {
      animate(li, 'mbsc-lv-item-' + anim, callback);
    };
    /**
     * Add a new list item
     */


    that.add = function (id, markup, index, callback, p, isUndo) {
      var backBtn,
          length,
          siblings,
          sublevel,
          map,
          pref,
          cssClass = '',
          $parent = p === undefined ? elm : getItemByID(p),
          $list = $parent,
          $item = typeof markup !== 'object' ? $$1('<' + itemNode + ' data-ref="' + guid++ + '" data-id="' + id + '">' + markup + '</' + itemNode + '>') : $$1(markup),
          item = $item[0],
          style = item.style,
          dir = $item.attr('data-pos') < 0 ? 'left' : 'right',
          ref = $item.attr('data-ref');
      callback = callback || noop;

      if (!ref) {
        ref = guid++;
        $item.attr('data-ref', ref);
      }

      initItem($item); // Put action in undo stack

      if (!isUndo) {
        that.addUndoAction(function (next) {
          if (sublevel) {
            that.navigate($parent, function () {
              $list.remove();
              $parent.removeClass('mbsc-lv-parent').children('.mbsc-lv-arr').remove();
              map.child = $parent.children(listSelector);
              that.remove($item, null, next, true);
            });
          } else {
            that.remove($item, null, next, true);
          }
        }, true);
      }

      doAction($item, function (next) {
        resetItem($item.css('top', '').removeClass('mbsc-lv-item-undo')); // If parent is a list item, insert new element in the sublist

        if ($parent.is(itemSelector)) {
          pref = $parent.attr('data-ref'); // If there is no sublist yet, create it

          if (!$parent.children(listSelector).length) {
            sublevel = true;
            $parent.append('<' + listNode + '></' + listNode + '>');
          }
        } else {
          pref = $parent.children('.mbsc-lv-back').attr('data-back');
        }

        map = treeMap[pref];

        if (map) {
          if (!map.child.length) {
            $parent.addClass('mbsc-lv-parent').prepend(htmlRight); // Set parent to be the sublist

            $list = $parent.children(listSelector).prepend(htmlLeft).addClass('mbsc-lv');
            map.child = $list;
            $$1('.mbsc-lv-back', $parent).attr('data-back', pref);
          } else {
            $list = map.child;
          }
        }

        treeMap[ref] = {
          item: $item,
          child: $item.children(listSelector),
          parent: $list,
          ref: pref
        };
        siblings = getChildren($list);
        length = siblings.length;

        if (index === undefined || index === null) {
          index = length;
        }

        if (isUndo) {
          cssClass = 'mbsc-lv-item-new-' + (isUndo ? dir : '');
        }

        initBranch($item.addClass(cssClass));

        if (index !== false) {
          if (!length) {
            backBtn = $$1('.mbsc-lv-back', $list);

            if (backBtn.length) {
              $item.insertAfter(backBtn);
            } else {
              $list.append($item);
            }
          } else if (index < length) {
            $item.insertBefore(siblings.eq(index));
          } else {
            $item.insertAfter(siblings.eq(length - 1));
          }
        }

        cont.trigger('mbsc-refresh'); // If current level is visible

        if (s.animateAddRemove && $list.hasClass('mbsc-lv-v')) {
          // Don't run expand animation if add is running on the "undo" element
          style.height = item.offsetHeight + 'px';
          that.animate($item, isUndo && undoRef === ref ? 'none' : 'expand', function ($item) {
            that.animate($item, isUndo ? 'add-' + dir : 'pop-in', function ($item) {
              style.height = '';
              callback.call(e, $item.removeClass(cssClass));
              next();
            });
          });
        } else {
          callback.call(e, $item.removeClass(cssClass));
          next();
        }

        event('onItemAdd', {
          target: item
        });
      });
    };
    /**
     * Swipe a list item programatically
     */


    that.swipe = function (li, percent, time, demo, callback) {
      var prevPos;
      li = getItemByID(li);
      item = li;
      demoMode = demo;
      simulating = true;
      action = true;
      time = time === undefined ? 300 : time;
      diffX = percent > 0 ? 1 : -1;
      onActionStart();
      onSwipeStart();
      slide(li, percent, time);
      clearTimeout(swipeTimeout);
      clearInterval(swipeInterval);
      swipeInterval = setInterval(function () {
        prevPos = animPos;
        animPos = getPosition(li) / itemw * 100;
        onSwipeMove(prevPos);
      }, 10);
      swipeTimeout = setTimeout(function () {
        clearInterval(swipeInterval);
        prevPos = animPos;
        animPos = percent; // We need one additional move with the final percent to get the correct stage

        onSwipeMove(prevPos);
        onSwipeEnd(callback);
        demoMode = false;
        simulating = false;
        action = false;
      }, time);
    };

    that.openStage = function (li, stage, time, demo) {
      if (stageObj[stage]) {
        that.swipe(li, stageObj[stage].percent, time, demo);
      }
    };

    that.openActions = function (li, dir, time, demo) {
      li = getItemByID(li);
      var percent = getActionWidth(types[li.attr('data-type') || 'defaults'], dir == 'left' ? -1 : 1);
      that.swipe(li, dir == 'left' ? -percent : percent, time, demo);
    };

    that.close = function (li, time) {
      that.swipe(li, 0, time);
    };
    /**
     * Remove a list item
     */


    that.remove = function (id, dir, callback, isUndo) {
      var $item, $parent, anim, index, ref, shouldNavigate, style;

      function deleteSubTree($child) {
        if ($child) {
          shouldNavigate = shouldNavigate || $child.hasClass('mbsc-lv-v');
          $child.children('[data-ref]').each(function () {
            var ref = $$1(this).attr('data-ref');

            if (treeMap[ref]) {
              deleteSubTree(treeMap[ref].child);
              delete treeMap[ref];
            }
          });
        }
      }

      callback = callback || noop;
      $item = getItemByID(id);
      ref = $item.attr('data-ref');

      if ($item.length && treeMap[ref]) {
        $parent = $item.parent();
        index = getChildren($parent).index($item);
        style = $item[0].style;
        deleteSubTree(treeMap[ref].child);

        if (shouldNavigate) {
          anim = s.animation;
          s.animation = false;
          that.navigate($item);
          s.animation = anim;
        }

        delete treeMap[ref]; // Put action in undo stack

        if (!isUndo) {
          // If undo element is removed, undo placeholder should be removed with animation
          if ($item.attr('data-ref') === undoRef) {
            undoAnim = true;
          }

          that.addUndoAction(function (next) {
            that.add(null, $item, index, next, $parent, true);
          }, true);
        }

        doAction($item, function (next) {
          dir = dir || ($item.attr('data-pos') < 0 ? 'left' : 'right');

          if (s.animateAddRemove && $parent.hasClass('mbsc-lv-v')) {
            that.animate($item.addClass('mbsc-lv-removed'), isUndo ? 'pop-out' : 'remove-' + dir, function ($item) {
              style.height = $item[0].offsetHeight + 'px';
              that.animate($item, 'collapse', function ($item) {
                style.height = '';
                resetItem($item.removeClass('mbsc-lv-removed'));

                if (callback.call(e, $item) !== false) {
                  $item.remove();
                }

                next();
              });
            });
          } else {
            if (callback.call(e, $item) !== false) {
              $item.remove();
            }

            next();
          }

          event('onItemRemove', {
            target: $item[0]
          });
        });
      }
    };
    /**
     * Moves an item in the list
     */


    that.move = function (li, index, dir, callback, p, isUndo) {
      li = getItemByID(li); //if (getChildren(li.parent()).index(li) !== index) {

      if (!isUndo) {
        that.startActionTrack();
      }

      stagec.append(iconc);
      that.remove(li, dir, null, isUndo);
      that.add(null, li, index, callback, p, isUndo);

      if (!isUndo) {
        that.endActionTrack();
      } //}

    };
    /**
     * Navigate and scroll to the given element
     */


    that.navigate = function (item, callback) {
      var map, level;
      item = getItemByID(item);
      map = treeMap[item.attr('data-ref')];
      level = getItemLevel(item);

      if (map) {
        drill(level >= slideLevel ? 'r' : 'l', map.parent, item, callback, true);
        slideLevel = level;
      }
    };

    that.showLoading = function () {
      isLoading = true;
      loading.addClass('mbsc-show-lv-loading');
      wnd.scrollTop(hasContext ? wnd0.scrollHeight : $$1(s.context)[0].scrollHeight);
    };

    that.hideLoading = function () {
      loading.removeClass('mbsc-show-lv-loading'); // Needs timeout to prevent triggering 
      // the onListEnd event from the scroll listener

      setTimeout(function () {
        isLoading = false;
      }, 100);
    };

    that.select = function (item) {
      if (!multiple) {
        deselectItem($$1(itemSelector, cont).filter('.' + SELECTED_CLASS));
      }

      selectItem(getItemByID(item));
    };

    that.deselect = function (item) {
      deselectItem(getItemByID(item));
    };

    that._processSettings = function () {
      if (elm.is('[mbsc-enhance]')) {
        hadEnhance = true;
        elm.removeAttr('mbsc-enhance');
      }
    };
    /**
     * Listview initialization.
     */


    that._init = function () {
      var contClass,
          headerClass,
          sortable,
          //defSortHandle = elm.find(listSelector).length ? 'left' : 'right',
      i = 0,
          icons = '',
          iconsLeft = '',
          iconsRight = '';
      listNode = s.listNode;
      listSelector = s.listSelector;
      itemNode = s.itemNode;
      itemSelector = s.itemSelector;
      multiple = s.select == 'multiple';
      selectable = s.select != 'off';
      /*
      sortable = s.sort || s.sortable || false;
        // Backward compatiblity for 'group' and sortHandle settings
      // ---
      if (sortable === 'group') {
          sortable = {
              group: false,
              multiLevel: true
          };
      }
        if (sortable === true) {
          sortable = {
              group: true,
              multiLevel: true,
              handle: s.sortHandle
          };
      }
        if (sortable && sortable.handle === undefined) {
          sortable.handle = s.sortHandle;
      }
      // ---
        if (sortable.handle) {
          handlePos = sortable.handle === true ? defSortHandle : sortable.handle;
          handleDiv = '<div class="mbsc-lv-handle-c mbsc-lv-item-h-' + handlePos + ' mbsc-lv-handle"><div class="' + s.handleClass + ' mbsc-lv-handle-bar-c mbsc-lv-handle">' + s.handleMarkup + '</div></div>';
      }
        htmlLeft = '<' + itemNode + ' class="mbsc-lv-item mbsc-lv-back mbsc-lv-item-actionable">' + s.backText + '<div class="mbsc-lv-arr mbsc-lv-ic mbsc-ic ' + s.leftArrowClass + '"></div></' + itemNode + '>';
      htmlRight = '<div class="mbsc-lv-arr mbsc-lv-ic mbsc-ic ' + s.rightArrowClass + '"></div>';
        contClass = 'mbsc-no-touch mbsc-lv-cont mbsc-lv-' + s.theme + ' mbsc-' + s.theme +
          (halfBorder ? ' mbsc-lv-hb' : '') +
          (s.rtl ? ' mbsc-lv-rtl mbsc-rtl' : ' mbsc-ltr') +
          (s.baseTheme ? ' mbsc-lv-' + s.baseTheme + ' mbsc-' + s.baseTheme : '') +
          (s.animateIcons ? ' mbsc-lv-ic-anim' : '') +
          (s.striped ? ' mbsc-lv-alt-row' : '') +
          (s.fixedHeader ? ' mbsc-lv-has-fixed-header' : '') +
          (sortable.handle ? ' mbsc-lv-handle-' + handlePos : '');
      */
      // --- TRIAL SERVER CODE START ---

      sortable = that.remote.listview.sortable;
      handlePos = that.remote.listview.handlePos;
      handleDiv = that.remote.listview.handleDiv;
      htmlLeft = that.remote.listview.htmlLeft;
      htmlRight = that.remote.listview.htmlRight;
      contClass = that.remote.listview.contClass; // --- TRIAL SERVER CODE END ---

      that.sortable = sortable || false;

      if (!cont) {
        // Icon menu container
        icons += '<div class="mbsc-lv-multi-c"></div>'; // Stage icons container

        icons += '<div class="mbsc-lv-ic-c"><div class="mbsc-lv-ic-s mbsc-lv-ic mbsc-ic mbsc-ic-none"></div><div class="mbsc-lv-ic-text"></div></div>'; // Add classes

        elm.addClass('mbsc-lv mbsc-lv-v mbsc-lv-root').removeClass('mbsc-cloak').show();
        stagec = $$1('<div class="mbsc-lv-stage-c">' + icons + '</div>');
        iconc = $$1('.mbsc-lv-ic-c', stagec);
        multic = $$1('.mbsc-lv-multi-c', stagec);
        icon = $$1('.mbsc-lv-ic-s', stagec);
        text = $$1('.mbsc-lv-ic-text', stagec);
        placeholder = $$1('<' + itemNode + ' class="mbsc-lv-item mbsc-lv-ph"></' + itemNode + '>');
        fill = $$1('<div class="mbsc-lv-fill-item"></div>');
        cont = $$1('<div class="' + contClass + '"><' + listNode + ' class="mbsc-lv mbsc-lv-dummy"></' + listNode + '><div class="mbsc-lv-sl-c"></div>' + '<div class="mbsc-lv-loading"><span class="mbsc-ic mbsc-ic-' + (s.loadingIcon || 'loop2') + '"></span></div></div>');
        cont0 = cont[0];
        dummyCont = $$1('.mbsc-lv-dummy', cont);
        loading = $$1('.mbsc-lv-loading', cont);
        cont.insertAfter(elm);
        onResize(); // Slide events

        listen(cont0, 'mousedown', onStart);
        listen(cont0, 'touchstart', onStart, {
          passive: true
        });
        listen(document, 'touchmove', onMove, {
          passive: false
        });
        cont.on('touchend touchcancel', '.mbsc-lv-item', onEnd).on('click', '.mbsc-lv-item', onClick); // Prevent click on swipe

        listen(e, 'click', onListClick, true); // Init action icons
        // ---

        listen(cont0, 'mousedown', onIconStart);
        listen(document, 'touchstart', onIconStart, {
          passive: false
        });
        cont.on('touchend mouseup', '.mbsc-lv-ic-m', function (ev) {
          if (!demoMode) {
            if (ev.type === 'touchend') {
              preventClick();
            } // If movement is less than 10px, fire the click event handler


            if (confirms && !$$1(this).hasClass('mbsc-lv-ic-disabled') && Math.abs(getCoord(ev, 'X') - startX) < 10 && Math.abs(getCoord(ev, 'Y') - startY) < 10) {
              runAction((animPos < 0 ? type.rightMenu : type.leftMenu)[$$1(this).index()], confirmItem, confirmIndex);
            }
          }
        }); // ---
        // Init hierarchical navigation
        // ---

        slideCont = $$1('.mbsc-lv-sl-c', cont).append(elm.addClass('mbsc-lv-sl-curr')).attr('data-ref', guid++);
        currList = elm;
        currParent = cont; // ---
      } else {
        cont.attr('class', contClass); // reinit sort handles

        $$1('.mbsc-lv-handle-c', cont).remove(); // remove to reinit list items

        $$1(itemSelector, cont).not('.mbsc-lv-back').removeClass('mbsc-lv-item');
        unlisten(wnd0, 'orientationchange', onResize);
        unlisten(wnd0, 'resize', onResize);
        unlisten(wnd0, 'scroll', onScrollBottom);
        unlisten(wnd0, 'touchmove', onScrollBottom, {
          passive: true
        });

        if (onScrollThrottle) {
          unlisten(wnd0, 'scroll', onScrollThrottle);
          unlisten(wnd0, 'touchmove', onScrollThrottle, {
            passive: true
          });
        }
      }

      hasContext = s.context !== 'body';
      wnd = $$1(hasContext ? s.context : window);
      wnd0 = wnd[0]; // Recalculate sizes on resize / orientationchange

      listen(wnd0, 'orientationchange', onResize);
      listen(wnd0, 'resize', onResize);
      listen(wnd0, 'scroll', onScrollBottom);
      listen(wnd0, 'touchmove', onScrollBottom, {
        passive: true
      }); // Init stages and actions
      // ---

      stageNr = 0;
      types = s.itemGroups || {};
      types.defaults = {
        swipeleft: s.swipeleft,
        swiperight: s.swiperight,
        stages: s.stages,
        actions: s.actions,
        actionsWidth: s.actionsWidth,
        actionable: s.actionable
      };
      initBranch(elm);
      $$1.each(types, function (n, v) {
        v.swipe = v.swipe !== undefined ? v.swipe : s.swipe;
        v.actionable = v.actionable !== undefined ? v.actionable : s.actionable;
        v.stages = v.stages || []; // Init stages

        processStages(v.stages, 1, true);
        processStages(v.stages.left, 1);
        processStages(v.stages.right, -1);

        if (v.stages.left || v.stages.right) {
          v.stages = [].concat(v.stages.left || [], v.stages.right || []);
        }

        found = false;

        if (!v.stages.length) {
          if (v.swipeleft) {
            v.stages.push({
              percent: -30,
              action: v.swipeleft
            });
          }

          if (v.swiperight) {
            v.stages.push({
              percent: 30,
              action: v.swiperight
            });
          }
        }

        $$1.each(v.stages, function (i, v) {
          // find the 0
          if (v.percent === 0) {
            found = true;
            return false;
          }
        });

        if (!found) {
          v.stages.push({
            percent: 0
          });
        }

        v.stages.sort(function (a, b) {
          return a.percent - b.percent;
        });
        $$1.each(v.stages, function (i, s) {
          // find the 0
          if (s.percent === 0) {
            v.start = i;
            return false;
          }
        });

        if (found) {
          v.left = v.right = v.stages[v.start];
        } else {
          v.left = v.stages[v.start - 1] || {};
          v.right = v.stages[v.start + 1] || {};
        } // Init actions


        if (v.actions) {
          v.leftMenu = v.actions.left || v.actions;
          v.rightMenu = v.actions.right || v.leftMenu;
          iconsLeft = '';
          iconsRight = '';

          for (i = 0; i < v.leftMenu.length; i++) {
            iconsLeft += '<div ' + (v.leftMenu[i].color ? 'style="background-color: ' + v.leftMenu[i].color + '"' : '') + ' class="mbsc-lv-ic-m mbsc-lv-ic mbsc-ic mbsc-ic-' + v.leftMenu[i].icon + '">' + (v.leftMenu[i].text || '') + '</div>';
          }

          for (i = 0; i < v.rightMenu.length; ++i) {
            iconsRight += '<div ' + (v.rightMenu[i].color ? 'style="background-color: ' + v.rightMenu[i].color + '"' : '') + ' class="mbsc-lv-ic-m mbsc-lv-ic mbsc-ic mbsc-ic-' + v.rightMenu[i].icon + '">' + (v.rightMenu[i].text || '') + '</div>';
          }

          if (v.actions.left) {
            v.swipe = v.actions.right ? v.swipe : 'right';
          }

          if (v.actions.right) {
            v.swipe = v.actions.left ? v.swipe : 'left';
          }

          v.icons = '<div class="mbsc-lv-multi mbsc-lv-multi-ic-left">' + iconsLeft + '</div><div class="mbsc-lv-multi mbsc-lv-multi-ic-right">' + iconsRight + '</div>';
        }
      }); // ---
      // Init fixed header
      // ---

      if (s.fixedHeader) {
        headerClass = 'mbsc-lv-fixed-header' + (hasContext ? ' mbsc-lv-fixed-header-ctx mbsc-lv-' + s.theme + ' mbsc-' + s.theme + (s.baseTheme ? ' mbsc-lv-' + s.baseTheme + ' mbsc-' + s.baseTheme : '') : '');

        if (!groupHeader) {
          groupHeader = $$1('<div class="' + headerClass + '"></div>');
        } else {
          groupHeader.attr('class', headerClass);
          onScroll();
        }

        if (hasContext) {
          wnd.before(groupHeader);
        } else {
          cont.prepend(groupHeader);
        }

        onScrollThrottle = throttle(onScroll, 200);
        listen(wnd0, 'scroll', onScrollThrottle);
        listen(wnd0, 'touchmove', onScrollThrottle, {
          passive: true
        });
      } // ---


      if (s.hover) {
        if (!hoverTime) {
          cont.on('mouseover.mbsc-lv', '.mbsc-lv-item', function () {
            if (!hoverItem || hoverItem[0] != this) {
              onMouseLeave();
              hoverItem = $$1(this);

              if (types[hoverItem.attr('data-type') || 'defaults'].actions) {
                hoverTimer = setTimeout(function () {
                  if (!preventHover) {
                    hoverItemOpened = true;
                    that.openActions(hoverItem, hoverDir, hoverTime, false);
                  } else {
                    hoverItem = null;
                  }
                }, hoverTimeout);
              }
            }
          }).on('mouseleave.mbsc-lv', onMouseLeave);
        }

        hoverTime = s.hover.time || 200;
        hoverTimeout = s.hover.timeout || 200;
        hoverDir = s.hover.direction || s.hover || 'right';
      }

      if (hadEnhance) {
        cont.attr('mbsc-enhance', '');
      }

      cont.trigger('mbsc-enhance', [{
        theme: s.theme,
        lang: s.lang
      }]);
    };
    /**
     * Listview destroy: removes event handlers, classes and additional markup.
     */


    that._destroy = function () {
      var form;
      currParent.append(currList);

      if (hasContext && groupHeader) {
        groupHeader.remove();
      }

      if (hadEnhance) {
        elm.attr('mbsc-enhance', ''); // Destroy form instance if any

        form = instances[cont0.id];

        if (form) {
          form.destroy();
        }
      }

      unlisten(document, 'touchstart', onIconStart, {
        passive: false
      });
      unlisten(document, 'touchmove', onMove, {
        passive: false
      });
      unlisten(e, 'click', onListClick, true);
      cont.find('.mbsc-lv-txt,.mbsc-lv-img').removeClass('mbsc-lv-txt mbsc-lv-img');
      cont.find(listSelector).removeClass('mbsc-lv mbsc-lv-v mbsc-lv-root mbsc-lv-sl-curr').find(itemSelector).removeClass('mbsc-lv-gr-title mbsc-lv-item mbsc-lv-item-enhanced mbsc-lv-parent mbsc-lv-img-left mbsc-lv-img-right mbsc-lv-item-ic-left mbsc-lv-item-ic-right').removeAttr('data-ref');
      $$1('.mbsc-lv-back,.mbsc-lv-handle-c,.mbsc-lv-arr,.mbsc-lv-item-ic', cont).remove();
      elm.insertAfter(cont);
      cont.remove();
      stagec.remove();
      unlisten(wnd0, 'orientationchange', onResize);
      unlisten(wnd0, 'resize', onResize);
      unlisten(wnd0, 'scroll', onScrollBottom);
      unlisten(wnd0, 'touchmove', onScrollBottom, {
        passive: true
      });

      if (onScrollThrottle) {
        unlisten(wnd0, 'scroll', onScrollThrottle);
        unlisten(wnd0, 'touchmove', onScrollThrottle, {
          passive: true
        });
      }
    }; // Undo manager, may be removed later in separate class
    // ---


    var undoing,
        undoQueue = [],
        undoStack = [],
        undoGroup = [],
        undoListener = 0;

    that.startActionTrack = function () {
      // Start a new undo group if not running
      if (!undoListener) {
        undoGroup = [];
      }

      undoListener++;
    };

    that.endActionTrack = function () {
      // End undo group, if this the outermost listener (undoListener counter is 0);
      undoListener--;

      if (!undoListener) {
        undoStack.push(undoGroup);
      }
    };

    that.addUndoAction = function (action, async) {
      var obj = {
        action: action,
        async: async
      }; //if (!undoing) {

      if (undoListener) {
        // Add undo action in current group, if a listener is running
        undoGroup.push(obj);
      } else {
        // Add undo action within a new group
        undoStack.push([obj]);

        if (undoStack.length > s.undoLimit) {
          undoStack.shift();
        }
      } //}

    };

    that.undo = function () {
      var action, i, group;

      function run() {
        if (i < 0) {
          undoing = false; // If there is data in the queue, keep calling the undo

          undo();
        } else {
          action = group[i];
          i--;

          if (action.async) {
            // Run action, next action must be called inside the action
            action.action(run);
          } else {
            // Run action
            action.action(); // Run next action

            run();
          }
        }
      }

      function undo() {
        group = undoQueue.shift();

        if (group) {
          undoing = true;
          i = group.length - 1; // Call actions from the group recoursively

          run();
        }
      }

      if (undoStack.length) {
        undoQueue.push(undoStack.pop());
      } // If undo is currently running, don't do anything (it will be called later from queue)


      if (!undoing) {
        undo();
      }
    }; // ---
    // Constructor


    s = that.settings;
    event = that.trigger;
    that.init();
  }; // Defaults

  ListView.prototype = {
    _class: 'listview',
    _hasDef: true,
    _hasTheme: true,
    _hasLang: true,
    _defaults: {
      context: 'body',
      actionsWidth: 90,
      sortDelay: 250,
      undoLimit: 10,
      tap: hasGhostClick,
      swipe: true,
      quickSwipe: true,
      animateAddRemove: true,
      animateIcons: true,
      animation: true,
      revert: true,
      vibrate: true,
      actionable: true,
      handleClass: '',
      handleMarkup: '<div class="mbsc-lv-handle-bar mbsc-lv-handle"></div><div class="mbsc-lv-handle-bar mbsc-lv-handle"></div><div class="mbsc-lv-handle-bar mbsc-lv-handle"></div>',
      listNode: 'ul',
      listSelector: 'ul,ol',
      itemNode: 'li',
      itemSelector: 'li',
      leftArrowClass: 'mbsc-ic-arrow-left4',
      rightArrowClass: 'mbsc-ic-arrow-right4',
      backText: 'Back',
      undoText: 'Undo',
      stages: [],
      select: 'off'
    }
  };
  classes.ListView = ListView;
  mobiscroll.themes.listview.mobiscroll = {
    leftArrowClass: 'mbsc-ic-arrow-left5',
    rightArrowClass: 'mbsc-ic-arrow-right5'
  };

  var MbscListviewService = (function () {
      function MbscListviewService() {
          this.addObservable = new Observable();
          this.removeObservable = new Observable();
          this.cardObservable = new Observable();
          this.instanceObservable = new Observable();
          this.inst = null;
      }
      MbscListviewService.prototype.notifyInstanceReady = function (instance) {
          this.inst = instance;
          this.instanceObservable.next(instance);
      };
      MbscListviewService.prototype.onInstanceReady = function () {
          return this.instanceObservable;
      };
      MbscListviewService.prototype.notifyAdded = function (item, parent) {
          this.addObservable.next({ item: item, parent: parent });
      };
      MbscListviewService.prototype.notifyRemoved = function (item) {
          this.removeObservable.next(item);
      };
      MbscListviewService.prototype.notifyCardPresence = function (isCard) {
          this.cardObservable.next(isCard);
      };
      MbscListviewService.prototype.onCardContent = function () {
          return this.cardObservable;
      };
      MbscListviewService.prototype.onItemAdded = function () {
          return this.addObservable;
      };
      MbscListviewService.prototype.onItemRemoved = function () {
          return this.removeObservable;
      };
      MbscListviewService.decorators = [
          { type: core.Injectable },
      ];
      MbscListviewService.ctorParameters = function () { return []; };
      return MbscListviewService;
  }());
  var MbscSublistService = (function () {
      function MbscSublistService() {
          this.addObservable = new Observable();
          this.removeObserable = new Observable();
      }
      MbscSublistService.prototype.notifyAdded = function (item) {
          this.addObservable.next(item);
      };
      MbscSublistService.prototype.notifyRemoved = function (item) {
          this.removeObserable.next(item);
      };
      MbscSublistService.prototype.onItemAdded = function () {
          return this.addObservable;
      };
      MbscSublistService.prototype.onItemRemoved = function () {
          return this.removeObserable;
      };
      MbscSublistService.decorators = [
          { type: core.Injectable },
      ];
      MbscSublistService.ctorParameters = function () { return []; };
      return MbscSublistService;
  }());
  var MbscListitemService = (function () {
      function MbscListitemService() {
          this.sublistSubject = new Observable();
          this.inst = null;
      }
      MbscListitemService.prototype.notifySublistCreated = function (item) {
          this.sublistSubject.next(item);
      };
      MbscListitemService.prototype.onSublistCreated = function () {
          return this.sublistSubject;
      };
      MbscListitemService.decorators = [
          { type: core.Injectable },
      ];
      MbscListitemService.ctorParameters = function () { return []; };
      return MbscListitemService;
  }());
  var MbscListviewSublist = (function () {
      function MbscListviewSublist(parentServ, subServ, itemService) {
          this.parentServ = parentServ;
          this.subServ = subServ;
          this.itemService = itemService;
      }
      MbscListviewSublist.prototype.ngOnInit = function () {
          this.itemService.notifySublistCreated(this);
      };
      MbscListviewSublist.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-listview-sublist',
                      template: '<ng-content></ng-content>',
                      providers: [MbscSublistService]
                  },] },
      ];
      MbscListviewSublist.ctorParameters = function () { return [
          { type: MbscListviewService, },
          { type: MbscSublistService, },
          { type: MbscListitemService, },
      ]; };
      return MbscListviewSublist;
  }());
  var MbscListviewItem = (function () {
      function MbscListviewItem(elem, lvService, lvItemService, subService) {
          var _this = this;
          this.elem = elem;
          this.lvService = lvService;
          this.lvItemService = lvItemService;
          this.subService = subService;
          this.clone = null;
          this.mounted = false;
          this.isParent = false;
          this._instance = undefined;
          this.subitemObserver = null;
          this.selectedChange = new core.EventEmitter();
          this.sublistObserver = lvItemService.onSublistCreated().subscribe(function (sublist) {
              _this.isParent = true;
              _this.sublist = sublist;
              _this.subitemObserver = sublist.subServ.onItemAdded().subscribe(function (subItem) {
                  if (_this.mounted) {
                      _this.lvService.notifyAdded(subItem, _this);
                  }
              });
          });
          this.instanceObserver = this.lvService.onInstanceReady().subscribe(function (instance) {
              _this._instance = instance;
          });
          if (lvService.inst) {
              this._instance = lvService.inst;
          }
      }
      Object.defineProperty(MbscListviewItem.prototype, "Index", {
          get: function () {
              var thisElem = $$1(this.elem.nativeElement);
              var index = thisElem.parent().children('mbsc-listview-item, mbsc-listview-header').not('.mbsc-lv-back').index(thisElem);
              return index;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MbscListviewItem.prototype, "Element", {
          get: function () {
              return this.clone || $$1(this.elem.nativeElement);
          },
          enumerable: true,
          configurable: true
      });
      MbscListviewItem.prototype.ngAfterViewInit = function () {
          if (this.subService) {
              this.subService.notifyAdded(this);
          }
          else {
              this.lvService.notifyAdded(this);
          }
          this.mounted = true;
      };
      MbscListviewItem.prototype.ngOnDestroy = function () {
          this.lvItemService.onSublistCreated().unsubscribe(this.sublistObserver);
          this.lvService.onInstanceReady().unsubscribe(this.instanceObserver);
          if (this.subitemObserver !== null) {
              this.sublist.subServ.onItemAdded().unsubscribe(this.subitemObserver);
              this.sublist = null;
          }
          var $elm = this.Element, $clone = $elm.clone();
          if ($elm.parent().length) {
              $clone.insertBefore($elm);
              this.clone = $clone;
          }
          if (this.subService) {
              this.subService.notifyRemoved(this);
          }
          else {
              this.lvService.notifyRemoved(this);
          }
      };
      Object.defineProperty(MbscListviewItem.prototype, "selected", {
          get: function () {
              return this._selected;
          },
          set: function (v) {
              this._selected = v;
              if (this._instance) {
                  if (this._selected) {
                      this._instance.select(this.elem.nativeElement);
                  }
                  else {
                      this._instance.deselect(this.elem.nativeElement);
                  }
              }
          },
          enumerable: true,
          configurable: true
      });
      MbscListviewItem.prototype.toggle = function () {
          this._selected = !this._selected;
          this.selectedChange.emit(this._selected);
      };
      MbscListviewItem.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-listview-item',
                      template: '<ng-content></ng-content>',
                      providers: [MbscListitemService],
                      host: {
                          '[attr.data-id]': 'id',
                          '[attr.data-icon]': 'icon',
                          '[attr.data-icon-align]': 'iconAlign',
                          '[attr.data-selected]': 'selected',
                          '[attr.data-type]': 'type'
                      }
                  },] },
      ];
      MbscListviewItem.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: MbscListviewService, },
          { type: MbscListitemService, },
          { type: MbscSublistService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscListviewItem.propDecorators = {
          'id': [{ type: core.Input },],
          'icon': [{ type: core.Input },],
          'iconAlign': [{ type: core.Input, args: ['icon-align',] },],
          'type': [{ type: core.Input },],
          'selected': [{ type: core.Input },],
          'selectedChange': [{ type: core.Output },],
      };
      return MbscListviewItem;
  }());
  var MbscListviewHeader = (function (_super) {
      __extends(MbscListviewHeader, _super);
      function MbscListviewHeader(elem, lvService, itemService, subService) {
          return _super.call(this, elem, lvService, itemService, subService) || this;
      }
      MbscListviewHeader.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-listview-header',
                      template: '<ng-content></ng-content>',
                      providers: [MbscListitemService],
                      host: {
                          '[attr.data-id]': 'id',
                          'data-role': 'list-divider'
                      }
                  },] },
      ];
      MbscListviewHeader.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: MbscListviewService, },
          { type: MbscListitemService, },
          { type: MbscSublistService, decorators: [{ type: core.Optional },] },
      ]; };
      return MbscListviewHeader;
  }(MbscListviewItem));
  var MbscListview = (function (_super) {
      __extends(MbscListview, _super);
      function MbscListview(elem, zone, lvService, optionService) {
          var _this = _super.call(this, elem, zone) || this;
          _this.elem = elem;
          _this.lvService = lvService;
          _this.optionService = optionService;
          _this.onItemTap = new core.EventEmitter();
          _this.onItemAdd = new core.EventEmitter();
          _this.onItemRemove = new core.EventEmitter();
          _this.onListEnd = new core.EventEmitter();
          _this.onNavEnd = new core.EventEmitter();
          _this.onNavStart = new core.EventEmitter();
          _this.onSlideEnd = new core.EventEmitter();
          _this.onSlideStart = new core.EventEmitter();
          _this.onSort = new core.EventEmitter();
          _this.onSortChange = new core.EventEmitter();
          _this.onSortStart = new core.EventEmitter();
          _this.onSortEnd = new core.EventEmitter();
          _this.onSortUpdate = new core.EventEmitter();
          _this.onStageChange = new core.EventEmitter();
          _this.cardContent = false;
          _this.addObserver = lvService.onItemAdded().subscribe(function (t) {
              var item = t.item, parent = t.parent;
              if (_this.instance) {
                  _this.instance.add(null, item.Element, item.Index, undefined, parent && parent.Element);
              }
          });
          _this.removeObserver = lvService.onItemRemoved().subscribe(function (item) {
              if (_this.instance) {
                  _this.instance.remove(item.Element, undefined);
              }
          });
          _this.cardObserver = lvService.onCardContent().subscribe(function (isCard) {
              _this.cardContent = isCard;
          });
          return _this;
      }
      MbscListview.prototype.tapHandler = function (event, inst) {
          var selection = this.select || (inst && inst.settings.select);
          switch (selection) {
              case 'multiple': {
                  var item = this._getItem(event.target);
                  if (item && !item.isParent) {
                      item.toggle();
                  }
                  break;
              }
              case 'single': {
                  var item = this._getItem(event.target);
                  if (item && !item.selected) {
                      this.items.forEach(function (item) {
                          if (item.selected) {
                              item.toggle();
                          }
                      });
                      item.toggle();
                  }
              }
          }
          event.inst = inst;
          this.onItemTap.emit(event);
      };
      MbscListview.prototype._getItem = function (nativeEl) {
          return this.items.find(function (item) {
              return item.elem.nativeElement === nativeEl;
          });
      };
      MbscListview.prototype.initControl = function () {
          var _this = this;
          var onItemTap = this.tapHandler.bind(this);
          var onItemTapUser = this.options && this.options.onItemTap;
          if (onItemTapUser) {
              onItemTap = function (event, inst) {
                  _this.tapHandler(event, inst);
                  return onItemTapUser(event, inst);
              };
          }
          var options = extend$1({
              listNode: 'mbsc-listview',
              listSelector: 'mbsc-listview, mbsc-listview-sublist',
              itemNode: 'mbsc-listview-item',
              itemSelector: 'mbsc-listview-item, mbsc-listview-header'
          }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, { onItemTap: onItemTap });
          this.instance = new ListView(this.elem.nativeElement, options);
          this.lvService.notifyInstanceReady(this.instance);
      };
      MbscListview.prototype.ngOnDestroy = function () {
          this.lvService.onCardContent().unsubscribe(this.cardObserver);
          this.lvService.onItemAdded().unsubscribe(this.addObserver);
          this.lvService.onItemRemoved().unsubscribe(this.removeObserver);
          _super.prototype.ngOnDestroy.call(this);
      };
      MbscListview.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-listview',
                      template: "<ng-content></ng-content>",
                      providers: [MbscListviewService],
                      exportAs: 'mobiscroll',
                      host: {
                          'class': 'mbsc-cloak',
                          '[class.mbsc-card-list]': 'cardContent'
                      }
                  },] },
      ];
      MbscListview.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: MbscListviewService, },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscListview.propDecorators = {
          'actions': [{ type: core.Input },],
          'actionsWidth': [{ type: core.Input },],
          'context': [{ type: core.Input },],
          'striped': [{ type: core.Input },],
          'animateAddRemove': [{ type: core.Input },],
          'actionable': [{ type: core.Input },],
          'animateIcons': [{ type: core.Input },],
          'enhance': [{ type: core.Input },],
          'fillAnimation': [{ type: core.Input },],
          'fixedHeader': [{ type: core.Input },],
          'hover': [{ type: core.Input },],
          'iconSlide': [{ type: core.Input },],
          'itemGroups': [{ type: core.Input },],
          'loadingIcon': [{ type: core.Input },],
          'navigateOnDrop': [{ type: core.Input },],
          'quickSwipe': [{ type: core.Input },],
          'select': [{ type: core.Input },],
          'sortable': [{ type: core.Input },],
          'sortDelay': [{ type: core.Input },],
          'stages': [{ type: core.Input },],
          'swipe': [{ type: core.Input },],
          'swipeleft': [{ type: core.Input },],
          'swiperight': [{ type: core.Input },],
          'vibrate': [{ type: core.Input },],
          'undoText': [{ type: core.Input },],
          'backText': [{ type: core.Input },],
          'onItemTap': [{ type: core.Output },],
          'onItemAdd': [{ type: core.Output },],
          'onItemRemove': [{ type: core.Output },],
          'onListEnd': [{ type: core.Output },],
          'onNavEnd': [{ type: core.Output },],
          'onNavStart': [{ type: core.Output },],
          'onSlideEnd': [{ type: core.Output },],
          'onSlideStart': [{ type: core.Output },],
          'onSort': [{ type: core.Output },],
          'onSortChange': [{ type: core.Output },],
          'onSortStart': [{ type: core.Output },],
          'onSortEnd': [{ type: core.Output },],
          'onSortUpdate': [{ type: core.Output },],
          'onStageChange': [{ type: core.Output },],
          'options': [{ type: core.Input, args: ['options',] },],
          'items': [{ type: core.ContentChildren, args: [MbscListviewItem, { descendants: true },] },],
      };
      return MbscListview;
  }(MbscBase));
  var comp = [
      MbscListview,
      MbscListviewItem,
      MbscListviewHeader,
      MbscListviewSublist
  ];
  var MbscListviewModule = (function () {
      function MbscListviewModule() {
      }
      MbscListviewModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [MbscBaseModule],
                      declarations: comp,
                      exports: comp
                  },] },
      ];
      MbscListviewModule.ctorParameters = function () { return []; };
      return MbscListviewModule;
  }());

  var MbscCard = (function (_super) {
      __extends(MbscCard, _super);
      function MbscCard(host, optionsService, lvService, zone) {
          var _this = _super.call(this, host, zone) || this;
          _this.optionsService = optionsService;
          _this.lvService = lvService;
          _this._collapsibleInput = null;
          _this._open = false;
          if (_this.lvService) {
              _this.lvService.notifyCardPresence(true);
          }
          return _this;
      }
      Object.defineProperty(MbscCard.prototype, "collapsibleInput", {
          set: function (v) {
              this._collapsibleInput = v;
              this.inlineOptionsObj.collapsible = this._open;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MbscCard.prototype, "open", {
          set: function (v) {
              if (this._open != v && this.instance) {
                  if (v) {
                      this.instance.show();
                  }
                  else {
                      this.instance.hide();
                  }
              }
              this._open = !!v;
              if (this._collapsibleInput !== null) {
                  this.inlineOptionsObj.collapsible = this._open;
              }
          },
          enumerable: true,
          configurable: true
      });
      MbscCard.prototype.initControl = function () {
          var options = extend$1({}, this.optionsService ? this.optionsService.options : {}, this.options, this.inlineOptionsObj);
          this.instance = new Card(this.initialElem.nativeElement, options);
      };
      MbscCard.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mbsc-card]',
                      exportAs: 'mobiscroll',
                      host: { 'class': 'mbsc-cloak' }
                  },] },
      ];
      MbscCard.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: MbscListviewService, decorators: [{ type: core.Optional },] },
          { type: core.NgZone, },
      ]; };
      MbscCard.propDecorators = {
          'collapsibleInput': [{ type: core.Input, args: ['collapsible',] },],
          'open': [{ type: core.Input },],
      };
      return MbscCard;
  }(MbscBase));
  var MbscCardComponent = (function (_super) {
      __extends(MbscCardComponent, _super);
      function MbscCardComponent(host, optionsService, lvService, zone) {
          var _this = _super.call(this, host, optionsService, lvService, zone) || this;
          _this.optionsService = optionsService;
          return _this;
      }
      MbscCardComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-card',
                      template: '<ng-content></ng-content>',
                      exportAs: 'mobiscroll',
                      styles: [':host { display: block }']
                  },] },
      ];
      MbscCardComponent.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: MbscListviewService, decorators: [{ type: core.Optional },] },
          { type: core.NgZone, },
      ]; };
      MbscCardComponent.propDecorators = {
          'options': [{ type: core.Input },],
      };
      return MbscCardComponent;
  }(MbscCard));
  var MbscCardHeader = (function () {
      function MbscCardHeader() {
      }
      MbscCardHeader.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-card-header',
                      template: '<ng-content></ng-content>',
                      styles: [':host { display: block; }'],
                      host: {
                          'class': 'mbsc-card-header'
                      }
                  },] },
      ];
      MbscCardHeader.ctorParameters = function () { return []; };
      return MbscCardHeader;
  }());
  var MbscCardContent = (function () {
      function MbscCardContent() {
      }
      MbscCardContent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-card-content',
                      template: '<ng-content></ng-content>',
                      styles: [':host { display: block; }'],
                      host: {
                          'class': 'mbsc-card-content'
                      }
                  },] },
      ];
      MbscCardContent.ctorParameters = function () { return []; };
      return MbscCardContent;
  }());
  var MbscCardFooter = (function () {
      function MbscCardFooter() {
      }
      MbscCardFooter.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-card-footer',
                      template: '<ng-content></ng-content>',
                      styles: [':host { display: block; }'],
                      host: {
                          'class': 'mbsc-card-footer'
                      }
                  },] },
      ];
      MbscCardFooter.ctorParameters = function () { return []; };
      return MbscCardFooter;
  }());
  var MbscCardTitle = (function () {
      function MbscCardTitle() {
      }
      MbscCardTitle.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-card-title',
                      template: '<ng-content></ng-content>',
                      styles: [':host { display: block; }'],
                      host: {
                          'class': 'mbsc-card-title'
                      }
                  },] },
      ];
      MbscCardTitle.ctorParameters = function () { return []; };
      return MbscCardTitle;
  }());
  var MbscCardSubtitle = (function () {
      function MbscCardSubtitle() {
      }
      MbscCardSubtitle.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-card-subtitle',
                      template: '<ng-content></ng-content>',
                      styles: [':host { display: block; }'],
                      host: {
                          'class': 'mbsc-card-subtitle'
                      }
                  },] },
      ];
      MbscCardSubtitle.ctorParameters = function () { return []; };
      return MbscCardSubtitle;
  }());
  var comp$1 = [
      MbscCard, MbscCardComponent,
      MbscCardHeader, MbscCardContent, MbscCardFooter,
      MbscCardTitle, MbscCardSubtitle
  ];
  var MbscCardModule = (function () {
      function MbscCardModule() {
      }
      MbscCardModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [MbscBaseModule],
                      declarations: comp$1,
                      exports: comp$1
                  },] },
      ];
      MbscCardModule.ctorParameters = function () { return []; };
      return MbscCardModule;
  }());

  /**
   * Convert rgb color to hex
   */

  function rgb2hex(rgb) {
    var hex = [Math.round(rgb.r).toString(16), Math.round(rgb.g).toString(16), Math.round(rgb.b).toString(16)];
    $$1.each(hex, function (nr, val) {
      if (val.length == 1) {
        hex[nr] = '0' + val;
      }
    });
    return '#' + hex.join('');
  }
  /**
   * Convert hex color to rgb
   */


  function hex2rgb(hex) {
    hex = parseInt(hex.indexOf('#') > -1 ? hex.substring(1) : hex, 16);
    return {
      r: hex >> 16,
      g: (hex & 0x00FF00) >> 8,
      b: hex & 0x0000FF,
      toString: function toString() {
        return 'rgb(' + this.r + ',' + this.g + ',' + this.b + ')';
      }
    };
  }
  /**
   * Convert hsv color to rgb
   */


  function hsv2rgb(hsv) {
    var r,
        g,
        b,
        h = hsv.h,
        s = hsv.s * 255 / 100,
        v = hsv.v * 255 / 100;

    if (s === 0) {
      r = g = b = v;
    } else {
      var t1 = v,
          t2 = (255 - s) * v / 255,
          t3 = (t1 - t2) * (h % 60) / 60;

      if (h == 360) {
        h = 0;
      }

      if (h < 60) {
        r = t1;
        b = t2;
        g = t2 + t3;
      } else if (h < 120) {
        g = t1;
        b = t2;
        r = t1 - t3;
      } else if (h < 180) {
        g = t1;
        r = t2;
        b = t2 + t3;
      } else if (h < 240) {
        b = t1;
        r = t2;
        g = t1 - t3;
      } else if (h < 300) {
        b = t1;
        g = t2;
        r = t2 + t3;
      } else if (h < 360) {
        r = t1;
        g = t2;
        b = t1 - t3;
      } else {
        r = g = b = 0;
      }
    }

    return {
      r: r,
      g: g,
      b: b,
      toString: function toString() {
        return 'rgb(' + this.r + ',' + this.g + ',' + this.b + ')';
      }
    };
  }
  /**
   * Convert rgb color to hsv
   */


  function rgb2hsv(rgb) {
    var h = 0,
        s,
        v,
        min = Math.min(rgb.r, rgb.g, rgb.b),
        max = Math.max(rgb.r, rgb.g, rgb.b),
        delta = max - min;
    v = max;
    s = max ? 255 * delta / max : 0;

    if (s) {
      if (rgb.r == max) {
        h = (rgb.g - rgb.b) / delta;
      } else if (rgb.g == max) {
        h = 2 + (rgb.b - rgb.r) / delta;
      } else {
        h = 4 + (rgb.r - rgb.g) / delta;
      }
    } else {
      h = -1;
    }

    h *= 60;

    if (h < 0) {
      h += 360;
    }

    s *= 100 / 255;
    v *= 100 / 255;
    return {
      h: h,
      s: s,
      v: v,
      toString: function toString() {
        return 'hsv(' + Math.round(this.h) + ',' + Math.round(this.s) + '%,' + Math.round(this.v) + '%)';
      }
    };
  }
  /**
   * Convert rgb color to hsl
   */


  function rgb2hsl(rgb) {
    var r = rgb.r / 255,
        g = rgb.g / 255,
        b = rgb.b / 255,
        max = Math.max(r, g, b),
        min = Math.min(r, g, b),
        l = (max + min) / 2,
        h,
        s;

    if (max == min) {
      h = s = 0; // achromatic
    } else {
      var d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;

        case g:
          h = (b - r) / d + 2;
          break;

        case b:
          h = (r - g) / d + 4;
          break;
      }

      h /= 6;
    }

    return {
      h: Math.round(h * 360),
      s: Math.round(s * 100),
      l: Math.round(l * 100),
      toString: function toString() {
        return 'hsl(' + this.h + ',' + this.s + '%,' + this.l + '%)';
      }
    };
  }
  /**
   * Convert hsl color to rgb
   */


  function hsl2rgb(hsl) {
    var r,
        g,
        b,
        m,
        c,
        x,
        h = hsl.h,
        s = hsl.s,
        l = hsl.l;

    if (!isFinite(h)) {
      h = 0;
    }

    if (!isFinite(s)) {
      s = 0;
    }

    if (!isFinite(l)) {
      l = 0;
    }

    h /= 60;

    if (h < 0) {
      h = 6 - -h % 6;
    }

    h %= 6;
    s = Math.max(0, Math.min(1, s / 100));
    l = Math.max(0, Math.min(1, l / 100));
    c = (1 - Math.abs(2 * l - 1)) * s;
    x = c * (1 - Math.abs(h % 2 - 1));

    if (h < 1) {
      r = c;
      g = x;
      b = 0;
    } else if (h < 2) {
      r = x;
      g = c;
      b = 0;
    } else if (h < 3) {
      r = 0;
      g = c;
      b = x;
    } else if (h < 4) {
      r = 0;
      g = x;
      b = c;
    } else if (h < 5) {
      r = x;
      g = 0;
      b = c;
    } else {
      r = c;
      g = 0;
      b = x;
    }

    m = l - c / 2;
    return {
      r: Math.round((r + m) * 255),
      g: Math.round((g + m) * 255),
      b: Math.round((b + m) * 255),
      toString: function toString() {
        return 'rgb(' + this.r + ',' + this.g + ',' + this.b + ')';
      }
    };
  }
  /**
   * Convert hex color to hsl
   */


  function hex2hsl(hex) {
    return rgb2hsl(hex2rgb(hex));
  }
  /**
   * Convert hsl color to hex
   */


  function hsl2hex(hsl) {
    return rgb2hex(hsl2rgb(hsl));
  }
  /**
   * Convert hsv color to hex
   */


  function hsv2hex(hsv) {
    return rgb2hex(hsv2rgb(hsv));
  }
  /**
   * Convert hex color to hsv
   */


  function hex2hsv(hex) {
    return rgb2hsv(hex2rgb(hex));
  }

  var Color = function Color(el, settings, inherit) {
    var s,
        def,
        tempColors,
        trigger,
        scrollView,
        previewScrollView,
        hasClear,
        currValue,
        currHslValue,
        isHorizontalScroll,
        hasPreview,
        sliderTrack,
        refineMode,
        rowItems,
        slider,
        colorIndex,
        enhanceInput,
        singleSelect,
        maxSelect,
        returnObj,
        $input,
        $colorItems,
        $colorPreviewItems,
        $currItem,
        $sliderElm,
        that = this,
        $elm = $$1(el),
        colorPreviewInd = 0,
        previewValues = {},
        tempPreviewValues = {};

    function setValue(fill, change, temp) {
      if (!temp) {
        that._value = that._hasValue ? that._tempValue.slice(0) : null;

        for (var i = 0; i < tempColors.length; ++i) {
          if (tempColors[i].tempChangedColor && that._value && that._value.indexOf(tempColors[i].tempChangedColor) != -1) {
            // set changed color if was set
            tempColors[i].changedColor = tempColors[i].tempChangedColor;
          } // else if (tempColors[i].changedColor && that._value.indexOf(tempColors[i].changedColor) == -1) { // delete changed color if was unset
          //    delete tempColors[i].changedColor;
          //}


          delete tempColors[i].tempChangedColor;
        }
      }

      if (fill) {
        if (that._isInput) {
          $elm.val(that._hasValue ? that._tempValue : '');
        }

        trigger('onFill', {
          valueText: that._hasValue ? that._tempValue : '',
          change: change
        });

        if (change) {
          previewValues = extend$1(true, {}, tempPreviewValues);
          that._preventChange = true;
          $elm.trigger('change');
        }

        refreshSelectedValues(that._value, true);
      }
    }

    function getInputColorItem(value, index) {
      index = index !== undefined ? index : getColorIndex(value);
      return '<div class="mbsc-color-input-item" data-color="' + (index !== undefined ? index : value) + '" style="background: ' + value + ';">' + (singleSelect ? '' : '<div class="mbsc-color-input-item-close mbsc-ic mbsc-ic-material-close"></div>') + '</div>';
    }

    function changeSliderStepsColor(color) {
      sliderTrack[0].style.background = color ? cssPrefix + 'linear-gradient(left, ' + (s.rtl ? '#000000' : '#FFFFFF') + ' 0%, ' + color + ' 50%, ' + (s.rtl ? '#FFFFFF' : '#000000') + ' 100%)' : '';
    }

    function getColorIndex(color) {
      if (Object.keys(tempPreviewValues).length && !isNaN(color)) {
        return color;
      }

      for (var c in tempColors) {
        if (color == tempColors[c].color || color == tempColors[c].changedColor) {
          return c;
        }
      }
    }

    function generateInputItems() {
      if (enhanceInput) {
        var i,
            inputColorItems = '';
        $input.empty();

        if (that._hasValue) {
          if (singleSelect) {
            inputColorItems += getInputColorItem(that._value, colorIndex);
          } else {
            for (i = 0; i < that._value.length; ++i) {
              inputColorItems += getInputColorItem(that._value[i], Object.keys(tempPreviewValues).length && tempPreviewValues[i].colorIndex ? tempPreviewValues[i].colorIndex : getColorIndex(that._value[i]));
            }
          }

          $input.append(inputColorItems);
          that.tap($$1('.mbsc-color-input-item', $input), function (ev) {
            if ($$1(ev.target).hasClass('mbsc-color-input-item-close')) {
              var indx = $$1(this).index();
              ev.stopPropagation();
              ev.preventDefault();

              if (colorIndex === undefined) {
                colorIndex = $$1(ev.target).parent().attr('data-color');
              }

              if (hasPreview && tempColors[colorIndex]) {
                colorPreviewInd = tempColors[colorIndex].previewInd;
                $colorPreviewItems.eq(colorPreviewInd).parent().removeClass('mbsc-color-active');
                previewValues[indx] = {};
                tempPreviewValues[indx] = {};
              }

              that._value.splice(indx, 1);

              that.setVal(that._value, true, true);
            } else if (refineMode && s.display !== 'inline') {
              colorIndex = $$1(ev.target).attr('data-color');

              if (isNaN(colorIndex)) {
                colorIndex = getColorIndex(colorIndex);
              }

              if (colorIndex && tempColors[colorIndex]) {
                tempColors[colorIndex].selected = true;
                colorPreviewInd = tempColors[colorIndex].previewInd; // scroll to view, if the selected color is not resent in the view

                setTimeout(function () {
                  scrollView.scroll($colorItems.eq(colorIndex), 400);

                  if (hasPreview) {
                    previewScrollView.scroll($colorPreviewItems.eq(colorPreviewInd), 400);
                  }
                }, 200);
              }
            }
          });
        }
      }
    }

    function convertToFormat(color, type) {
      var colorHex,
          colorValues = color.match(/\d+/gmi);

      switch (true) {
        case color.indexOf('rgb') > -1:
          colorHex = rgb2hex({
            r: colorValues[0],
            g: colorValues[1],
            b: colorValues[2]
          });
          break;

        case color.indexOf('hsl') > -1:
          colorHex = hsl2hex({
            h: colorValues[0],
            s: colorValues[1],
            l: colorValues[2]
          });
          break;

        case color.indexOf('hsv') > -1:
          colorHex = hsv2hex({
            h: colorValues[0],
            s: colorValues[1],
            v: colorValues[2]
          });
          break;

        case color.indexOf('#') > -1:
          colorHex = color;
          break;
      }

      return convertFromHex(colorHex, type || s.format);
    }

    function convertFromHex(color, type) {
      switch (type) {
        case 'rgb':
          return hex2rgb(color);

        case 'hsl':
          return hex2hsl(color);

        case 'hsv':
          return hex2hsv(color);

        default:
          return color;
      }
    }

    function getFirstEmptyPreviewIndex() {
      var i;

      for (i = 0; i < s.select; ++i) {
        if (tempPreviewValues[i].colorIndex === undefined) {
          return i;
        }
      }
    }

    function highlightActiveColor($color, ctx) {
      $$1('.mbsc-color-active', ctx).removeClass('mbsc-color-active');

      if (refineMode) {
        $color.parent().addClass('mbsc-color-active');

        if (hasPreview && $color) {
          if (colorPreviewInd !== undefined) {
            $colorPreviewItems.eq(colorPreviewInd).parent().addClass('mbsc-color-active');
          }
        }
      }
    }

    function refreshSelectedValues(newtempColors, updateInput) {
      var i,
          temp,
          indexes = [],
          prevInd = 0,
          colorValues = $$1.map(tempColors, function (v) {
        return v.changedColor || v.color;
      }); // check the indexes in the tempColors

      if (singleSelect) {
        newtempColors = $$1.isArray(newtempColors) ? newtempColors[0] : newtempColors;
        temp = colorValues.indexOf(newtempColors);

        if (temp > -1) {
          indexes.push(temp);
        }

        if (newtempColors && !indexes.length && refineMode) {
          var inputIndex = +$$1('.mbsc-color-input-item', $input).attr('data-color');

          if (isNaN(inputIndex)) {
            inputIndex = undefined;
          } else {
            indexes.push(inputIndex);
          }

          colorIndex = inputIndex;
        }
      } else if (newtempColors) {
        if (hasPreview && refineMode) {
          for (var c in previewValues) {
            if (previewValues[c].colorIndex !== undefined) {
              indexes.push(+previewValues[c].colorIndex);
            }
          }
        } else {
          for (i = 0; i < newtempColors.length; ++i) {
            temp = colorValues.indexOf(newtempColors[i]);

            if (temp > -1) {
              indexes.push(temp);
              colorValues[temp] = 'temp' + i;
            }
          }
        }
      } // loop trough new color indexes and check the colors


      for (i = 0; i < indexes.length; ++i) {
        if (tempColors[indexes[i]]) {
          toggleColor(true, indexes[i], prevInd++, tempColors[indexes[i]].changedColor || tempColors[indexes[i]].color, true);
        }
      } // loop trough other color indexes and uncheck the colors


      for (i = 0; i < tempColors.length; ++i) {
        if (indexes.indexOf(i) == -1) {
          toggleColor(false, i, undefined, tempColors[i].changedColor || tempColors[i].color, false);
        }
      } // generate new preview object


      if (hasPreview) {
        for (i = prevInd; i < s.select; ++i) {
          tempPreviewValues[i] = {};

          if ($colorPreviewItems) {
            $colorPreviewItems.eq(i).addClass('mbsc-color-preview-item-empty').css({
              background: 'transparent'
            });
          }
        }
      }

      previewValues = extend$1(true, {}, tempPreviewValues);

      if (updateInput !== false) {
        generateInputItems();
      }
    }

    function toggleColor(add, colorIndex, colorPreviewInd, currValue, updatePreview, updateValue) {
      if (hasPreview && updatePreview) {
        tempPreviewValues[colorPreviewInd].colorIndex = add ? colorIndex : undefined;
        tempPreviewValues[colorPreviewInd].color = add ? currValue : undefined;

        if ($colorPreviewItems) {
          var colorPrevItem = $colorPreviewItems.eq(colorPreviewInd);
          colorPrevItem.removeClass('mbsc-color-preview-item-empty').css({
            background: add ? currValue : 'transparent'
          });

          if (!add) {
            colorPrevItem.addClass('mbsc-color-preview-item-empty').parent().removeClass('mbsc-color-active');
          }
        }
      }

      if (updateValue) {
        if (add) {
          that._tempValue.splice(colorPreviewInd, 0, currValue);
        } else {
          that._tempValue.splice(that._tempValue.indexOf(currValue), 1);
        }
      }

      if ($colorItems) {
        if (add) {
          $colorItems.eq(colorIndex).addClass('mbsc-color-selected');
        } else {
          $colorItems.eq(colorIndex).removeClass('mbsc-color-selected').parent().removeClass('mbsc-color-active');
        }
      }

      tempColors[colorIndex].previewInd = add ? colorPreviewInd : undefined;
      tempColors[colorIndex].selected = add;
    }

    function setDefaultValues(colorInd, ctx) {
      if (colorInd !== undefined && (singleSelect || tempColors[colorInd] && tempColors[colorInd].selected)) {
        colorIndex = colorInd;

        if (tempColors[colorInd]) {
          currValue = tempColors[colorInd].changedColor || tempColors[colorInd].color;
          $currItem = $colorItems.eq(colorInd); // refresh slider tempColors

          if (refineMode) {
            highlightActiveColor($colorItems.eq(colorInd), ctx || '');
            currHslValue = convertToFormat(tempColors[colorInd].color, 'hsl');
            currHslValue.l = convertToFormat(currValue, 'hsl').l;
            changeSliderStepsColor(tempColors[colorInd].color);
            slider.setVal(100 - currHslValue.l, false, false);
          }
        }
      } else if (refineMode) {
        changeSliderStepsColor();
      }
    }

    function getColorObjects() {
      var i,
          arr = [];

      for (i = 0; i < tempColors.length; ++i) {
        if (tempColors[i].selected) {
          arr.push(tempColors[i]);
        }
      }

      return arr;
    }

    function colorPreviewTap(ev, $m) {
      var index = $$1(ev.target).index();
      colorIndex = tempPreviewValues[index].colorIndex;
      $currItem = $colorItems.eq(colorIndex); // refresh values

      colorPreviewInd = index;
      setDefaultValues(colorIndex, $m);
      scrollView.scroll($currItem, 250);
      trigger('onPreviewItemTap', {
        target: ev.target,
        value: tempPreviewValues[index].color,
        index: index
      });
    }

    function colorTap(ev, $m) {
      var hasSelect = false,
          $selectedtempColors = $$1('.mbsc-color-selected', $m);
      $currItem = $$1(ev.target);

      if ($currItem.hasClass('mbsc-color-clear-item')) {
        currValue = '';
        that.clear();
        return;
      }

      if ((singleSelect || maxSelect > +$selectedtempColors.length || $currItem.hasClass('mbsc-color-selected')) && mobiscroll.owfBP) {
        colorIndex = $currItem.attr('data-index');

        if (hasPreview) {
          colorPreviewInd = tempColors[colorIndex].previewInd !== undefined ? tempColors[colorIndex].previewInd : getFirstEmptyPreviewIndex();
          hasSelect = refineMode && $currItem.hasClass('mbsc-color-selected') && !$currItem.parent().hasClass('mbsc-color-active'); // scroll to the preview color

          if ($colorPreviewItems.length > 6) {
            previewScrollView.scroll($colorPreviewItems.eq(colorPreviewInd));
          }
        }

        currValue = tempColors[colorIndex].changedColor || tempColors[colorIndex].color;

        if (singleSelect) {
          $selectedtempColors.removeClass('mbsc-color-selected');
          that._tempValue = currValue;

          if (currValue) {
            $currItem.toggleClass('mbsc-color-selected');
          }

          highlightActiveColor($currItem, $m);
        } else {
          highlightActiveColor($currItem, $m);

          if (!hasSelect) {
            toggleColor(!tempColors[colorIndex].selected, colorIndex, colorPreviewInd, currValue, true, true);
          }
        }

        setDefaultValues(colorIndex, $m);

        if (that.live) {
          that._fillValue();

          trigger('onSet', {
            value: that._value
          });
        }

        trigger('onItemTap', {
          target: ev.target,
          value: currValue,
          selected: tempColors[colorIndex].selected,
          index: colorIndex
        });

        that._updateHeader();
      }
    } // Call the parent constructor


    Frame.call(this, el, settings, true); // Public functions

    /**
     * Sets the value
     */

    that.setVal = that._setVal = function (val, fill, change, temp) {
      that._hasValue = val !== null && val !== undefined;
      that._tempValue = singleSelect ? $$1.isArray(val) ? val[0] : val : $$1.isArray(val) ? val : val ? [val] : [];
      setValue(fill, change === undefined ? fill : change, temp);
    };
    /**
     * Returns the selected value
     */


    that.getVal = that._getVal = function (temp) {
      return that._hasValue || temp ? returnObj ? getColorObjects() : that[temp ? '_tempValue' : '_value'] : null;
    };

    that._readValue = function () {
      var v = $elm.val() || '';
      that._hasValue = false;

      if (v.length !== 0 && v !== '') {
        that._hasValue = true;
      }

      if (that._hasValue) {
        that._tempValue = singleSelect ? v : s.format == 'hex' ? v.split(',') : v.match(/[a-z]{3}\((\d+\.?\d{0,}?),\s*([\d.]+)%{0,},\s*([\d.]+)%{0,}\)/gmi);
        setValue(true);
      } else {
        that._tempValue = [];
      }

      refreshSelectedValues(that._tempValue, that._hasValue);
    };

    that._fillValue = function () {
      that._hasValue = true;
      setValue(true, true);
    };

    that._generateContent = function () {
      var i,
          html,
          currColor,
          colorOffset = hasClear ? 1 : 0;
      rowItems = isHorizontalScroll ? Math.ceil((tempColors.length + colorOffset) / s.rows) : s.rows; // generate color content

      html = '<div class="mbsc-color-scroll-cont mbsc-w-p ' + (isHorizontalScroll ? '' : 'mbsc-color-vertical') + '"><div class="mbsc-color-cont">' + (isHorizontalScroll ? '<div class="mbsc-color-row">' : '');

      for (i = 0; i < tempColors.length; ++i) {
        currColor = tempColors[i].changedColor || tempColors[i].color;

        if (hasClear && i === 0) {
          html += '<div class="mbsc-color-item-c"><div tabindex="0" class="mbsc-color-clear-item mbsc-btn-e mbsc-color-selected"><div class="mbsc-color-clear-cross"></div></div></div>';
        }

        if (i !== 0 && (i + colorOffset) % rowItems === 0) {
          html += isHorizontalScroll ? '</div><div class="mbsc-color-row">' : '';
        }

        html += '<div class="mbsc-color-item-c"><div tabindex="0" data-index="' + i + '" class="mbsc-color-item mbsc-btn-e mbsc-ic mbsc-ic-material-check mbsc-color-btn-e ' + (tempColors[i].selected ? 'mbsc-color-selected' : '') + '"  style="background:' + currColor + '"></div>' + that._getText(mobiscroll, 0.2) + '</div>';
      }

      html += '</div></div>' + (isHorizontalScroll ? '</div>' : '');

      if (refineMode) {
        // add refine slider 
        html += '<div class="mbsc-color-slider-cont"><input class="mbsc-color-slider" type="range" data-highlight="false" value="50" min="0" max="100"/></div>';
      } // add preview container 


      if (hasPreview) {
        html += '<div class="mbsc-color-preview-cont"><div class="mbsc-color-refine-preview">';

        for (var c in previewValues) {
          html += '<div class="mbsc-color-preview-item-c mbsc-btn-e mbsc-color-btn-e" tabindex="0"><div class="mbsc-color-preview-item ' + (previewValues[c].color ? '' : 'mbsc-color-preview-item-empty') + '" style="background: ' + (previewValues[c].color || 'initial') + ';"></div></div>';
        }

        html += '</div></div>';
      }

      return html;
    };

    that._position = function ($m) {
      var colorCont, colorItemWidth;

      if (!isHorizontalScroll) {
        colorCont = $m.find('.mbsc-color-cont');
        colorItemWidth = Math.ceil(colorCont.find('.mbsc-color-item-c')[0].offsetWidth);
        colorCont.width(Math.min(Math.floor($m.find('.mbsc-fr-c').width() / colorItemWidth), Math.round(tempColors.length / s.rows)) * colorItemWidth + 1);
      }

      if (scrollView) {
        scrollView.refresh();
      }

      if (previewScrollView) {
        previewScrollView.refresh();
      }
    };

    that._markupInserted = function ($markup) {
      if (!isHorizontalScroll) {
        $markup.find('.mbsc-color-scroll-cont').css('max-height', $markup.find('.mbsc-color-item-c')[0].offsetHeight * s.rows);
      } // init color scrollView


      scrollView = new ScrollViewBase($markup.find('.mbsc-color-scroll-cont')[0], {
        axis: isHorizontalScroll ? 'X' : 'Y',
        rtl: s.rtl,
        elastic: 60,
        stopProp: false,
        mousewheel: s.mousewheel,
        onBtnTap: function onBtnTap(ev) {
          colorTap(ev, $markup);
        }
      });
    };

    that._attachEvents = function ($markup) {
      var modifiedColor;
      $colorItems = $$1('.mbsc-color-item', $markup); // handle color selection with space

      $markup.on('keydown', '.mbsc-color-btn-e', function (ev) {
        ev.stopPropagation();

        if (ev.keyCode == 32) {
          // Space 
          if (ev.target.classList.contains('mbsc-color-item')) {
            colorTap(ev, $markup);
          } else {
            colorPreviewTap(ev, $markup);
          }
        }
      });

      if (hasPreview) {
        $colorPreviewItems = $$1('.mbsc-color-preview-item', $markup);
      } // refine mode 


      if (refineMode) {
        $markup.addClass('mbsc-color-refine');
        $sliderElm = $$1('.mbsc-color-slider', $markup);
        slider = new Slider($sliderElm[0], {
          theme: s.theme,
          rtl: s.rtl
        });
        sliderTrack = $markup.find('.mbsc-progress-track'); // change slider track step color

        if (colorIndex && that._value) {
          setDefaultValues(colorIndex, $markup);
        }

        $sliderElm.on('change', function () {
          if (colorIndex !== undefined && (singleSelect || tempColors[colorIndex] && tempColors[colorIndex].selected)) {
            currHslValue.l = 100 - this.value;
            modifiedColor = convertToFormat(currHslValue.toString()).toString();

            if (singleSelect) {
              that._tempValue = modifiedColor;
            } else {
              that._tempValue[colorPreviewInd !== undefined ? colorPreviewInd : that._tempValue.length] = modifiedColor;
            }

            tempColors[colorIndex].tempChangedColor = modifiedColor;
            $colorItems.eq(colorIndex).css('background', modifiedColor);

            if (hasPreview) {
              tempPreviewValues[colorPreviewInd].color = modifiedColor;
              $colorPreviewItems.eq(colorPreviewInd).removeClass('mbsc-color-preview-item-empty').css({
                'background': modifiedColor
              });
            }

            if (that.live) {
              throttle(that._fillValue());
            }
          }
        });
      }

      if (hasPreview) {
        // init colorprevirew scrollview
        previewScrollView = new ScrollViewBase($markup.find('.mbsc-color-preview-cont')[0], {
          axis: 'X',
          rtl: s.rtl,
          stopProp: false,
          mousewheel: s.mousewheel,
          onBtnTap: function onBtnTap(ev) {
            colorPreviewTap(ev, $markup);
          }
        });
      }

      that._updateHeader();
    };

    that._markupRemove = function () {
      if (scrollView) {
        scrollView.destroy();
      }

      if (slider) {
        slider.destroy();
      }

      if (previewScrollView) {
        previewScrollView.destroy();
      }
    };

    that.__processSettings = function () {
      var i, data;
      s = that.settings;
      trigger = that.trigger;
      isHorizontalScroll = s.navigation == 'horizontal';
      that._value = [];
      that._tempValue = [];
      singleSelect = s.select == 'single';
      hasClear = s.clear !== undefined ? s.clear : singleSelect;
      data = s.data || [];

      if (!data.length) {
        switch (s.format) {
          case 'rgb':
            data = ["rgb(255,235,60)", "rgb(255,153,0)", "rgb(244,68,55)", "rgb(234,30,99)", "rgb(156,38,176)", "rgb(104,58,183)", "rgb(63,81,181)", "rgb(33,150,243)", "rgb(0,151,136)", "rgb(75,175,79)", "rgb(126,93,78)", "rgb(158,158,158)"];

            if (hasClear) {
              data.splice(10, 0, 'rgb(83, 71, 65)');
            }

            break;

          case 'hsl':
            data = ["hsl(54,100%,62%)", "hsl(36,100%,50%)", "hsl(4,90%,59%)", "hsl(340,83%,52%)", "hsl(291,64%,42%)", "hsl(262,52%,47%)", "hsl(231,48%,48%)", "hsl(207,90%,54%)", "hsl(174,100%,30%)", "hsl(122,40%,49%)", "hsl(19,24%,40%)", "hsl(0,0%,62%)"];

            if (hasClear) {
              data.splice(10, 0, 'hsl(20, 12%, 29%)');
            }

            break;

          default:
            data = ['#ffeb3c', '#ff9900', '#f44437', '#ea1e63', '#9c26b0', '#683ab7', '#3f51b5', '#2196f3', '#009788', '#4baf4f', '#7e5d4e', '#9e9e9e'];

            if (hasClear) {
              data.splice(10, 0, '#534741');
            }

        }
      }

      refineMode = s.mode == 'refine';
      hasPreview = !isNaN(s.select);
      maxSelect = isNaN(s.select) ? singleSelect ? 2 : data.length : s.select;
      returnObj = $$1.isPlainObject(data[0]); // generate preview object

      if (hasPreview && !Object.keys(previewValues).length) {
        for (i = 0; i < s.select; ++i) {
          previewValues[i] = {};
          tempPreviewValues[i] = {};
        }
      }

      tempColors = data.slice(0); // convert tempColors into objects

      for (i = 0; i < tempColors.length; ++i) {
        if (!$$1.isPlainObject(data[i])) {
          data[i] = data[i].toLowerCase();
          tempColors[i] = {
            key: i,
            name: data[i],
            color: data[i]
          };
        } else {
          tempColors[i].color = data[i].color;
        }
      }

      def = s.defaultValue || tempColors[0].color;
      currValue = def;
      currHslValue = convertToFormat(currValue, 'hsl');
      enhanceInput = s.enhance && $elm.is('input'); // Create dummy input

      if (enhanceInput) {
        if ($elm.hasClass('mbsc-color-input-hdn')) {
          $input = $elm.prev();
        } else {
          $input = $$1('<div ' + (el.placeholder ? 'data-placeholder="' + el.placeholder + '"' : '') + ' class="mbsc-control mbsc-color-input ' + (s.inputClass || '') + '" readonly ></div>');
          $input.insertBefore($elm);
          $elm.addClass('mbsc-color-input-hdn').attr('tabindex', -1);
        }

        s.anchor = $input;
        that.attachShow($input);
      }
    };

    that.__destroy = function () {
      if (enhanceInput) {
        $elm.removeClass('mbsc-color-input-hdn');
        $input.remove();
      }
    };

    that._checkSize = true; // Constructor

    if (!inherit) {
      that.init();
    }
  }; // Extend defaults

  Color.prototype = {
    _hasDef: true,
    _hasTheme: true,
    _hasLang: true,
    _class: 'color',
    _defaults: extend$1({}, Frame.prototype._defaults, {
      headerText: false,
      validate: noop,
      parseValue: noop,
      enhance: true,
      rows: 2,
      select: 'single',
      format: 'hex',
      navigation: 'horizontal',
      compClass: 'mbsc-color'
    })
  };
  classes.Color = Color;
  mobiscroll.themes.color = mobiscroll.themes.frame; // Expose utility functions

  util.color = {
    hsv2hex: hsv2hex,
    hsv2rgb: hsv2rgb,
    rgb2hsv: rgb2hsv,
    rgb2hex: rgb2hex,
    rgb2hsl: rgb2hsl,
    hex2rgb: hex2rgb,
    hex2hsv: hex2hsv,
    hex2hsl: hex2hsl
  };

  var MbscColor = (function (_super) {
      __extends(MbscColor, _super);
      function MbscColor(initialElem, zone, control, inputService, optionService, view) {
          var _this = _super.call(this, initialElem, zone, control, inputService, view) || this;
          _this.optionService = optionService;
          _this.enhance = false;
          _this.onSet = new core.EventEmitter();
          _this.onClear = new core.EventEmitter();
          _this.onItemTap = new core.EventEmitter();
          _this.onPreviewItemTap = new core.EventEmitter();
          _this.options = {};
          _this.onChangeEmitter = new core.EventEmitter();
          return _this;
      }
      Object.defineProperty(MbscColor.prototype, "value", {
          set: function (v) {
              this.setNewValueProxy(v);
          },
          enumerable: true,
          configurable: true
      });
      MbscColor.prototype.refreshData = function (newData) {
          this.instance.option('data', newData);
      };
      MbscColor.prototype.initControl = function () {
          var options = extend$1({}, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
          this.instance = new Color(this.element, options);
          if (this.initialValue !== undefined) {
              this.instance.setVal(this.initialValue, true, false);
          }
      };
      MbscColor.prototype.setNewValue = function (v) {
          if (this.instance) {
              var changed = void 0;
              if (this.isMulti) {
                  changed = !deepEqualsArray(v, this.instance.getVal());
              }
              else {
                  var innerValue = this.instance.getVal();
                  changed = innerValue !== v;
              }
              if (changed) {
                  this.instance.setVal(v, true, false);
                  if (this._inputService && this._inputService.input) {
                      this._inputService.input.innerValue = this.instance._value;
                  }
              }
          }
      };
      MbscColor.prototype.ngOnInit = function () {
          this.isMulti = this.options && this.options.select && this.options.select !== 'single';
          this.cloneDictionary.data = [];
          _super.prototype.ngOnInit.call(this);
      };
      MbscColor.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mbsc-color]',
                      exportAs: 'mobiscroll'
                  },] },
      ];
      MbscColor.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: core.ViewContainerRef, },
      ]; };
      MbscColor.propDecorators = {
          'clear': [{ type: core.Input },],
          'data': [{ type: core.Input, args: ['mbsc-data',] },],
          'defaultValue': [{ type: core.Input },],
          'enhance': [{ type: core.Input },],
          'format': [{ type: core.Input },],
          'inputClass': [{ type: core.Input },],
          'mode': [{ type: core.Input },],
          'navigation': [{ type: core.Input },],
          'preview': [{ type: core.Input },],
          'previewText': [{ type: core.Input },],
          'rows': [{ type: core.Input },],
          'valueText': [{ type: core.Input },],
          'select': [{ type: core.Input },],
          'onSet': [{ type: core.Output },],
          'onClear': [{ type: core.Output },],
          'onItemTap': [{ type: core.Output },],
          'onPreviewItemTap': [{ type: core.Output },],
          'options': [{ type: core.Input, args: ['mbsc-options',] },],
          'value': [{ type: core.Input, args: ['mbsc-color',] },],
          'onChangeEmitter': [{ type: core.Output, args: ['mbsc-colorChange',] },],
      };
      return MbscColor;
  }(MbscFrameBase));
  var MbscColorComponent = (function (_super) {
      __extends(MbscColorComponent, _super);
      function MbscColorComponent(initialElem, zone, control, inputService, optionService) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
          _this.errorMessage = '';
          _this.placeholder = '';
          _this.enhance = true;
          return _this;
      }
      MbscColorComponent.prototype.ngAfterViewInit = function () {
          _super.prototype.ngAfterViewInit.call(this);
          this.setThemeClasses();
      };
      MbscColorComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-color',
                      exportAs: 'mobiscroll',
                      template: INPUT_TEMPLATE
                  },] },
      ];
      MbscColorComponent.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscColorComponent.propDecorators = {
          'inputIcon': [{ type: core.Input, args: ['icon',] },],
          'iconAlign': [{ type: core.Input, args: ['icon-align',] },],
          'name': [{ type: core.Input },],
          'error': [{ type: core.Input },],
          'errorMessage': [{ type: core.Input },],
          'options': [{ type: core.Input },],
          'placeholder': [{ type: core.Input },],
          'data': [{ type: core.Input },],
          'enhance': [{ type: core.Input },],
      };
      return MbscColorComponent;
  }(MbscColor));
  var MbscColorModule = (function () {
      function MbscColorModule() {
      }
      MbscColorModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule, MbscFrameBaseModule, MbscInputModule],
                      declarations: [MbscColor, MbscColorComponent],
                      exports: [MbscColor, MbscColorComponent]
                  },] },
      ];
      MbscColorModule.ctorParameters = function () { return []; };
      return MbscColorModule;
  }());

  var DateTime$1 = Scroller;
  presets.date = DateTime;
  presets.time = DateTime;
  presets.datetime = DateTime;

  var MbscDateBase = (function (_super) {
      __extends(MbscDateBase, _super);
      function MbscDateBase(initialElem, zone, control, inputService, optionService, view) {
          var _this = _super.call(this, initialElem, zone, control, inputService, view) || this;
          _this.optionService = optionService;
          _this.options = {};
          _this.preset = 'date';
          _this.onChangeEmitter = new core.EventEmitter();
          return _this;
      }
      Object.defineProperty(MbscDateBase.prototype, "value", {
          set: function (v) {
              this.setNewValueProxy(v);
          },
          enumerable: true,
          configurable: true
      });
      MbscDateBase.prototype.setNewValue = function (v) {
          if (this.instance) {
              var innerValue = this.instance.getVal();
              if ((!innerValue && v) ||
                  (innerValue && !v) ||
                  (innerValue && v && innerValue.toString() !== v.toString())) {
                  this.instance.setVal(v, true, false);
                  if (this._inputService && this._inputService.input) {
                      this._inputService.input.innerValue = this.instance._value;
                  }
              }
          }
      };
      MbscDateBase.prototype.initControl = function () {
          var options = extend$1({ preset: this.preset }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
          this.instance = new DateTime$1(this.element, options);
          if (this.initialValue !== undefined && this.initialValue !== "") {
              this.instance.setVal(this.initialValue, true, false);
          }
      };
      MbscDateBase.decorators = [
          { type: core.Directive, args: [{ selector: '[mbsc-dt-b]' },] },
      ];
      MbscDateBase.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, },
          { type: MbscInputService, },
          { type: MbscOptionsService, },
          { type: core.ViewContainerRef, },
      ]; };
      MbscDateBase.propDecorators = {
          'options': [{ type: core.Input, args: ['mbsc-options',] },],
          'value': [{ type: core.Input, args: ['mbsc-date',] },],
          'onChangeEmitter': [{ type: core.Output, args: ['mbsc-dateChange',] },],
      };
      return MbscDateBase;
  }(MbscDatetimeBase));
  var MbscDate = (function (_super) {
      __extends(MbscDate, _super);
      function MbscDate(initialElem, zone, control, inputService, optionService, view) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;
          _this.preset = 'date';
          return _this;
      }
      MbscDate.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mbsc-date]',
                      exportAs: 'mobiscroll'
                  },] },
      ];
      MbscDate.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: core.ViewContainerRef, },
      ]; };
      return MbscDate;
  }(MbscDateBase));
  var MbscDateComponent = (function (_super) {
      __extends(MbscDateComponent, _super);
      function MbscDateComponent(initialElem, zone, control, inputService, optionService) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
          _this.errorMessage = '';
          _this.placeholder = '';
          return _this;
      }
      MbscDateComponent.prototype.ngAfterViewInit = function () {
          _super.prototype.ngAfterViewInit.call(this);
          this.setThemeClasses();
      };
      MbscDateComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-date',
                      exportAs: 'mobiscroll',
                      template: INPUT_TEMPLATE
                  },] },
      ];
      MbscDateComponent.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscDateComponent.propDecorators = {
          'inputIcon': [{ type: core.Input, args: ['icon',] },],
          'iconAlign': [{ type: core.Input, args: ['icon-align',] },],
          'name': [{ type: core.Input },],
          'error': [{ type: core.Input },],
          'errorMessage': [{ type: core.Input },],
          'options': [{ type: core.Input },],
          'placeholder': [{ type: core.Input },],
      };
      return MbscDateComponent;
  }(MbscDate));
  var MbscTime = (function (_super) {
      __extends(MbscTime, _super);
      function MbscTime(initialElem, zone, control, inputService, optionService, view) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;
          _this.onChangeEmitter = new core.EventEmitter();
          _this.preset = 'time';
          return _this;
      }
      Object.defineProperty(MbscTime.prototype, "value", {
          set: function (v) {
              this.setNewValueProxy(v);
          },
          enumerable: true,
          configurable: true
      });
      MbscTime.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mbsc-time]',
                      exportAs: 'mobiscroll'
                  },] },
      ];
      MbscTime.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: core.ViewContainerRef, },
      ]; };
      MbscTime.propDecorators = {
          'value': [{ type: core.Input, args: ['mbsc-time',] },],
          'onChangeEmitter': [{ type: core.Output, args: ['mbsc-timeChange',] },],
      };
      return MbscTime;
  }(MbscDateBase));
  var MbscTimeComponent = (function (_super) {
      __extends(MbscTimeComponent, _super);
      function MbscTimeComponent(initialElem, zone, control, inputService, optionService) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
          _this.errorMessage = '';
          _this.placeholder = '';
          return _this;
      }
      MbscTimeComponent.prototype.ngAfterViewInit = function () {
          _super.prototype.ngAfterViewInit.call(this);
          this.setThemeClasses();
      };
      MbscTimeComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-time',
                      exportAs: 'mobiscroll',
                      template: INPUT_TEMPLATE
                  },] },
      ];
      MbscTimeComponent.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscTimeComponent.propDecorators = {
          'inputIcon': [{ type: core.Input, args: ['icon',] },],
          'iconAlign': [{ type: core.Input, args: ['icon-align',] },],
          'name': [{ type: core.Input },],
          'error': [{ type: core.Input },],
          'errorMessage': [{ type: core.Input },],
          'options': [{ type: core.Input },],
          'placeholder': [{ type: core.Input },],
      };
      return MbscTimeComponent;
  }(MbscTime));
  var MbscDatetime = (function (_super) {
      __extends(MbscDatetime, _super);
      function MbscDatetime(initialElem, zone, control, inputService, optionService, view) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;
          _this.onChangeEmitter = new core.EventEmitter();
          _this.preset = 'datetime';
          return _this;
      }
      Object.defineProperty(MbscDatetime.prototype, "value", {
          set: function (v) {
              this.setNewValueProxy(v);
          },
          enumerable: true,
          configurable: true
      });
      MbscDatetime.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mbsc-datetime]',
                      exportAs: 'mobiscroll'
                  },] },
      ];
      MbscDatetime.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: core.ViewContainerRef, },
      ]; };
      MbscDatetime.propDecorators = {
          'value': [{ type: core.Input, args: ['mbsc-datetime',] },],
          'onChangeEmitter': [{ type: core.Output, args: ['mbsc-datetimeChange',] },],
      };
      return MbscDatetime;
  }(MbscDateBase));
  var MbscDatetimeComponent = (function (_super) {
      __extends(MbscDatetimeComponent, _super);
      function MbscDatetimeComponent(initialElem, zone, control, inputService, optionService) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
          _this.errorMessage = '';
          _this.placeholder = '';
          return _this;
      }
      MbscDatetimeComponent.prototype.ngAfterViewInit = function () {
          _super.prototype.ngAfterViewInit.call(this);
          this.setThemeClasses();
      };
      MbscDatetimeComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-datetime',
                      exportAs: 'mobiscroll',
                      template: INPUT_TEMPLATE
                  },] },
      ];
      MbscDatetimeComponent.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscDatetimeComponent.propDecorators = {
          'inputIcon': [{ type: core.Input, args: ['icon',] },],
          'iconAlign': [{ type: core.Input, args: ['icon-align',] },],
          'name': [{ type: core.Input },],
          'error': [{ type: core.Input },],
          'errorMessage': [{ type: core.Input },],
          'options': [{ type: core.Input },],
          'placeholder': [{ type: core.Input },],
      };
      return MbscDatetimeComponent;
  }(MbscDatetime));
  var comp$2 = [MbscDateBase, MbscDate, MbscDateComponent, MbscTime, MbscTimeComponent, MbscDatetime, MbscDatetimeComponent];
  var MbscDatetimeModule = (function () {
      function MbscDatetimeModule() {
      }
      MbscDatetimeModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule, MbscDatetimeBaseModule, MbscInputModule],
                      declarations: comp$2,
                      exports: comp$2
                  },] },
      ];
      MbscDatetimeModule.ctorParameters = function () { return []; };
      return MbscDatetimeModule;
  }());

  var Popup = function Popup(el, settings, inherit) {
    function addContent($m) {
      $$1('.mbsc-fr-c', $m).append(that._getText(mobiscroll, 0.7));

      if (!$$1('.mbsc-fr-c', $m).hasClass('mbsc-wdg-c') && mobiscroll.owfBP) {
        $$1('.mbsc-fr-c', $m).addClass('mbsc-wdg-c').append($elm.show());

        if (!$$1('.mbsc-w-p', $m).length) {
          $$1('.mbsc-fr-c', $m).addClass('mbsc-w-p');
        }
      }
    }

    var s,
        $prev,
        $elm = $$1(el),
        that = this; // Call the parent constructor

    Frame.call(this, el, settings, true);

    that._generateContent = function () {
      return '';
    };

    that._markupReady = function ($m) {
      if (s.display != 'inline') {
        addContent($m);
      }
    };

    that._markupInserted = function ($m) {
      if (s.display == 'inline') {
        addContent($m);
      }

      $m.trigger('mbsc-enhance', [{
        theme: s.theme,
        lang: s.lang
      }]);
    };

    that._markupRemove = function () {
      $elm.hide();

      if ($prev && $prev.parent().length) {
        $prev.after($elm);
      }
    };

    that.__processSettings = function () {
      s = that.settings;
      that.buttons.ok = {
        text: s.okText,
        icon: s.okIcon,
        handler: 'set'
      };
      s.buttons = s.buttons || (s.display == 'inline' ? [] : ['ok']);

      if (!$prev && $elm.parent().length) {
        $prev = $$1(document.createComment('popup'));
        $elm.before($prev);
      }

      $elm.hide();
    }; // Constructor


    if (!inherit) {
      that.init();
    }
  };
  Popup.prototype = {
    _hasDef: true,
    _hasTheme: true,
    _hasContent: true,
    _hasLang: true,
    _responsive: true,
    _class: 'popup',
    _defaults: extend$1({}, Frame.prototype._defaults, {
      compClass: 'mbsc-wdg',
      okText: 'OK',
      headerText: false
    })
  };
  classes.Popup = Popup;
  classes.Widget = Popup;
  mobiscroll.themes.popup = mobiscroll.themes.frame;

  // eslint-disable-next-line no-unused-vars
  var Eventcalendar = Scroller;

  function getHeight(el) {
    var style = getComputedStyle(el);
    return el.innerHeight || el.clientHeight - parseFloat(style.paddingTop) - parseFloat(style.paddingBottom);
  }

  var defaults$4 = {
    view: {
      calendar: {
        type: 'month',
        popover: true
      }
    },
    // Localization
    allDayText: 'All-day',
    labelsShort: ['Yrs', 'Mths', 'Days', 'Hrs', 'Mins', 'Secs'],
    eventText: 'event',
    eventsText: 'events',
    noEventsText: 'No events'
  },
      overrides = {
    yearChange: false,
    weekDays: 'short'
  };

  presets.eventcalendar = function (inst, settings, resp) {
    // Private functions
    // ---
    function processSettings() {
      var view = s.view,
          calendar = view.calendar,
          list = view.eventList,
          months = s.months,
          weeks = s.weeks;

      if (calendar) {
        if (calendar.type == 'week') {
          weeks = calendar.size || 1;
        } else if (calendar.size) {
          months = calendar.size;
        }

        isListOnly = false;
      } else {
        weeks = 0;
        isListOnly = true;
      }

      if (list) {
        listType = list.type;
        listSize = list.size || 1;
      }

      multiLabel = calendar && calendar.labels;
      scrollEventList = list && list.scrollable;
      showEventList = view.eventList;
      showEventBubble = s.eventBubble === undefined ? calendar && calendar.popover : s.eventBubble;
      s.weeks = weeks;
      s.months = months;
    }

    function updateTitle(firstDay, lastDay) {
      var title,
          monthIndex = (s.dateWheels || s.dateFormat).search(/m/i),
          yearIndex = (s.dateWheels || s.dateFormat).search(/y/i),
          firstYear = s.getYear(firstDay),
          firstMonth = s.getMonth(firstDay),
          lastYear = s.getYear(lastDay),
          lastMonth = s.getMonth(lastDay);

      inst._checkBtn($$1('.mbsc-cal-prev-m', $ctx), getDateOnly(firstDay) <= inst._minDate);

      inst._checkBtn($$1('.mbsc-cal-next-m', $ctx), getDateOnly(lastDay) >= inst._maxDate);

      if (listType == 'day') {
        title = formatDate(s.dateFormat, firstDay, s) + (listSize > 1 ? ' - ' + formatDate(s.dateFormat, lastDay, s) : '');
      } else if (listType == 'week') {
        title = formatDate(s.dateFormat, firstDay, s) + ' - ' + formatDate(s.dateFormat, lastDay, s);
      } else if (listType == 'month') {
        if (listSize == 1) {
          title = yearIndex < monthIndex ? firstYear + ' ' + s.monthNames[firstMonth] : s.monthNames[firstMonth] + ' ' + firstYear;
        } else {
          title = yearIndex < monthIndex ? firstYear + ' ' + s.monthNamesShort[firstMonth] + ' - ' + lastYear + ' ' + s.monthNamesShort[lastMonth] : s.monthNamesShort[firstMonth] + ' ' + firstYear + ' - ' + s.monthNamesShort[lastMonth] + ' ' + lastYear;
        }
      } else if (listType == 'year') {
        title = firstYear + (listSize > 1 ? " - " + lastYear : '');
      }

      $viewTitle.html(title);
    }

    function createEventList(firstDay, lastDay, eventObj) {
      var d,
          i,
          j,
          ev,
          $items,
          count = 0,
          allEvents = [],
          eventHtml = '',
          events = [];

      if (!eventObj) {
        eventObj = inst._prepareObj(eventList, firstDay, lastDay);
      }

      for (d = getDateOnly(firstDay); d <= lastDay; d.setDate(d.getDate() + 1)) {
        ev = eventObj[getDateOnly(d)];

        if (ev && ev.length) {
          events.push({
            d: new Date(d),
            list: sortEvents(ev)
          });
        }
      }

      if (events.length > 0) {
        for (i = 0; i < events.length; i++) {
          ev = events[i];
          eventHtml += '<div><div class="mbsc-lv-gr-title mbsc-event-day" data-full="' + getDateStr(ev.d) + '">' + formatDate(s.dateFormat, ev.d, s) + '</div>';

          for (j = 0; j < ev.list.length; j++) {
            var event = ev.list[j],
                start = event.start ? makeDate(event.start) : null,
                end = event.end ? makeDate(event.end) : null,
                color = event.color,
                isRepeating = DAY_OF_WEEK.test(event.d) || DAY_OF_MONTH.test(event.d),
                isMultiDay = start && end && !isSameDay(start, end),
                isFirstDay = isMultiDay ? isSameDay(start, ev.d) : true,
                isLastDay = isMultiDay ? isSameDay(end, ev.d) : true,
                dt = event.d ? isRepeating ? event.d : makeDate(event.d) : start,
                allDay = event.allDay || isRepeating || isMultiDay && !isFirstDay && !isLastDay;
            allEvents.push({
              d: ev.d,
              e: event
            });
            eventHtml += '<div tabindex="0" role="button" class="mbsc-lv-item mbsc-lv-item-actionable" data-index="' + count + '"><div class="mbsc-event-time">' + (allDay ? s.allDayText : isFirstDay && dt && dt.getTime ? formatDate(s.timeFormat, dt) : isMultiDay && isLastDay ? s.toText : '') + (!allDay && isLastDay && end && end.getTime ? '<br/>' + formatDate(s.timeFormat, end) : '') + '</div>' + '<div class="mbsc-event-color"' + (color ? ' style="background:' + color + ';"' : '') + '></div>' + '<div class="mbsc-event-txt">' + event.text + '</div>' + inst._getText(mobiscroll, 0.3) + '</div>';
            count++;
          }

          eventHtml += '</div>';
        }
      } else {
        eventHtml += '<div class="mbsc-lv-gr-title mbsc-event-empty"><div class="mbsc-empty"><h3>' + s.noEventsText + '</h3></div></div>';
      }

      preventScrollWatch++;
      $eventListCont.html('<div class="mbsc-lv mbsc-lv-v">' + eventHtml + '</div>').scrollTop(0);
      setTimeout(function () {
        // Need setTimeout since scroll listener is throtteled
        preventScrollWatch--;
      }, 150);
      $items = $$1('.mbsc-lv-item', $eventListCont); // Assign event click

      inst.tap($items, function (e) {
        var data = allEvents[$$1(this).attr('data-index')];
        trigger('onEventSelect', {
          domEvent: e,
          event: data.e,
          date: data.d
        });
      });
      handleFocus($items);
    }

    function handleFocus($items) {
      $items.on('keydown', function (ev) {
        if (ev.keyCode === 13 || ev.keyCode === 32) {
          this.click();
        }
      }).on('focus', function () {
        if (window.__mbscFocusVisible) {
          $$1(this).addClass('mbsc-focus');
        }
      }).on('blur', function () {
        $$1(this).removeClass('mbsc-focus');
      });
    }

    function createEventPopover() {
      if (popoverData) {
        var d = getDateOnly(popoverData.d),
            events = popoverData.events || eventObj[d],
            cell = popoverData.cell || $$1('.mbsc-cal-slide-a .mbsc-cal-day[data-full="' + getDateStr(d) + '"]', inst._markup)[0];
        showEvents(events, d, cell);
        popoverData = null;
      }
    }

    function formatDuration(start, end) {
      var lbl = s.labelsShort,
          time = end - start,
          seconds = Math.abs(time) / 1000,
          minutes = seconds / 60,
          hours = minutes / 60,
          days = hours / 24,
          years = days / 365;
      return seconds < 45 && Math.round(seconds) + ' ' + lbl[5].toLowerCase() || //seconds < 90 && '1 minute' ||
      minutes < 45 && Math.round(minutes) + ' ' + lbl[4].toLowerCase() || //minutes < 90 && '1 hour' ||
      hours < 24 && Math.round(hours) + ' ' + lbl[3].toLowerCase() || //hours < 42 && '1 day' ||
      days < 30 && Math.round(days) + ' ' + lbl[2].toLowerCase() || //days < 45 && '1 month' ||
      days < 365 && Math.round(days / 30) + ' ' + lbl[1].toLowerCase() || //years < 1.5 && '1 year' ||
      Math.round(years) + ' ' + lbl[0].toLowerCase();
    }

    function sortEvents(events) {
      return events.slice(0).sort(s.eventOrder);
    }

    function showEvents(events, d, cell) {
      if (events) {
        var $eventCont,
            $eventContInner,
            $eventScroller,
            eventScroller,
            $items,
            html = '<div class="mbsc-cal-event-list">';
        $eventCont = $$1('<div class="mbsc-cal-events ' + (s.eventBubbleClass || '') + '">' + '<div class="mbsc-cal-events-i"><div class="mbsc-cal-events-sc">' + '</div><div class="mbsc-sc-bar-c"><div class="mbsc-sc-bar"></div></div></div></div>');
        $eventContInner = $$1('.mbsc-cal-events-i', $eventCont);
        $eventScroller = $$1('.mbsc-cal-events-sc', $eventCont);
        inst.tap($eventContInner, function () {
          if (!eventScroller.scrolled) {
            hideEvents();
          }
        });
        popup = new Popup($eventCont[0], {
          display: 'bubble',
          theme: s.theme,
          lang: s.lang,
          context: s.context,
          buttons: [],
          anchor: cell,
          showOverlay: false,
          cssClass: 'mbsc-no-padding mbsc-cal-events-popup',
          onShow: function onShow() {
            eventScroller = new ScrollViewBase($eventContInner[0], {
              scrollbar: $$1('.mbsc-sc-bar-c', $eventCont),
              stopProp: false
            });
            $$1(document).on('click', hideEventsOnClick);
          },
          onClose: function onClose(event, inst) {
            inst.destroy();

            if (eventScroller) {
              eventScroller.destroy();
            }

            $$1(document).off('click', hideEventsOnClick);
          }
        }); // Store the popup on the instance, we need to destroy it in case of an option call or re-init

        inst._popup = popup;
        eventDay = cell;
        events = sortEvents(events);
        $$1.each(events, function (i, e) {
          var start = e.start ? makeDate(e.start) : null,
              end = e.end ? makeDate(e.end) : null,
              isRepeating = DAY_OF_WEEK.test(e.d) || DAY_OF_MONTH.test(e.d),
              dt = e.d ? isRepeating ? e.d : makeDate(e.d) : start,
              isMultiDay = start && end && !isSameDay(start, end),
              isFirstDay = isMultiDay ? isSameDay(start, d) : true,
              isLastDay = isMultiDay ? isSameDay(end, d) : true,
              allDay = e.allDay || isRepeating || isMultiDay && !isFirstDay && !isLastDay,
              bg = e.color,
              ariaFrom = '',
              ariaTo = '',
              ariaLabel = $$1('<div>' + e.text + '</div>').text();

          if (dt.getTime) {
            ariaFrom = formatDate((isMultiDay ? 'MM d yy ' : '') + s.timeFormat, dt);
          }

          if (end) {
            ariaTo = formatDate((isMultiDay ? 'MM d yy ' : '') + s.timeFormat, end);
          }

          html += '<div tabindex="0" role="button" title="' + ariaLabel + '" aria-label="' + ariaLabel + (ariaFrom ? ', ' + s.fromText + ': ' + ariaFrom : '') + (ariaTo ? ', ' + s.toText + ': ' + ariaTo : '') + '" class="mbsc-cal-event mbsc-lv-item mbsc-lv-item-actionable">' + '<div class="mbsc-cal-event-color" style="' + (bg ? 'background:' + bg + ';' : '') + '"></div>' + '<div class="mbsc-cal-event-text">' + '<div class="mbsc-cal-event-time">' + (allDay ? s.allDayText : isFirstDay && dt.getTime ? formatDate(s.timeFormat, dt) : '') + '</div>' + e.text + '</div>' + (start && end && !e.allDay ? '<div class="mbsc-cal-event-dur">' + s.formatDuration(start, end, e) + '</div>' : '') + '</div>';
        });
        html += '</div>';
        $eventScroller.html(html);
        popup.show();
        trigger('onEventBubbleShow', {
          target: eventDay,
          eventList: $eventCont[0]
        });
        $items = $$1('.mbsc-cal-event', $eventScroller); // Assign event click

        inst.tap($items, function (e) {
          if (!eventScroller.scrolled) {
            trigger('onEventSelect', {
              domEvent: e,
              event: events[$$1(this).index()],
              date: d
            });
          }
        });
        handleFocus($items);
        hasEventBubble = true;
      }
    }

    function onScroll() {
      var d, top, parts;

      if (!preventScrollWatch) {
        $$1('.mbsc-event-day', this).each(function () {
          top = this.offsetTop - eventListCont.scrollTop;

          if (top >= 0 && top < 35) {
            parts = $$1(this).attr('data-full').split('-');
            d = adjustedDate(parts[0], parts[1] - 1, parts[2]);

            if (!isSameDay(d, currDay)) {
              preventEventScroll = true;
              inst.setVal(d);
            }

            return false;
          }
        });
      }
    }

    function hideEvents() {
      if (popup && hasEventBubble) {
        popup.hide();
      }

      eventDay = null;
      hasEventBubble = false;
    }

    function hideEventsOnClick(e) {
      if ($$1(e.target).closest('.mbsc-cal-day').length == 0) {
        hideEvents();
      }
    }

    function refresh() {
      hideEvents();
      inst.redraw();
    }

    function getFirstLast(day) {
      var y = s.getYear(day),
          m = s.getMonth(day),
          d = s.getDay(day);
      currFirstDay = day;

      if (listType == 'day') {
        currLastDay = s.getDate(y, m, d + listSize - 1);
      } else if (listType == 'week') {
        // get first day of week
        var diff,
            weekDay = currFirstDay.getDay();
        diff = d + s.firstDay - (s.firstDay - weekDay > 0 ? 7 : 0) - weekDay;
        currFirstDay = s.getDate(y, m, diff);
        currLastDay = s.getDate(y, m, diff + listSize * 7 - 1);
      } else if (listType == 'month') {
        currFirstDay = s.getDate(y, m, 1);
        currLastDay = s.getDate(y, m + listSize, 0);
      } else if (listType == 'year') {
        currFirstDay = s.getDate(y, 0, 1);
        currLastDay = s.getDate(y + listSize, 0, 0);
      }
    }

    function scrollToDay(d, prevAnim) {
      // Scroll to the day in the list, if any
      if (showEventList && !preventEventScroll) {
        var $day = $$1('.mbsc-event-day[data-full="' + getDateStr(d) + '"]', $eventListCont);

        if ($day.length) {
          preventScrollWatch++;
          smoothScroll(eventListCont, $day.parent()[0].offsetTop, prevAnim, function () {
            // Need setTimeout since scroll listener is throtteled
            setTimeout(function () {
              preventScrollWatch--;
            }, 150);
          });
        }
      }
    }

    function triggerLoading(change, render) {
      if (change) {
        trigger('onPageChange', {
          firstDay: currFirstDay,
          lastDay: currLastDay
        });
      }

      if (!render) {
        trigger('onPageLoading', {
          firstDay: currFirstDay,
          lastDay: currLastDay
        });
      }

      trigger('onPageLoaded', {
        firstDay: currFirstDay,
        lastDay: currLastDay
      });
    } // ---


    var base,
        $ctx,
        $eventListCont,
        $viewTitle,
        currDay,
        currFirstDay,
        currLastDay,
        eventDay,
        eventListCont,
        eventObj,
        hasEventBubble,
        isChanging,
        isLabelTap,
        isListOnly,
        listType,
        listSize,
        multiLabel,
        popoverData,
        popup,
        preventEventScroll,
        preventScrollAnim,
        prevFirstDay,
        prevLastDay,
        scrollEventList,
        showEventList,
        showEventBubble,
        showMore,
        elm = this,
        orig = extend$1({}, inst.settings),
        s = extend$1(inst.settings, defaults$4, orig, overrides, settings, resp),
        preventScrollWatch = 0,
        eventID = 0,
        eventList = extend$1(true, [], s.data),
        firstLoad = true,
        trigger = inst.trigger; // Keep tracking events in settings,
    // otherwise changes will be lost on an eventual option call

    s.data = eventList;
    $$1.each(eventList, function (i, e) {
      if (e._id === undefined) {
        e._id = eventID++;
      }
    });
    processSettings();
    base = CalendarBase.call(this, inst); // Extended methods
    // ---

    inst._onGenMonth = function (start, end) {
      eventObj = inst._prepareObj(eventList, start, end);
      inst._labels = multiLabel ? eventObj : null;
    };

    inst._onRefresh = function (render) {
      preventScrollAnim = true; // Will re-create the list

      prevFirstDay = null;
      prevLastDay = null;

      if (isListOnly) {
        triggerLoading(false, render);
      }
    };

    inst._onSetDate = function (d, diff) {
      currDay = d;

      if (isListOnly) {
        if (!preventEventScroll && !isChanging) {
          getFirstLast(d);

          if (!prevFirstDay || !prevLastDay || !isSameDay(prevFirstDay, currFirstDay) || !isSameDay(prevLastDay, currLastDay)) {
            triggerLoading(true);
          }
        }
      } else if (!diff && !isChanging) {
        hideEvents();

        if (showEventList && listType == 'day') {
          // List events for the day
          createEventList(d, d, eventObj);
        }

        if ((showEventBubble || showMore) && !isLabelTap) {
          // Show event popover
          createEventPopover();
        }

        scrollToDay(d);
      }

      preventEventScroll = false;
      showMore = false;
      isLabelTap = false;
    };

    inst._getDayProps = function (d) {
      var events = eventObj[d],
          ret = {
        events: events
      };

      if (!s.marked && !s.labels && !multiLabel) {
        if (events) {
          ret.background = events[0] && events[0].background;
          ret.marked = events; // For backward compatibility

          ret.markup = s.showEventCount ? '<div class="mbsc-cal-txt">' + events.length + ' ' + (events.length > 1 ? s.eventsText : s.eventText) + '</div>' : '<div class="mbsc-cal-marks"><div class="mbsc-cal-mark"></div></div>';
        } else {
          ret.markup = s.showEventCount ? '<div class="mbsc-cal-txt-ph"></div>' : '';
        }
      }

      return ret;
    };

    inst.addEvent = function (events) {
      var ret = [];
      events = extend$1(true, [], $$1.isArray(events) ? events : [events]);
      $$1.each(events, function (i, e) {
        if (e._id === undefined) {
          e._id = eventID++;
        }

        eventList.push(e);
        ret.push(e._id);
      });
      refresh();
      return ret;
    };

    inst.updateEvent = function (event) {
      $$1.each(eventList, function (j, e) {
        if (e._id === event._id) {
          eventList.splice(j, 1, event);
          return false;
        }
      });
      refresh();
    };

    inst.removeEvent = function (eids) {
      eids = $$1.isArray(eids) ? eids : [eids];
      $$1.each(eids, function (i, eid) {
        $$1.each(eventList, function (j, e) {
          if (e._id === eid) {
            eventList.splice(j, 1);
            return false;
          }
        });
      });
      refresh();
    };

    inst.getEvents = function (d) {
      var obj;

      if (d) {
        d.setHours(0, 0, 0, 0);
        obj = inst._prepareObj(eventList, d, d);
        return obj[d] ? sortEvents(obj[d]) : [];
      }

      return extend$1(true, [], eventList);
    };

    inst.setEvents = function (events) {
      var ret = [];
      s.data = eventList = extend$1(true, [], events);
      $$1.each(eventList, function (i, e) {
        if (e._id === undefined) {
          e._id = eventID++;
        }

        ret.push(e._id);
      });
      refresh();
      return ret;
    };

    inst.navigate = function (d, anim, pop) {
      d = makeDate(d, inst._format, s);
      popoverData = pop ? {
        d: d
      } : null;
      inst.setVal(d, true, true, false, anim ? 200 : 0);
    }; // ---


    return extend$1({}, base, {
      multiLabel: multiLabel,
      headerText: false,
      buttons: s.display !== 'inline' ? ['close'] : s.buttons,
      compClass: 'mbsc-ev-cal mbsc-calendar mbsc-dt mbsc-sc',
      formatDuration: formatDuration,
      onMarkupReady: function onMarkupReady(ev, inst) {
        $ctx = $$1(ev.target);
        currDay = inst.getDate(true);

        if (showEventList) {
          $eventListCont = $$1('<div class="mbsc-lv-cont mbsc-lv-' + s.theme + (s.baseTheme ? ' mbsc-lv-' + s.baseTheme : '') + (scrollEventList ? ' mbsc-event-list-h' : '') + ' mbsc-event-list"></div>').appendTo($$1('.mbsc-fr-w', $ctx));
          $eventListCont.on('scroll', throttle(onScroll));
          eventListCont = $eventListCont[0];
        }

        base.onMarkupReady.call(this, ev);
        $viewTitle = $$1('.mbsc-cal-month', $ctx);
        hasEventBubble = false;
        getFirstLast(currDay);

        if (showEventList && isListOnly) {
          triggerLoading(); // Init navigation arrows

          createStepper($$1('.mbsc-cal-btn', $ctx), function (i, diff) {
            var y = s.getYear(currFirstDay),
                m = s.getMonth(currFirstDay),
                d = s.getDay(currFirstDay);

            if (listType == 'day') {
              currFirstDay = s.getDate(y, m, d + diff * listSize);
              currLastDay = s.getDate(y, m, d + (diff + 1) * listSize - 1);
            } else if (listType == 'week') {
              currFirstDay = s.getDate(y, m, d + diff * listSize * 7);
              currLastDay = s.getDate(y, m, d + (diff + 1) * listSize * 7 - 1);
            } else if (listType == 'month') {
              currFirstDay = s.getDate(y, m + diff * listSize, 1);
              currLastDay = s.getDate(y, m + (diff + 1) * listSize, 0);
            } else if (listType == 'year') {
              currFirstDay = s.getDate(y + diff * listSize, 0, 1);
              currLastDay = s.getDate(y + (diff + 1) * listSize, 0, 0);
            }

            triggerLoading(true);
          }, 200);
        }

        addWindowFocus();
      },
      onDayChange: function onDayChange(day) {
        var cell = day.target,
            show = cell !== eventDay;

        if (show) {
          showMore = showEventBubble !== false && $$1('.mbsc-cal-txt-more', cell).length;
          popoverData = {
            d: day.date,
            cell: s.outerMonthChange && $$1(cell).hasClass('mbsc-cal-day-diff') ? null : cell,
            events: day.events
          };
        }
      },
      onLabelTap: function onLabelTap(ev) {
        if (ev.label) {
          trigger('onEventSelect', {
            domEvent: ev.domEvent,
            event: ev.label,
            date: ev.date
          });
          isLabelTap = true;
        }
      },
      onPageChange: function onPageChange(ev) {
        hideEvents();
        isChanging = true;

        if (!inst._isSetDate) {
          inst.setVal(ev.firstDay);
        }
      },
      onPageLoaded: function onPageLoaded(ev) {
        var firstDay = ev.firstDay,
            lastDay = ev.lastDay;

        if (showEventList) {
          if (isListOnly) {
            if (!prevFirstDay || !prevLastDay || !isSameDay(prevFirstDay, firstDay) || !isSameDay(prevLastDay, lastDay)) {
              prevFirstDay = firstDay;
              prevLastDay = lastDay;
              createEventList(firstDay, lastDay);
              updateTitle(firstDay, lastDay);
            }
          } else {
            if (listType == 'month') {
              // month view
              lastDay = s.getDate(s.getYear(firstDay), s.getMonth(firstDay) + listSize, 0);
            } else if (listType == 'week') {
              // week view
              lastDay = s.getDate(s.getYear(firstDay), s.getMonth(firstDay), s.getDay(firstDay) + listSize * 7 - 1);
            } else {
              firstDay = inst.getVal(true);
              lastDay = firstDay;
            }

            createEventList(firstDay, lastDay, eventObj);
          }

          if (!firstLoad && !isSameDay(currDay, firstDay)) {
            scrollToDay(currDay, preventScrollAnim);
            preventScrollAnim = false;
          }
        }

        if (showEventBubble) {
          createEventPopover();
        }

        isChanging = false;
      },
      onPosition: function onPosition(ev) {
        base.onPosition.call(this, ev);

        if (popup) {
          popup.position();
        }

        if (showEventList && scrollEventList) {
          $eventListCont.addClass('mbsc-event-list-h');
          var context = s.display == 'inline' ? elm.parentNode : window,
              availableHeight = getHeight(context),
              listHeight = availableHeight - ev.popup.offsetHeight;
          eventListCont.style.height = listHeight > 200 ? listHeight + 'px' : '';
          $eventListCont.removeClass('mbsc-event-list-h');

          if (firstLoad && listHeight) {
            scrollToDay(currDay, true);
            firstLoad = false;
          }
        }
      },
      onHide: function onHide() {
        base.onHide.call(this); // Destroy the popup stored on the instance,
        // the local variable is lost in case of option call or re-init

        if (inst._popup) {
          inst._popup.destroy();
        }

        removeWindowFocus();
      }
    });
  };

  var MbscEventcalendar = (function (_super) {
      __extends(MbscEventcalendar, _super);
      function MbscEventcalendar(initialElem, zone, optionService) {
          var _this = _super.call(this, initialElem, zone, null, null, null) || this;
          _this.optionService = optionService;
          _this.onEventSelect = new core.EventEmitter();
          _this.onCellHoverIn = new core.EventEmitter();
          _this.onCellHoverOut = new core.EventEmitter();
          _this.onDayChange = new core.EventEmitter();
          _this.onSetDate = new core.EventEmitter();
          _this.options = {};
          return _this;
      }
      MbscEventcalendar.prototype.refreshData = function (newData) {
          this.instance.setEvents(newData);
      };
      MbscEventcalendar.prototype.initControl = function () {
          var options = extend$1({ preset: 'eventcalendar' }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
          this.instance = new Eventcalendar(this.element, options);
      };
      MbscEventcalendar.prototype.ngOnInit = function () {
          this.cloneDictionary.data = [];
          _super.prototype.ngOnInit.call(this);
      };
      MbscEventcalendar.prototype.setNewValue = function () { };
      MbscEventcalendar.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mbsc-eventcalendar]',
                      exportAs: 'mobiscroll'
                  },] },
      ];
      MbscEventcalendar.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscEventcalendar.propDecorators = {
          'data': [{ type: core.Input, args: ['mbsc-data',] },],
          'layout': [{ type: core.Input },],
          'showEventCount': [{ type: core.Input },],
          'eventBubble': [{ type: core.Input },],
          'formatDuration': [{ type: core.Input },],
          'view': [{ type: core.Input },],
          'allDayText': [{ type: core.Input },],
          'eventText': [{ type: core.Input },],
          'eventsText': [{ type: core.Input },],
          'labelsShort': [{ type: core.Input },],
          'noEventsText': [{ type: core.Input },],
          'onEventSelect': [{ type: core.Output },],
          'onCellHoverIn': [{ type: core.Output },],
          'onCellHoverOut': [{ type: core.Output },],
          'onDayChange': [{ type: core.Output },],
          'onSetDate': [{ type: core.Output },],
          'options': [{ type: core.Input, args: ['mbsc-options',] },],
      };
      return MbscEventcalendar;
  }(MbscCalBase));
  var MbscEventcalendarComponent = (function (_super) {
      __extends(MbscEventcalendarComponent, _super);
      function MbscEventcalendarComponent(initialElem, zone, optionService) {
          var _this = _super.call(this, initialElem, zone, optionService) || this;
          _this.options = {};
          return _this;
      }
      MbscEventcalendarComponent.prototype.ngOnInit = function () {
          var display = this.options && this.options.display || this.display;
          if (!display) {
              this.display = 'inline';
              this.inlineOptionsObj.display = 'inline';
          }
          _super.prototype.ngOnInit.call(this);
      };
      MbscEventcalendarComponent.prototype.ngAfterViewInit = function () {
          _super.prototype.ngAfterViewInit.call(this);
          this.setThemeClasses();
      };
      MbscEventcalendarComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-eventcalendar',
                      exportAs: 'mobiscroll',
                      template: '<div></div>'
                  },] },
      ];
      MbscEventcalendarComponent.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscEventcalendarComponent.propDecorators = {
          'data': [{ type: core.Input },],
          'options': [{ type: core.Input },],
      };
      return MbscEventcalendarComponent;
  }(MbscEventcalendar));
  var MbscEventcalendarModule = (function () {
      function MbscEventcalendarModule() {
      }
      MbscEventcalendarModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [MbscCalBaseModule],
                      declarations: [MbscEventcalendar, MbscEventcalendarComponent],
                      exports: [MbscEventcalendar, MbscEventcalendarComponent]
                  },] },
      ];
      MbscEventcalendarModule.ctorParameters = function () { return []; };
      return MbscEventcalendarModule;
  }());

  var hasPromise = isBrowser && !!window.Promise;
  var popupQueue = [];
  var notificationQueue = [];
  var activeNotification;

  function showPopup(popup) {
    if (!popupQueue.length) {
      popup.show();
    }

    popupQueue.push(popup);
  }

  function showNotification(notification) {
    var isAny = notificationQueue.length;
    notificationQueue.push(notification); // Only show notification if no popup is visible
    // otherwise postpone it until popup is closed

    if (!popupQueue.length) {
      // If there's a visible notification, hide it.
      // The notification will be shown after hide animation is complete
      if (isAny) {
        notificationQueue[0].hide();
      } else {
        // Prevent focus on show for notifications
        notification.show(false, true);
      }
    }
  }

  function getSettings(queue, settings, resolve, more) {
    //const active = mobiscroll.activeInstance;
    return extend$1({
      display: settings.display || 'center',
      cssClass: 'mbsc-alert',
      okText: settings.okText,
      cancelText: settings.cancelText,
      context: settings.context,
      theme: settings.theme,
      closeOnOverlayTap: false,
      onBeforeClose: function onBeforeClose() {
        queue.shift();
      },
      onHide: function onHide(ev, inst) {
        //mobiscroll.activeInstance = active;
        if (resolve) {
          resolve(inst._resolve);
        }

        if (settings.callback) {
          settings.callback(inst._resolve);
        }

        if (inst) {
          inst.destroy();
        } // Show next


        if (popupQueue.length) {
          popupQueue[0].show();
        } else if (notificationQueue.length) {
          // Prevent focus on show for notifications
          notificationQueue[0].show(false, true);
        }
      }
    }, more);
  }

  function getMessage(settings) {
    return (settings.title ? '<h2>' + settings.title + '</h2>' : '') + '<p>' + (settings.message || '') + '</p>';
  }

  function showAlert(popup, settings, resolve) {
    var inst = new Popup(popup, getSettings(popupQueue, settings, resolve));
    showPopup(inst);
  }

  function showConfirm(popup, settings, resolve) {
    var inst = new Popup(popup, getSettings(popupQueue, settings, resolve, {
      buttons: ['cancel', 'ok'],
      onSet: function onSet() {
        inst._resolve = true;
      }
    }));
    inst._resolve = false;
    showPopup(inst);
  }

  function showPrompt(popup, settings, resolve) {
    var input, label;
    var inst = new Popup(popup, getSettings(popupQueue, settings, resolve, {
      buttons: ['cancel', 'ok'],
      onMarkupReady: function onMarkupReady(event, inst) {
        var s = inst.settings;
        label = inst._markup.find('label');
        label.addClass('mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : ''));
        input = inst._markup.find('input')[0];
        setTimeout(function () {
          input.focus();
          input.setSelectionRange(0, input.value.length);
        }, 300);
      },
      onSet: function onSet() {
        inst._resolve = input.value;
      }
    }));
    inst._resolve = null;
    showPopup(inst);
  }

  function showSnackbar(popup, settings, resolve, cssClass, animation) {
    var notificationTimer;
    var inst = new Popup(popup, getSettings(notificationQueue, settings, resolve, {
      display: settings.display || 'bottom',
      animate: animation,
      cssClass: (cssClass || 'mbsc-snackbar') + (settings.color ? ' mbsc-' + settings.color : ''),
      scrollLock: false,
      focusTrap: false,
      buttons: [],
      onMarkupReady: function onMarkupReady(event, inst) {
        var s = inst.settings;

        var button = inst._markup.find('button');

        button.addClass('mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : ''));
      },
      onShow: function onShow(ev, inst) {
        activeNotification = inst;

        if (settings.duration !== false) {
          notificationTimer = setTimeout(function () {
            if (inst) {
              inst.hide();
            }
          }, settings.duration || 3000);
        }

        if (settings.button) {
          inst.tap($$1('.mbsc-snackbar-btn', ev.target), function () {
            inst.hide();

            if (settings.button.action) {
              settings.button.action.call(this);
            }
          });
        }
      },
      onClose: function onClose() {
        activeNotification = null;
        clearTimeout(notificationTimer);
      }
    }));
    showNotification(inst);
  }

  function showToast(popup, settings, resolve) {
    showSnackbar(popup, settings, resolve, 'mbsc-toast', 'fade');
  }

  function show(func, popup, settings) {
    var p;

    if (hasPromise) {
      p = new Promise(function (resolve) {
        func(popup, settings, resolve);
      });
    } else {
      func(popup, settings);
    }

    return p;
  }

  mobiscroll.alert = function (settings) {
    var popup = document.createElement('div');
    popup.innerHTML = getMessage(settings);
    return show(showAlert, popup, settings);
  };

  mobiscroll.confirm = function (settings) {
    var popup = document.createElement('div');
    popup.innerHTML = getMessage(settings);
    return show(showConfirm, popup, settings);
  };

  mobiscroll.prompt = function (settings) {
    var popup = document.createElement('div');
    popup.innerHTML = getMessage(settings) + '<label class="mbsc-input">' + (settings.label ? '<span class="mbsc-label">' + settings.label + '</span>' : '') + '<input class="mbsc-control" tabindex="0" type="' + (settings.inputType || 'text') + '" placeholder="' + (settings.placeholder || '') + '" value="' + (settings.value || '') + '">' + '</label>';
    return show(showPrompt, popup, settings);
  };

  mobiscroll.snackbar = function (settings) {
    var popup = document.createElement('div'),
        btn = settings.button;
    popup.innerHTML = '<div class="mbsc-snackbar-cont"><div class="mbsc-snackbar-msg">' + (settings.message || '') + '</div>' + (btn ? '<button class="mbsc-snackbar-btn mbsc-btn mbsc-btn-flat">' + (btn.icon ? '<span class="mbsc-ic ' + (btn.text ? 'mbsc-btn-ic ' : '') + 'mbsc-ic-' + btn.icon + '"></span>' : '') + (btn.text || '') + '</button>' : '') + '</div>';
    return show(showSnackbar, popup, settings);
  };

  mobiscroll.toast = function (settings) {
    var popup = document.createElement('div');
    popup.innerHTML = '<div class="mbsc-toast-msg">' + (settings.message || '') + '</div>';
    return show(showToast, popup, settings);
  };

  mobiscroll.notification = {
    dismiss: function dismiss() {
      if (activeNotification) {
        activeNotification.hide();
      }
    }
  };

  var halfBorder$1 = os == 'ios' && majorVersion > 7;
  var Form = function Form(el, settings) {
    var s,
        cssClass = '',
        $ctx = $$1(el),
        controls = {},
        that = this;

    function touched() {
      $ctx.removeClass('mbsc-no-touch');
    } // Call the parent constructor


    Base.call(this, el, settings, true);

    that.refresh = function (shallow) {
      if (s.enhance) {
        initControls($ctx, controls, s, shallow);
      }
    };
    /**
     * Form initialization.
     */


    that._init = function () {
      if (!mobiscroll.themes.form[s.theme]) {
        s.theme = 'mobiscroll';
      }

      if (!$ctx.hasClass('mbsc-form')) {
        $ctx.show();
        listen($ctx[0], 'touchstart', touched, {
          passive: true
        });
      }

      if (cssClass) {
        $ctx.removeClass(cssClass);
      } // --- TRIAL SERVER CODE START ---


      cssClass = 'mbsc-form mbsc-no-touch mbsc-' + s.theme + (halfBorder$1 ? ' mbsc-form-hb' : '') + (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr') + (s.inputStyle == 'box' ? ' mbsc-form-box' : '') + (s.inputStyle == 'outline' ? ' mbsc-form-outline' : ''); // --- TRIAL SERVER CODE END ---

      $ctx.addClass(cssClass).removeClass('mbsc-cloak');
      that.refresh();
    };
    /**
     * Destroys the mobiscroll instance.
     */


    that._destroy = function () {
      $ctx.removeClass(cssClass);
      unlisten($ctx[0], 'touchstart', touched, {
        passive: true
      });

      for (var id in controls) {
        controls[id].destroy();
      }
    };
    /**
     * Object with the underlying form control instances
     * keys are the element id's
     */


    that.controls = controls; // Constructor

    s = that.settings;
    that.init();
  }; // Extend defaults

  Form.prototype = {
    _hasDef: true,
    _hasTheme: true,
    _hasLang: true,
    _class: 'form',
    _defaults: {
      tap: hasGhostClick,
      stopProp: true,
      rtl: false,
      enhance: true
    }
  };
  classes.Form = Form; // Init mbsc-form elements on page load

  autoInit('[mbsc-enhance],[mbsc-form]', Form, true);

  var MbscForm = (function (_super) {
      __extends(MbscForm, _super);
      function MbscForm(initialElem, _formService, zone) {
          var _this = _super.call(this, initialElem, zone) || this;
          _this._formService = _formService;
          _this.enhance = false;
          return _this;
      }
      MbscForm.prototype.ngOnInit = function () {
          this.optionsObj = extend$1({}, this.options, this.inlineOptionsObj);
          this._formService.options = this.optionsObj;
      };
      MbscForm.prototype.initControl = function () {
          var opt = this.options;
          if (opt && opt.enhance === undefined) {
              opt.enhance = false;
          }
          var options = extend$1({}, opt, this.inlineOptionsObj);
          this.instance = new Form(this.rootElem.nativeElement, options);
      };
      MbscForm.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-form',
                      template: "<div #rootElement><ng-content></ng-content></div>",
                      providers: [MbscOptionsService],
                      exportAs: 'mobiscroll'
                  },] },
      ];
      MbscForm.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: MbscOptionsService, },
          { type: core.NgZone, },
      ]; };
      MbscForm.propDecorators = {
          'options': [{ type: core.Input, args: ['options',] },],
          'enhance': [{ type: core.Input },],
          'context': [{ type: core.Input },],
          'inputStyle': [{ type: core.Input, args: ['input-style',] },],
          'labelStyle': [{ type: core.Input, args: ['label-style',] },],
          'rootElem': [{ type: core.ViewChild, args: ['rootElement', { static: false },] },],
      };
      return MbscForm;
  }(MbscBase));
  var MbscTextarea = (function (_super) {
      __extends(MbscTextarea, _super);
      function MbscTextarea(initialElem, _formService, _inputService, _control, zone) {
          var _this = _super.call(this, initialElem, _formService, _inputService, _control, zone) || this;
          _this._inputService = _inputService;
          _inputService.input = _this;
          return _this;
      }
      MbscTextarea.prototype.initControl = function () {
          var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
          this.instance = new TextArea(this._initElem.nativeElement, options);
      };
      MbscTextarea.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-textarea',
                      host: { 'class': 'mbsc-control-ng' },
                      template: "\n            <label \n                [class.mbsc-err]=\"error\"\n                [class.mbsc-input-box]=\"inputStyle == 'box'\"\n                [class.mbsc-input-outline]=\"inputStyle == 'outline'\"\n                [class.mbsc-label-stacked]=\"labelStyle == 'stacked'\"\n                [class.mbsc-label-inline]=\"labelStyle == 'inline'\"\n                [class.mbsc-label-floating]=\"labelStyle == 'floating'\"\n            >\n            <ng-content></ng-content>\n            <span class=\"mbsc-input-wrap\">\n                <textarea #initElement [placeholder]=\"placeholder\" [(ngModel)]=\"innerValue\" (blur)=\"onTouch($event)\"\n                    [attr.name]=\"name\"\n                    [attr.rows]=\"rows\"\n                    [attr.wrap]=\"wrap\"\n                    [attr.minlength]=\"minlength\"\n                    [attr.maxlength]=\"maxlength\"\n                    [attr.autocomplete]=\"autocomplete\" \n                    [attr.autocapitalize]=\"autocapitalize\"\n                    [attr.autocorrect]=\"autocorrect\"\n                    [attr.spellcheck]=\"spellcheck\"\n                    [attr.autofocus]=\"autofocus\"\n                    [attr.required]=\"required\"\n                    [attr.data-icon]=\"icon ? icon : null\"\n                    [attr.data-icon-align]=\"iconAlign ? iconAlign : null\"\n                    [disabled]=\"disabled\"\n                    [readonly]=\"_readonly\"></textarea>\n                <span *ngIf=\"error && errorMessage\" class=\"mbsc-err-msg\">{{errorMessage}}</span>\n            </span>\n        </label>\n    ",
                      providers: [MbscInputService]
                  },] },
      ];
      MbscTextarea.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: core.NgZone, },
      ]; };
      MbscTextarea.propDecorators = {
          'rows': [{ type: core.Input },],
          'wrap': [{ type: core.Input },],
      };
      return MbscTextarea;
  }(MbscInputBase));
  var MbscDropdown = (function (_super) {
      __extends(MbscDropdown, _super);
      function MbscDropdown(hostElem, formService, _inputService, control, zone) {
          var _this = _super.call(this, hostElem, formService, _inputService, control, zone) || this;
          _this._inputService = _inputService;
          _inputService.input = _this;
          return _this;
      }
      Object.defineProperty(MbscDropdown.prototype, "value", {
          set: function (v) {
              var _this = this;
              this._value = v;
              setTimeout(function () {
                  _this.instance._setText();
              });
          },
          enumerable: true,
          configurable: true
      });
      MbscDropdown.prototype.initControl = function () {
          var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
          this.instance = new Select(this._initElem.nativeElement, options);
          var that = this;
          setTimeout(function () {
              that.instance._setText();
          });
      };
      MbscDropdown.prototype.writeValue = function (v) {
          this._value = v;
          if (this.instance) {
              var that_1 = this;
              setTimeout(function () {
                  that_1.instance._setText();
              });
          }
      };
      MbscDropdown.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-dropdown',
                      host: { 'class': 'mbsc-control-ng' },
                      template: "\n            <label \n                [class.mbsc-err]=\"error\"\n                [class.mbsc-input-box]=\"inputStyle == 'box'\"\n                [class.mbsc-input-outline]=\"inputStyle == 'outline'\"\n                [class.mbsc-label-stacked]=\"labelStyle == 'stacked'\"\n                [class.mbsc-label-inline]=\"labelStyle == 'inline'\"\n                [class.mbsc-label-floating]=\"labelStyle == 'floating'\"\n            >\n            {{label}}\n            <span class=\"mbsc-input-wrap\">\n                <select #initElement\n                    [(ngModel)]=\"innerValue\" \n                    [attr.name]=\"name\"\n                    [attr.data-icon]=\"icon ? icon : null\"\n                    [attr.data-icon-align]=\"iconAlign ? iconAlign : null\"\n                    [disabled]=\"disabled\"\n                    (blur)=\"onTouch($event)\">\n                    <ng-content></ng-content>\n                </select>\n                <span *ngIf=\"error && errorMessage\" class=\"mbsc-err-msg\">{{errorMessage}}</span>\n            </span>\n        </label>\n    ",
                      providers: [MbscInputService]
                  },] },
      ];
      MbscDropdown.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: core.NgZone, },
      ]; };
      MbscDropdown.propDecorators = {
          'label': [{ type: core.Input },],
          'icon': [{ type: core.Input },],
          'iconAlign': [{ type: core.Input, args: ['icon-align',] },],
          'value': [{ type: core.Input },],
          'inputStyle': [{ type: core.Input, args: ['input-style',] },],
          'labelStyle': [{ type: core.Input, args: ['label-style',] },],
      };
      return MbscDropdown;
  }(MbscFormValueBase));
  var MbscButton = (function (_super) {
      __extends(MbscButton, _super);
      function MbscButton(hostElem, formService, zone) {
          var _this = _super.call(this, hostElem, formService, zone) || this;
          _this._flat = false;
          _this._block = false;
          _this._outline = false;
          _this._classesObj = {};
          _this.type = 'button';
          return _this;
      }
      Object.defineProperty(MbscButton.prototype, "cssClasses", {
          get: function () {
              for (var k in this._classesObj) {
                  delete this._classesObj[k];
              }
              this._classesObj['mbsc-btn-flat'] = this._flat;
              this._classesObj['mbsc-btn-block'] = this._block;
              this._classesObj['mbsc-btn-outline'] = this._outline;
              if (this.classes) {
                  var cssClasses = this.classes.split(' ');
                  if (cssClasses.length) {
                      for (var i = 0; i < cssClasses.length; i++) {
                          if (cssClasses[i]) {
                              this._classesObj[cssClasses[i]] = true;
                          }
                      }
                  }
              }
              if (this.color) {
                  this._classesObj['mbsc-btn-' + this.color] = true;
              }
              return this._classesObj;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MbscButton.prototype, "flat", {
          set: function (val) {
              this._flat = emptyOrTrue(val);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MbscButton.prototype, "block", {
          set: function (val) {
              this._block = emptyOrTrue(val);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MbscButton.prototype, "outline", {
          set: function (val) {
              this._outline = emptyOrTrue(val);
          },
          enumerable: true,
          configurable: true
      });
      MbscButton.prototype.initControl = function () {
          var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
          this.instance = new Button(this._initElem.nativeElement, options);
      };
      MbscButton.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-button',
                      template: "\n        <button #initElement \n            [type]=\"type\"\n            [ngClass]=\"cssClasses\"\n            [attr.name]=\"name\"\n            [attr.data-icon]=\"icon ? icon : null\"\n            [disabled]=\"disabled\">\n            <ng-content></ng-content>\n        </button>\n    ",
                      changeDetection: core.ChangeDetectionStrategy.OnPush
                  },] },
      ];
      MbscButton.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: core.NgZone, },
      ]; };
      MbscButton.propDecorators = {
          'classes': [{ type: core.Input, args: ['class',] },],
          'type': [{ type: core.Input },],
          'icon': [{ type: core.Input },],
          'flat': [{ type: core.Input },],
          'block': [{ type: core.Input },],
          'outline': [{ type: core.Input },],
      };
      return MbscButton;
  }(MbscFormBase));
  var MbscCheckbox = (function (_super) {
      __extends(MbscCheckbox, _super);
      function MbscCheckbox(hostElem, cdr, formService, _inputService, control, zone) {
          var _this = _super.call(this, hostElem, formService, _inputService, control, zone) || this;
          _this.cdr = cdr;
          _this._colorClass = {};
          return _this;
      }
      Object.defineProperty(MbscCheckbox.prototype, "colorClass", {
          get: function () {
              for (var k in this._colorClass) {
                  delete this._colorClass[k];
              }
              if (this.color) {
                  this._colorClass['mbsc-checkbox-' + this.color] = true;
              }
              if (this.error) {
                  this._colorClass['mbsc-err'] = true;
              }
              return this._colorClass;
          },
          enumerable: true,
          configurable: true
      });
      MbscCheckbox.prototype.initControl = function () {
          var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
          this.instance = new CheckBox(this._initElem.nativeElement, options);
      };
      MbscCheckbox.prototype.writeValue = function (v) {
          this._value = v;
          this.cdr.detectChanges();
      };
      MbscCheckbox.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-checkbox',
                      host: { 'class': 'mbsc-control-ng' },
                      template: "\n        <label [ngClass]=\"colorClass\">\n            <input #initElement \n                type=\"checkbox\"\n                [attr.name]=\"name\"\n                [disabled]=\"disabled\"\n                [attr.data-label-style]=\"labelStyle\"\n                [attr.data-input-style]=\"inputStyle\"\n                [(ngModel)]=\"innerValue\"\n                (blur)=\"onTouch($event)\" />\n            <ng-content></ng-content>\n            <span *ngIf=\"error && errorMessage\" class=\"mbsc-err-msg\">{{errorMessage}}</span>\n        </label>\n    ",
                      changeDetection: core.ChangeDetectionStrategy.OnPush
                  },] },
      ];
      MbscCheckbox.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.ChangeDetectorRef, },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: core.NgZone, },
      ]; };
      MbscCheckbox.propDecorators = {
          'color': [{ type: core.Input },],
          'inputStyle': [{ type: core.Input, args: ['input-style',] },],
          'labelStyle': [{ type: core.Input, args: ['label-style',] },],
      };
      return MbscCheckbox;
  }(MbscFormValueBase));
  var MbscSwitch = (function (_super) {
      __extends(MbscSwitch, _super);
      function MbscSwitch(hostElem, zone, _formService, control) {
          var _this = _super.call(this, hostElem, zone, control, null, null) || this;
          _this._formService = _formService;
          _this.disabled = false;
          _this.onChangeEmitter = new core.EventEmitter();
          _this._colorClass = {};
          return _this;
      }
      Object.defineProperty(MbscSwitch.prototype, "value", {
          set: function (v) {
              this.setNewValueProxy(v);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MbscSwitch.prototype, "colorClass", {
          get: function () {
              for (var k in this._colorClass) {
                  delete this._colorClass[k];
              }
              if (this.color) {
                  this._colorClass['mbsc-switch-' + this.color] = true;
              }
              if (this.error) {
                  this._colorClass['mbsc-err'] = true;
              }
              return this._colorClass;
          },
          enumerable: true,
          configurable: true
      });
      MbscSwitch.prototype.setNewValue = function (v) {
          if (this.instance) {
              if (this.instance.getVal() !== v) {
                  this.instance.setVal(v, true, false);
              }
          }
      };
      MbscSwitch.prototype.ngOnInit = function () {
          this._inheritedOptions = this._formService ? this._formService.options : {};
          _super.prototype.ngOnInit.call(this);
      };
      MbscSwitch.prototype.initControl = function () {
          var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
          this.instance = new Switch(this._initElem.nativeElement, options);
          if (this.initialValue !== undefined) {
              this.instance.setVal(this.initialValue, true, false);
          }
      };
      MbscSwitch.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-switch',
                      host: { 'class': 'mbsc-control-ng' },
                      template: "\n        <label [ngClass]=\"colorClass\">\n            <ng-content></ng-content>\n            <span *ngIf=\"error && errorMessage\" class=\"mbsc-err-msg\">{{errorMessage}}</span>\n            <input #initElement \n                type=\"checkbox\"\n                data-role=\"switch\"\n                [attr.name]=\"name\"\n                [attr.data-label-style]=\"labelStyle\"\n                [attr.data-input-style]=\"inputStyle\"\n                [disabled]=\"disabled\"\n                (blur)=\"onTouch($event)\" />\n        </label>\n    ",
                      exportAs: 'mobiscroll',
                      changeDetection: core.ChangeDetectionStrategy.OnPush
                  },] },
      ];
      MbscSwitch.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
      ]; };
      MbscSwitch.propDecorators = {
          'options': [{ type: core.Input, args: ['options',] },],
          'disabled': [{ type: core.Input },],
          'name': [{ type: core.Input },],
          'color': [{ type: core.Input },],
          'error': [{ type: core.Input },],
          'errorMessage': [{ type: core.Input },],
          'value': [{ type: core.Input, args: ['value',] },],
          'onChangeEmitter': [{ type: core.Output, args: ['valueChange',] },],
          '_initElem': [{ type: core.ViewChild, args: ['initElement', { static: false },] },],
      };
      return MbscSwitch;
  }(MbscControlBase));
  var MbscStepper = (function (_super) {
      __extends(MbscStepper, _super);
      function MbscStepper(hostElement, zone, _formService, control) {
          var _this = _super.call(this, hostElement, zone, control, null, null) || this;
          _this._formService = _formService;
          _this.min = undefined;
          _this.max = undefined;
          _this.step = undefined;
          _this.val = undefined;
          _this.disabled = false;
          _this._colorClass = {};
          _this.onChangeEmitter = new core.EventEmitter();
          return _this;
      }
      Object.defineProperty(MbscStepper.prototype, "readonly", {
          set: function (val) {
              this._readonly = emptyOrTrue(val);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MbscStepper.prototype, "value", {
          set: function (v) {
              this.setNewValueProxy(v);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MbscStepper.prototype, "colorClass", {
          get: function () {
              for (var k in this._colorClass) {
                  delete this._colorClass[k];
              }
              if (this.color) {
                  this._colorClass['mbsc-stepper-' + this.color] = true;
              }
              return this._colorClass;
          },
          enumerable: true,
          configurable: true
      });
      MbscStepper.prototype.setNewValue = function (v) {
          if (this.instance && this.instance.getVal() !== v) {
              this.instance.setVal(v, true, false);
          }
      };
      MbscStepper.prototype.ngOnInit = function () {
          this._inheritedOptions = this._formService ? this._formService.options : {};
          _super.prototype.ngOnInit.call(this);
      };
      MbscStepper.prototype.initControl = function () {
          var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
          this.instance = new Stepper(this._initElem.nativeElement, options);
          if (this.initialValue !== undefined) {
              this.instance.setVal(this.initialValue, true, false);
          }
      };
      MbscStepper.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-stepper',
                      host: { 'class': 'mbsc-control-ng' },
                      template: "\n        <div [ngClass]=\"colorClass\">\n            <ng-content></ng-content>\n            <input #initElement\n                data-role=\"stepper\"\n                [attr.name]=\"name\"\n                [attr.min]=\"min !== undefined ? min : null\"\n                [attr.max]=\"max !== undefined ? max : null\"\n                [attr.step]=\"step !== undefined ? step : null\"\n                [attr.data-val]=\"val ? val : null\"\n                [attr.data-label-style]=\"labelStyle\"\n                [attr.data-input-style]=\"inputStyle\"\n                [disabled]=\"disabled\" \n                [readonly]=\"_readonly\"/>\n        </div>\n    ",
                      exportAs: 'mobiscroll',
                      changeDetection: core.ChangeDetectionStrategy.OnPush
                  },] },
      ];
      MbscStepper.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
      ]; };
      MbscStepper.propDecorators = {
          'readonly': [{ type: core.Input },],
          'options': [{ type: core.Input, args: ['options',] },],
          'value': [{ type: core.Input },],
          'name': [{ type: core.Input },],
          'min': [{ type: core.Input },],
          'max': [{ type: core.Input },],
          'step': [{ type: core.Input },],
          'val': [{ type: core.Input },],
          'disabled': [{ type: core.Input },],
          'color': [{ type: core.Input },],
          'onChangeEmitter': [{ type: core.Output, args: ['valueChange',] },],
          '_initElem': [{ type: core.ViewChild, args: ['initElement', { static: false },] },],
      };
      return MbscStepper;
  }(MbscControlBase));
  var MbscProgress = (function (_super) {
      __extends(MbscProgress, _super);
      function MbscProgress(hostElement, zone, _formService, control) {
          var _this = _super.call(this, hostElement, zone, control, null, null) || this;
          _this._formService = _formService;
          _this.max = undefined;
          _this.icon = undefined;
          _this.iconAlign = undefined;
          _this.val = undefined;
          _this.disabled = false;
          _this._colorClass = {};
          return _this;
      }
      Object.defineProperty(MbscProgress.prototype, "value", {
          set: function (v) {
              this.setNewValueProxy(v);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MbscProgress.prototype, "dataStepLabels", {
          get: function () {
              if (typeof (this.stepLabels) === 'string') {
                  return this.stepLabels;
              }
              else {
                  return null;
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MbscProgress.prototype, "colorClass", {
          get: function () {
              for (var k in this._colorClass) {
                  delete this._colorClass[k];
              }
              if (this.color) {
                  this._colorClass['mbsc-progress-' + this.color] = true;
              }
              return this._colorClass;
          },
          enumerable: true,
          configurable: true
      });
      MbscProgress.prototype.setNewValue = function (v) {
          if (this.instance && this.instance.getVal() !== v) {
              this.instance.setVal(v, true, false);
          }
      };
      MbscProgress.prototype.ngOnInit = function () {
          this._inheritedOptions = this._formService ? this._formService.options : {};
          _super.prototype.ngOnInit.call(this);
      };
      MbscProgress.prototype.initControl = function () {
          var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
          this.instance = new Progress(this._initElem.nativeElement, options);
          if (this.initialValue !== undefined) {
              this.instance.setVal(this.initialValue, true, false);
          }
      };
      MbscProgress.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-progress',
                      host: { 'class': 'mbsc-control-ng' },
                      template: "\n        <label [ngClass]=\"colorClass\">\n            <ng-content></ng-content>\n            <progress #initElement\n                [attr.data-step-labels]=\"dataStepLabels\"\n                [attr.data-icon]=\"icon ? icon : null\"\n                [attr.data-icon-align]=\"iconAlign ? iconAlign : null\"\n                [attr.data-label-style]=\"labelStyle\"\n                [attr.data-input-style]=\"inputStyle\"\n                [attr.max]=\"max !== undefined ? max : null\"\n                [attr.data-val]=\"val !== undefined ? val : null\"\n            >\n            </progress>\n        </label>\n    ",
                      exportAs: 'mobiscroll',
                      changeDetection: core.ChangeDetectionStrategy.OnPush
                  },] },
      ];
      MbscProgress.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
      ]; };
      MbscProgress.propDecorators = {
          'options': [{ type: core.Input, args: ['options',] },],
          'value': [{ type: core.Input },],
          'max': [{ type: core.Input },],
          'icon': [{ type: core.Input },],
          'iconAlign': [{ type: core.Input, args: ['icon-align',] },],
          'val': [{ type: core.Input },],
          'disabled': [{ type: core.Input },],
          'stepLabels': [{ type: core.Input, args: ['step-labels',] },],
          'color': [{ type: core.Input },],
          '_initElem': [{ type: core.ViewChild, args: ['initElement', { static: false },] },],
      };
      return MbscProgress;
  }(MbscControlBase));
  var groupName = 1;
  var MbscRadioService = (function () {
      function MbscRadioService() {
          this._lastValue = null;
          this._valueObservable = new Observable();
      }
      Object.defineProperty(MbscRadioService.prototype, "name", {
          get: function () {
              if (!this._name) {
                  this._name = 'mbsc-radio-group-' + (groupName++);
              }
              return this._name;
          },
          set: function (n) {
              this._name = n;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MbscRadioService.prototype, "multiSelect", {
          get: function () {
              return this._multiSelect;
          },
          set: function (v) {
              this._multiSelect = v;
          },
          enumerable: true,
          configurable: true
      });
      MbscRadioService.prototype.onValueChanged = function () {
          return this._valueObservable;
      };
      MbscRadioService.prototype.changeValue = function (v) {
          this._valueObservable.next(v);
          this._lastValue = v;
      };
      Object.defineProperty(MbscRadioService.prototype, "getLastValue", {
          get: function () {
              return this._lastValue;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MbscRadioService.prototype, "color", {
          get: function () {
              return this._color;
          },
          set: function (v) {
              this._color = v;
          },
          enumerable: true,
          configurable: true
      });
      MbscRadioService.decorators = [
          { type: core.Injectable },
      ];
      MbscRadioService.ctorParameters = function () { return []; };
      return MbscRadioService;
  }());
  var MbscRadioGroupBase = (function (_super) {
      __extends(MbscRadioGroupBase, _super);
      function MbscRadioGroupBase(hostElement, formService, _inputService, _radioService, control, zone) {
          var _this = _super.call(this, hostElement, formService, _inputService, control, zone) || this;
          _this._radioService = _radioService;
          _this.valueObserver = _this._radioService.onValueChanged().subscribe(function (v) {
              _this.innerValue = v;
              _this.onTouch();
          });
          return _this;
      }
      Object.defineProperty(MbscRadioGroupBase.prototype, "value", {
          set: function (v) {
              this._value = v;
              this._radioService.changeValue(v);
          },
          enumerable: true,
          configurable: true
      });
      MbscRadioGroupBase.prototype.ngOnInit = function () {
          _super.prototype.ngOnInit.call(this);
          if (this.name) {
              this._radioService.name = this.name;
          }
          if (this.color) {
              this._radioService.color = this.color;
          }
      };
      MbscRadioGroupBase.prototype.writeValue = function (v) {
          this._value = v;
          this._radioService.changeValue(v);
      };
      MbscRadioGroupBase.prototype.updateOptions = function () { };
      MbscRadioGroupBase.prototype.ngOnDestroy = function () {
          this._radioService.onValueChanged().unsubscribe(this.valueObserver);
          _super.prototype.ngOnDestroy.call(this);
      };
      MbscRadioGroupBase.decorators = [
          { type: core.Directive, args: [{ selector: '[mbsc-rg-b]' },] },
      ];
      MbscRadioGroupBase.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscRadioService, },
          { type: forms.NgControl, },
          { type: core.NgZone, },
      ]; };
      MbscRadioGroupBase.propDecorators = {
          'name': [{ type: core.Input },],
          'value': [{ type: core.Input },],
      };
      return MbscRadioGroupBase;
  }(MbscFormValueBase));
  var MbscRadioGroup = (function (_super) {
      __extends(MbscRadioGroup, _super);
      function MbscRadioGroup(hostElement, formService, _inputService, radioService, control, zone) {
          return _super.call(this, hostElement, formService, _inputService, radioService, control, zone) || this;
      }
      MbscRadioGroup.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-radio-group',
                      template: "<ng-content></ng-content>",
                      providers: [MbscRadioService]
                  },] },
      ];
      MbscRadioGroup.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscRadioService, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: core.NgZone, },
      ]; };
      return MbscRadioGroup;
  }(MbscRadioGroupBase));
  var MbscRadio = (function (_super) {
      __extends(MbscRadio, _super);
      function MbscRadio(hostElement, formService, _radioService, zone) {
          var _this = _super.call(this, hostElement, formService, zone) || this;
          _this._radioService = _radioService;
          _this._colorClass = {};
          var v = _this._radioService.getLastValue;
          if (v !== null) {
              _this.modelValue = v;
          }
          _this.valueObserver = _this._radioService.onValueChanged().subscribe(function (v) {
              _this.modelValue = v;
          });
          return _this;
      }
      Object.defineProperty(MbscRadio.prototype, "checked", {
          get: function () {
              return this.value == this.modelValue;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MbscRadio.prototype, "colorClass", {
          get: function () {
              for (var k in this._colorClass) {
                  delete this._colorClass[k];
              }
              if (this.color) {
                  this._colorClass['mbsc-radio-' + this.color] = true;
              }
              if (this.error) {
                  this._colorClass['mbsc-err'] = true;
              }
              return this._colorClass;
          },
          enumerable: true,
          configurable: true
      });
      MbscRadio.prototype.clicked = function (e) {
          this._radioService.changeValue(this.value);
      };
      MbscRadio.prototype.initControl = function () {
          var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
          this.instance = new Radio(this._initElem.nativeElement, options);
      };
      MbscRadio.prototype.ngOnInit = function () {
          _super.prototype.ngOnInit.call(this);
          this.name = this._radioService.name;
          this.color = this._radioService.color;
      };
      MbscRadio.prototype.ngOnDestroy = function () {
          this._radioService.onValueChanged().unsubscribe(this.valueObserver);
          _super.prototype.ngOnDestroy.call(this);
      };
      MbscRadio.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-radio',
                      host: { 'class': 'mbsc-control-ng' },
                      template: "\n        <label [ngClass]=\"colorClass\">\n            <input #initElement \n                type=\"radio\" \n                [attr.name]=\"name\" \n                [attr.value]=\"value\"\n                [value]=\"value\" \n                [checked]=\"checked\"\n                [disabled]=\"disabled\"\n                (click)=\"clicked($event)\" />\n            <ng-content></ng-content>\n            <span *ngIf=\"error && errorMessage\" class=\"mbsc-err-msg\">{{errorMessage}}</span>\n        </label>\n    "
                  },] },
      ];
      MbscRadio.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: MbscRadioService, },
          { type: core.NgZone, },
      ]; };
      MbscRadio.propDecorators = {
          'value': [{ type: core.Input },],
          'error': [{ type: core.Input },],
          'errorMessage': [{ type: core.Input },],
      };
      return MbscRadio;
  }(MbscFormBase));
  var MbscSegmentedGroup = (function (_super) {
      __extends(MbscSegmentedGroup, _super);
      function MbscSegmentedGroup(hostElement, formService, _inputService, radioService, control, zone) {
          var _this = _super.call(this, hostElement, formService, _inputService, radioService, control, zone) || this;
          _this.select = 'single';
          return _this;
      }
      Object.defineProperty(MbscSegmentedGroup.prototype, "multiSelect", {
          get: function () {
              return this.select == 'multiple';
          },
          enumerable: true,
          configurable: true
      });
      MbscSegmentedGroup.prototype.ngOnInit = function () {
          _super.prototype.ngOnInit.call(this);
          this._radioService.multiSelect = this.multiSelect;
          if (this.color) {
              this._radioService.color = this.color;
          }
      };
      MbscSegmentedGroup.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-segmented-group',
                      template: "<div class=\"mbsc-segmented mbsc-segmented-group mbsc-no-touch\"><ng-content></ng-content></div>",
                      providers: [MbscRadioService]
                  },] },
      ];
      MbscSegmentedGroup.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscRadioService, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: core.NgZone, },
      ]; };
      MbscSegmentedGroup.propDecorators = {
          'select': [{ type: core.Input },],
      };
      return MbscSegmentedGroup;
  }(MbscRadioGroupBase));
  var MbscSegmented = (function (_super) {
      __extends(MbscSegmented, _super);
      function MbscSegmented(hostElement, formService, _radioService, zone) {
          var _this = _super.call(this, hostElement, formService, zone) || this;
          _this._radioService = _radioService;
          _this.checkedChange = new core.EventEmitter();
          var v = _this._radioService.getLastValue;
          if (v !== null) {
              _this.modelValue = v;
          }
          _this.valueObserver = _this._radioService.onValueChanged().subscribe(function (v) {
              _this.modelValue = v;
          });
          return _this;
      }
      Object.defineProperty(MbscSegmented.prototype, "isChecked", {
          get: function () {
              if (this.multiSelect) {
                  if (this.checked !== undefined) {
                      return this.checked;
                  }
                  else {
                      return this.modelValue && this.modelValue.includes(this.value);
                  }
              }
              else {
                  return this.value == this.modelValue;
              }
          },
          enumerable: true,
          configurable: true
      });
      MbscSegmented.prototype.clicked = function (e) {
          if (this.multiSelect && this.checked !== undefined) {
              this.checkedChange.emit(!(!!this.checked));
          }
          else {
              if (this.multiSelect) {
                  if (this.modelValue.includes(this.value)) {
                      var i = this.modelValue.indexOf(this.value);
                      this.modelValue.splice(i, 1);
                  }
                  else {
                      this.modelValue.push(this.value);
                  }
                  this._radioService.changeValue(this.modelValue);
              }
              else {
                  this._radioService.changeValue(this.value);
              }
          }
      };
      Object.defineProperty(MbscSegmented.prototype, "cssClass", {
          get: function () {
              var cl = 'mbsc-segmented-item';
              if (this.color) {
                  cl += ' mbsc-segmented-' + this.color;
              }
              return cl;
          },
          enumerable: true,
          configurable: true
      });
      MbscSegmented.prototype.initControl = function () {
          var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
          this.instance = new SegmentedItem(this._initElem.nativeElement, options);
      };
      MbscSegmented.prototype.ngOnInit = function () {
          _super.prototype.ngOnInit.call(this);
          this.name = this._radioService.name;
          this.multiSelect = this._radioService.multiSelect;
          this.color = this._radioService.color;
      };
      MbscSegmented.prototype.ngOnDestroy = function () {
          this._radioService.onValueChanged().unsubscribe(this.valueObserver);
          _super.prototype.ngOnDestroy.call(this);
      };
      MbscSegmented.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-segmented',
                      host: { '[class]': 'cssClass' },
                      template: "\n        <label class=\"mbsc-segmented-item-ready\">\n            <input #initElement \n                data-role=\"segmented\"\n                [type]=\"multiSelect ? 'checkbox' : 'radio'\" \n                [value]=\"value\" \n                [checked]=\"isChecked\"\n                [disabled]=\"disabled\"\n                [attr.name]=\"name\" \n                [attr.value]=\"value\"\n                [attr.data-icon]=\"icon ? icon : null\"\n                (click)=\"clicked($event)\" />\n            <span class=\"mbsc-segmented-content\">\n                <span *ngIf=\"icon\" class=\"{{'mbsc-ic mbsc-ic-' + icon }}\"></span>\n                <ng-content></ng-content>\n            </span>\n        </label>\n    "
                  },] },
      ];
      MbscSegmented.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: MbscRadioService, },
          { type: core.NgZone, },
      ]; };
      MbscSegmented.propDecorators = {
          'icon': [{ type: core.Input },],
          'value': [{ type: core.Input },],
          'checked': [{ type: core.Input },],
          'checkedChange': [{ type: core.Output },],
      };
      return MbscSegmented;
  }(MbscFormBase));
  var MbscSlider = (function (_super) {
      __extends(MbscSlider, _super);
      function MbscSlider(hostElement, _formService, zone, control) {
          var _this = _super.call(this, hostElement, zone, control, null, null) || this;
          _this._formService = _formService;
          _this._dummy = undefined;
          _this._needsTimeout = false;
          _this.disabled = false;
          _this._colorClass = {};
          _this.onChangeEmitter = new core.EventEmitter();
          return _this;
      }
      Object.defineProperty(MbscSlider.prototype, "isMulti", {
          get: function () {
              return this._lastValue instanceof Array;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MbscSlider.prototype, "dummyArray", {
          get: function () {
              if (!this._dummy || (this.isMulti && this._lastValue && this._lastValue.length && this._dummy.length !== this._lastValue.length)) {
                  this._dummy = Array(this.isMulti ? this._lastValue.length : 1).fill(0).map(function (x, i) { return i; });
              }
              return this._dummy;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MbscSlider.prototype, "dataStepLabels", {
          get: function () {
              if (typeof (this.stepLabels) === 'string') {
                  return this.stepLabels;
              }
              else {
                  return null;
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MbscSlider.prototype, "value", {
          set: function (v) {
              this.setNewValueProxy(v);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MbscSlider.prototype, "colorClass", {
          get: function () {
              for (var k in this._colorClass) {
                  delete this._colorClass[k];
              }
              if (this.color) {
                  this._colorClass['mbsc-slider-' + this.color] = true;
              }
              return this._colorClass;
          },
          enumerable: true,
          configurable: true
      });
      MbscSlider.prototype.reInitialize = function () {
          var _this = this;
          this.instance.destroy();
          this.setElement();
          this.inputElements.forEach(function (input, index) {
              if (index) {
                  _this.handleChange(input.nativeElement);
              }
          });
          var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
          this.instance = new Slider(this.inputElements.first.nativeElement, options);
      };
      MbscSlider.prototype.setNewValue = function (v) {
          var _this = this;
          this._lastValue = v;
          if (this.instance) {
              var innerValue = this.instance.getVal();
              if (this.isMulti && (!innerValue || innerValue.length != v.length)) {
                  setTimeout(function () {
                      _this.reInitialize();
                      _this.instance.setVal(_this._lastValue, true, false);
                  });
              }
              else {
                  var changed = (this.isMulti && !deepEqualsArray(innerValue, v)) || (!this.isMulti && innerValue !== v);
                  if (changed) {
                      this.instance.setVal(v, true, false);
                  }
              }
          }
      };
      MbscSlider.prototype.ngOnInit = function () {
          this._inheritedOptions = this._formService ? this._formService.options : {};
          _super.prototype.ngOnInit.call(this);
      };
      MbscSlider.prototype.initControl = function () {
          var _this = this;
          this.inputElements.forEach(function (input, index) {
              if (index) {
                  _this.handleChange(input.nativeElement);
              }
          });
          var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
          this.instance = new Slider(this.inputElements.first.nativeElement, options);
          if (this.initialValue !== undefined && this.initialValue !== null) {
              this.instance.setVal(this.initialValue, true, false);
          }
      };
      MbscSlider.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-slider',
                      host: { 'class': 'mbsc-control-ng' },
                      template: "\n        <label [ngClass]=\"colorClass\">\n            <ng-content></ng-content>\n            <input #inputElements *ngFor=\"let v of dummyArray\" \n                type=\"range\"\n                [disabled]=\"disabled\"\n                [attr.value]=\"dummyArray.length > 1 && initialValue ? initialValue[v]: initialValue\"\n                [attr.data-step-labels]=\"dataStepLabels\"\n                [attr.data-template]=\"valueTemplate\"\n                [attr.data-tooltip]=\"tooltip ? 'true' : null\"\n                [attr.data-highlight]=\"highlight\"\n                [attr.data-live]=\"live\"\n                [attr.data-icon]=\"icon ? icon : null\"\n                [attr.data-val]=\"val ? val : null\"\n                [attr.data-label-style]=\"labelStyle\"\n                [attr.data-input-style]=\"inputStyle\"\n                [attr.name]=\"name\"\n                [attr.max]=\"max !== undefined ? max : null\"\n                [attr.min]=\"min !== undefined ? min : null\"\n                [attr.step]=\"step !== undefined ? step : null\"\n                (blur)=\"onTouch($event)\" />\n        </label>\n    ",
                      exportAs: 'mobiscroll'
                  },] },
      ];
      MbscSlider.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
      ]; };
      MbscSlider.propDecorators = {
          'options': [{ type: core.Input, args: ['options',] },],
          'name': [{ type: core.Input },],
          'tooltip': [{ type: core.Input },],
          'highlight': [{ type: core.Input },],
          'live': [{ type: core.Input },],
          'valueTemplate': [{ type: core.Input, args: ['value-template',] },],
          'icon': [{ type: core.Input },],
          'val': [{ type: core.Input },],
          'max': [{ type: core.Input },],
          'min': [{ type: core.Input },],
          'step': [{ type: core.Input },],
          'disabled': [{ type: core.Input },],
          'stepLabels': [{ type: core.Input, args: ['step-labels',] },],
          'value': [{ type: core.Input, args: ['value',] },],
          'color': [{ type: core.Input },],
          'onChangeEmitter': [{ type: core.Output, args: ['valueChange',] },],
          'inputElements': [{ type: core.ViewChildren, args: ['inputElements',] },],
      };
      return MbscSlider;
  }(MbscControlBase));
  var MbscRating = (function (_super) {
      __extends(MbscRating, _super);
      function MbscRating(hostElem, zone, formService, control) {
          var _this = _super.call(this, hostElem, zone, control, null, null) || this;
          _this.formService = formService;
          _this.min = undefined;
          _this.max = undefined;
          _this.step = undefined;
          _this.disabled = false;
          _this.val = undefined;
          _this.onChangeEmitter = new core.EventEmitter();
          _this._colorClass = {};
          return _this;
      }
      Object.defineProperty(MbscRating.prototype, "readonly", {
          set: function (val) {
              this._readonly = emptyOrTrue(val);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MbscRating.prototype, "value", {
          set: function (v) {
              this.setNewValueProxy(v);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MbscRating.prototype, "colorClass", {
          get: function () {
              for (var k in this._colorClass) {
                  delete this._colorClass[k];
              }
              if (this.color) {
                  this._colorClass['mbsc-rating-' + this.color] = true;
              }
              return this._colorClass;
          },
          enumerable: true,
          configurable: true
      });
      MbscRating.prototype.setNewValue = function (v) {
          if (this.instance) {
              if (this.instance.getVal() !== v) {
                  this.instance.setVal(v, true, false);
              }
          }
      };
      MbscRating.prototype.ngOnInit = function () {
          this._inheritedOptions = this.formService ? this.formService.options : {};
          _super.prototype.ngOnInit.call(this);
      };
      MbscRating.prototype.initControl = function () {
          var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
          this.instance = new Rating(this.element, options);
          if (this.initialValue !== undefined) {
              this.instance.setVal(this.initialValue, true, false);
          }
      };
      MbscRating.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-rating',
                      host: { 'class': 'mbsc-control-ng' },
                      template: "<label [ngClass]=\"colorClass\">\n        <ng-content></ng-content>\n        <input type=\"rating\" data-role=\"rating\" \n            [attr.name]=\"name\"\n            [attr.min]=\"min !== undefined ? min : null\"\n            [attr.max]=\"max !== undefined ? max : null\"\n            [attr.step]=\"step !== undefined ? step : null\"\n            [attr.data-val]=\"val ? val : null\"\n            [attr.data-template]=\"template ? template : null\"\n            [attr.data-empty]=\"empty\"\n            [attr.data-filled]=\"filled\"\n            [attr.data-label-style]=\"labelStyle\"\n            [attr.data-input-style]=\"inputStyle\"\n            [disabled]=\"disabled\"\n            [readonly]=\"_readonly\"\n            (blur)=\"onTouch($event)\" />\n    </label>"
                  },] },
      ];
      MbscRating.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
      ]; };
      MbscRating.propDecorators = {
          'options': [{ type: core.Input },],
          'name': [{ type: core.Input },],
          'min': [{ type: core.Input },],
          'max': [{ type: core.Input },],
          'step': [{ type: core.Input },],
          'disabled': [{ type: core.Input },],
          'empty': [{ type: core.Input },],
          'filled': [{ type: core.Input },],
          'readonly': [{ type: core.Input },],
          'val': [{ type: core.Input },],
          'template': [{ type: core.Input },],
          'value': [{ type: core.Input, args: ['value',] },],
          'onChangeEmitter': [{ type: core.Output, args: ['valueChange',] },],
          'color': [{ type: core.Input },],
      };
      return MbscRating;
  }(MbscControlBase));
  var MbscFormGroup = (function () {
      function MbscFormGroup(initialElem) {
          this.initialElem = initialElem;
          this.collapsible = null;
          this._open = false;
          this.instance = null;
          this.element = null;
          this.element = initialElem;
      }
      Object.defineProperty(MbscFormGroup.prototype, "open", {
          set: function (v) {
              if (this._open != v && this.instance) {
                  if (v) {
                      this.instance.show();
                  }
                  else {
                      this.instance.hide();
                  }
              }
              this._open = v;
          },
          enumerable: true,
          configurable: true
      });
      MbscFormGroup.prototype.emptyOrTrue = function (v) {
          return emptyOrTrue(v);
      };
      MbscFormGroup.prototype.ngAfterViewInit = function () {
          if (this.collapsible !== null) {
              this.instance = new CollapsibleBase(this.element.nativeElement, { isOpen: this._open !== false });
          }
      };
      MbscFormGroup.prototype.ngOnDestroy = function () {
          if (this.instance) {
              this.instance.destroy();
          }
      };
      MbscFormGroup.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-form-group',
                      template: '<ng-content></ng-content>',
                      host: {
                          '[class.mbsc-form-group-inset]': 'emptyOrTrue(inset)',
                          '[class.mbsc-form-group]': '!emptyOrTrue(inset)'
                      },
                      styles: [':host { display: block; }']
                  },] },
      ];
      MbscFormGroup.ctorParameters = function () { return [
          { type: core.ElementRef, },
      ]; };
      MbscFormGroup.propDecorators = {
          'collapsible': [{ type: core.Input },],
          'open': [{ type: core.Input },],
          'inset': [{ type: core.Input },],
      };
      return MbscFormGroup;
  }());
  var MbscFormGroupTitle = (function () {
      function MbscFormGroupTitle() {
      }
      MbscFormGroupTitle.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-form-group-title',
                      template: '<ng-content></ng-content>',
                      host: {
                          '[class.mbsc-form-group-title]': 'true'
                      },
                      styles: [':host { display: block; }']
                  },] },
      ];
      MbscFormGroupTitle.ctorParameters = function () { return []; };
      return MbscFormGroupTitle;
  }());
  var MbscFormGroupContent = (function () {
      function MbscFormGroupContent() {
      }
      MbscFormGroupContent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-form-group-content',
                      template: '<ng-content></ng-content>',
                      host: {
                          '[class.mbsc-form-group-content]': 'true'
                      },
                      styles: [':host { display: block; }']
                  },] },
      ];
      MbscFormGroupContent.ctorParameters = function () { return []; };
      return MbscFormGroupContent;
  }());
  var MbscAccordion = (function () {
      function MbscAccordion() {
      }
      MbscAccordion.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-accordion',
                      template: '<ng-content></ng-content>',
                      host: {
                          '[class.mbsc-accordion]': 'true'
                      },
                      styles: [':host { display: block; }']
                  },] },
      ];
      MbscAccordion.ctorParameters = function () { return []; };
      return MbscAccordion;
  }());
  var comp$3 = [
      MbscForm,
      MbscTextarea,
      MbscDropdown,
      MbscButton,
      MbscCheckbox,
      MbscSwitch,
      MbscStepper,
      MbscProgress,
      MbscRadioGroup,
      MbscRadioGroupBase,
      MbscRadio,
      MbscSegmentedGroup,
      MbscSegmented,
      MbscSlider,
      MbscRating,
      MbscFormGroup,
      MbscFormGroupTitle,
      MbscFormGroupContent,
      MbscAccordion
  ];
  var MbscFormsModule = (function () {
      function MbscFormsModule() {
      }
      MbscFormsModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [forms.FormsModule, common.CommonModule, MbscBaseModule, MbscInputModule],
                      declarations: comp$3,
                      exports: [comp$3, MbscInputModule, MbscInput]
                  },] },
      ];
      MbscFormsModule.ctorParameters = function () { return []; };
      return MbscFormsModule;
  }());

  var defaults$5 = {
    invalid: [],
    showInput: true,
    inputClass: '',
    itemSelector: 'li'
  };
  var List = function List(inst) {
    var currLevel,
        input,
        prevent,
        w,
        orig = extend$1({}, inst.settings),
        s = extend$1(inst.settings, defaults$5, orig),
        layout = s.layout || (/top|bottom/.test(s.display) ? 'liquid' : ''),
        isLiquid = layout == 'liquid',
        origReadOnly = s.readonly,
        elm = $$1(this),
        id = this.id + '_dummy',
        lvl = 0,
        currWheelVector = [],
        wa = s.wheelArray || createWheelArray(elm),
        fwv = firstWheelVector(wa);

    function getDepth(tree, l) {
      var i;
      lvl = l > lvl ? l : lvl;

      for (i = 0; i < tree.length; i++) {
        if (tree[i].children) {
          getDepth(tree[i].children, l + 1);
        }
      }
    }
    /**
     * Disables the invalid items on the wheels
     * @param {Object} dw - the jQuery mobiscroll object
     * @param {Number} nrWheels - the number of the current wheels
     * @param {Array} whArray - The wheel array objects containing the wheel tree
     * @param {Array} whVector - the wheel vector containing the current keys
     */


    function getDisabled(nrWheels, whArray, whVector) {
      var i = 0,
          disabled = [];

      while (i < nrWheels) {
        disabled[i] = getInvalidKeys(whVector, i, whArray);
        i++;
      }

      return disabled;
    }
    /**
     * Returns the invalid keys of one wheel as an array
     * @param {Array} whVector - the wheel vector used to search for the wheel in the wheel array
     * @param {Number} index - index of the wheel in the wheel vector, that we are interested in
     * @param {Array} whArray - the wheel array we are searching in
     * @return {Array} - list of invalid keys
     */


    function getInvalidKeys(whVector, index, whArray) {
      var i = 0,
          n,
          whObjA = whArray,
          invalids = [];

      while (i < index) {
        var ii = whVector[i];

        for (n in whObjA) {
          if (whObjA[n].key == ii) {
            whObjA = whObjA[n].children;
            break;
          }
        }

        i++;
      }

      i = 0;

      while (i < whObjA.length) {
        if (whObjA[i].invalid) {
          invalids.push(whObjA[i].key);
        }

        i++;
      }

      return invalids;
    }
    /**
     * Creates a Boolean vector with true values (except one) that can be used as the readonly vector
     * n - the length of the vector
     * i - the index of the value that's going to be false
     */


    function createROVector(n, i) {
      var a = [];

      while (n) {
        a[--n] = true;
      }

      a[i] = false;
      return a;
    }
    /**
     * Creates the wheel array from the vector provided
     * wv - wheel vector containing the values that should be selected on the wheels
     * l - the length of the wheel array
     */


    function generateWheelsFromVector(wv, l, index) {
      var nextLevel,
          j,
          i = 0,
          hasChildren = true,
          w = [[]],
          wtObjA = wa;

      if (l) {
        // if length is defined we need to generate that many wheels (even if they are empty)
        for (j = 0; j < l; j++) {
          if (isLiquid) {
            w[0][j] = {};
          } else {
            w[j] = [{}];
          }
        }
      }

      while (hasChildren) {
        if (isLiquid) {
          w[0][i] = getWheelFromObjA(wtObjA, i);
        } else {
          w[i] = [getWheelFromObjA(wtObjA, i)];
        }

        j = 0;
        nextLevel = null;

        while (j < wtObjA.length && !nextLevel) {
          if (wtObjA[j].key == wv[i] && (index !== undefined && i <= index || index === undefined)) {
            nextLevel = wtObjA[j];
          }

          j++;
        }

        if (!nextLevel) {
          nextLevel = getFirstValidItemObjOrInd(wtObjA);
        }

        if (nextLevel && nextLevel.children) {
          wtObjA = nextLevel.children;
          i++;
        } else {
          hasChildren = false;
        }
      }

      return w;
    }
    /**
     * Returns the first valid Wheel Node Object or its index from a Wheel Node Object Array
     * getInd - if it is true then the return value is going to be the index, otherwise the object itself
     */


    function getFirstValidItemObjOrInd(wtObjA, getInd) {
      if (!wtObjA) {
        return false;
      }

      var i = 0,
          obj;

      while (i < wtObjA.length) {
        if (!(obj = wtObjA[i++]).invalid) {
          return getInd ? i - 1 : obj;
        }
      }

      return false;
    }

    function getWheelFromObjA(objA, i) {
      var wheel = {
        data: [],
        label: s.labels && s.labels[i] ? s.labels[i] : i
      },
          j = 0;

      while (j < objA.length) {
        wheel.data.push({
          value: objA[j].key,
          display: objA[j].value
        });
        j++;
      }

      return wheel;
    }
    /**
     * Hides the last i number of wheels
     * i - the last number of wheels that has to be hidden
     */


    function hideWheels(i) {
      if (inst._isVisible) {
        $$1('.mbsc-sc-whl-w', inst._markup).css('display', '').slice(i).hide();
      }
    }
    /**
     * Generates the first wheel vector from the wheeltree
     * wt - the wheel tree object
     * uses the lvl global variable to determine the length of the vector
     */


    function firstWheelVector(wa) {
      var t = [],
          ndObjA = wa,
          obj,
          ok = true,
          i = 0;

      while (ok) {
        obj = getFirstValidItemObjOrInd(ndObjA);
        t[i++] = obj.key;
        ok = obj.children;

        if (ok) {
          ndObjA = ok;
        }
      }

      return t;
    }
    /**
     * Calculates the level of a wheel vector and the new wheel vector, depending on current wheel vector and the index of the changed wheel
     * wv - current wheel vector
     * index - index of the changed wheel
     */


    function calcLevelOfVector2(wv, index) {
      var childIdx,
          childName,
          i,
          level = 0,
          ndObjA = wa,
          next = true,
          t = [];

      while (next) {
        if (wv[level] !== undefined && level <= index) {
          i = 0;
          childName = wv[level];
          childIdx = undefined;

          while (i < ndObjA.length && childIdx === undefined) {
            if (ndObjA[i].key == wv[level] && !ndObjA[i].invalid) {
              childIdx = i;
            }

            i++;
          }
        } else {
          childIdx = getFirstValidItemObjOrInd(ndObjA, true);
          childName = ndObjA[childIdx] && ndObjA[childIdx].key;
        }

        t[level] = childName;
        level++;
        next = ndObjA[childIdx] ? ndObjA[childIdx].children : false;
        ndObjA = ndObjA[childIdx] && ndObjA[childIdx].children;
      } // return the calculated level and the wheel vector as an object


      return {
        lvl: level,
        nVector: t
      };
    }

    function createWheelArray(ul) {
      var wheelArray = [];
      var children = ul.length > 1 ? ul : ul.children(s.itemSelector);
      children.each(function (index) {
        var that = $$1(this),
            c = that.clone();
        c.children('ul,ol').remove();
        c.children(s.itemSelector).remove();
        var v = inst._processMarkup ? inst._processMarkup(c) : c.html().replace(/^\s\s*/, '').replace(/\s\s*$/, ''),
            inv = that.attr('data-invalid') ? true : false,
            wheelObj = {
          key: that.attr('data-val') === undefined || that.attr('data-val') === null ? index : that.attr('data-val'),
          value: v,
          invalid: inv,
          children: null
        },
            nest = s.itemSelector === 'li' ? that.children('ul,ol') : that.children(s.itemSelector);

        if (nest.length) {
          wheelObj.children = createWheelArray(nest);
        }

        wheelArray.push(wheelObj);
      });
      return wheelArray;
    }

    function changeWheels(values, index, o) {
      var j,
          i = (index || 0) + 1,
          args = [],
          w = {},
          wheels = {};
      w = generateWheelsFromVector(values, null, index);

      for (j = 0; j < values.length; j++) {
        inst._tempWheelArray[j] = values[j] = o.nVector[j] || 0;
      }

      while (i < o.lvl) {
        wheels[i] = isLiquid ? w[0][i] : w[i][0];
        args.push(i++);
      }

      hideWheels(o.lvl);
      currWheelVector = values.slice(0);

      if (args.length) {
        prevent = true;
        inst.changeWheel(wheels);
      }
    } // Calculate the maximum depth of the tree


    getDepth(wa, 1);
    w = generateWheelsFromVector(fwv, lvl); // Remove input if exists

    $$1('#' + id).remove();

    if (s.input) {
      input = $$1(s.input);
    } else if (s.showInput) {
      input = $$1('<input type="text" id="' + id + '" value="" class="' + s.inputClass + '" placeholder="' + (s.placeholder || '') + '" readonly />').insertBefore(elm);
    }

    if (input) {
      inst.attachShow(input);
    }

    if (!s.wheelArray) {
      elm.hide();
    }

    return {
      wheels: w,
      anchor: input,
      layout: layout,
      headerText: false,
      setOnTap: lvl == 1,
      formatValue: function formatValue(d) {
        if (currLevel === undefined) {
          currLevel = calcLevelOfVector2(d, d.length).lvl;
        }

        return d.slice(0, currLevel).join(' ');
      },
      parseValue: function parseValue(value) {
        return value ? (value + '').split(' ') : (s.defaultValue || fwv).slice(0);
      },
      onBeforeShow: function onBeforeShow() {
        var t = inst.getArrayVal(true);
        currWheelVector = t.slice(0);
        s.wheels = generateWheelsFromVector(t, lvl, lvl);
        prevent = true;
      },
      onWheelGestureStart: function onWheelGestureStart(ev) {
        s.readonly = createROVector(lvl, ev.index);
      },
      onWheelAnimationEnd: function onWheelAnimationEnd(ev) {
        var index = ev.index,
            values = inst.getArrayVal(true),
            o = calcLevelOfVector2(values, index);
        currLevel = o.lvl;
        s.readonly = origReadOnly;

        if (values[index] != currWheelVector[index]) {
          changeWheels(values, index, o);
        }
      },
      onFill: function onFill(ev) {
        currLevel = undefined;

        if (input) {
          input.val(ev.valueText);
        }
      },
      validate: function validate(data) {
        var values = data.values,
            index = data.index,
            o = calcLevelOfVector2(values, values.length);
        currLevel = o.lvl;

        if (index === undefined) {
          hideWheels(o.lvl);

          if (!prevent) {
            changeWheels(values, index, o);
          }
        }

        prevent = false;
        return {
          disabled: getDisabled(currLevel, wa, values)
        };
      },
      onDestroy: function onDestroy() {
        if (input) {
          $$1('#' + id).remove();
        }

        elm.show();
      }
    };
  };

  var ImageScroller = Scroller;

  presets.image = function (inst) {
    if (inst.settings.enhance) {
      inst._processMarkup = function (li) {
        var hasIcon = li.attr('data-icon');
        li.children().each(function (i, v) {
          v = $$1(v);

          if (v.is('img')) {
            $$1('<div class="mbsc-img-c"></div>').insertAfter(v).append(v.addClass('mbsc-img'));
          } else if (v.is('p')) {
            v.addClass('mbsc-img-txt');
          }
        });

        if (hasIcon) {
          li.prepend('<div class="mbsc-ic mbsc-ic-' + hasIcon + '"></div');
        }

        li.html('<div class="mbsc-img-w">' + li.html() + '</div>');
        return li.html();
      };
    }

    return List.call(this, inst);
  };

  var MbscImage = (function (_super) {
      __extends(MbscImage, _super);
      function MbscImage(initialElement, zone, control, inputService, optionService, view) {
          var _this = _super.call(this, initialElement, zone, control, inputService, view) || this;
          _this.optionService = optionService;
          _this.enhance = true;
          _this.placeholder = '';
          _this.options = {};
          _this.onChangeEmitter = new core.EventEmitter();
          return _this;
      }
      Object.defineProperty(MbscImage.prototype, "value", {
          set: function (v) {
              this.setNewValueProxy(v);
          },
          enumerable: true,
          configurable: true
      });
      MbscImage.prototype.initControl = function () {
          var _this = this;
          var target = this.target;
          if (target) {
              if (typeof target !== 'string') {
                  if (target._elementRef && target._elementRef.nativeElement) {
                      target = target._elementRef.nativeElement;
                  }
                  else if (target.getInputElement) {
                      target.getInputElement().then(function (inp) {
                          _this.updateOptions({ input: inp }, true, false, false);
                      });
                  }
                  else if (target.element) {
                      target = target.element;
                  }
              }
          }
          var options = extend$1({ preset: 'image', input: target }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
          this.instance = new ImageScroller(this.element, options);
          if (this.initialValue !== undefined) {
              this.instance.setVal(this.initialValue, true, false);
          }
      };
      MbscImage.prototype.setNewValue = function (v) {
          if (this.instance && this.instance.getVal() !== v) {
              this.instance.setVal(v, true, false);
              if (this._inputService && this._inputService.input) {
                  this._inputService.input.innerValue = this.instance._value;
              }
          }
      };
      MbscImage.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mbsc-image]',
                      exportAs: 'mobiscroll'
                  },] },
      ];
      MbscImage.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: core.ViewContainerRef, },
      ]; };
      MbscImage.propDecorators = {
          'defaultValue': [{ type: core.Input },],
          'enhance': [{ type: core.Input },],
          'inputClass': [{ type: core.Input },],
          'invalid': [{ type: core.Input },],
          'labels': [{ type: core.Input },],
          'placeholder': [{ type: core.Input },],
          'showInput': [{ type: core.Input },],
          'wheelArray': [{ type: core.Input, args: ['mbsc-data',] },],
          'options': [{ type: core.Input, args: ['mbsc-options',] },],
          'target': [{ type: core.Input, args: ['mbsc-target',] },],
          'value': [{ type: core.Input, args: ['mbsc-image',] },],
          'onChangeEmitter': [{ type: core.Output, args: ['mbsc-imageChange',] },],
      };
      return MbscImage;
  }(MbscScrollerBase));
  var MbscImageComponent = (function (_super) {
      __extends(MbscImageComponent, _super);
      function MbscImageComponent(initialElem, zone, listService, control, inputService, optionService) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
          _this.listService = listService;
          _this.errorMessage = '';
          _this.label = '';
          _this.placeholder = '';
          _this.showInput = false;
          _this.inlineOptionsObj = {
              itemSelector: 'mbsc-image-item',
              showInput: false
          };
          return _this;
      }
      MbscImageComponent.prototype.setElement = function () {
          if (this.itemWrapper) {
              this.element = this.itemWrapper.nativeElement;
          }
          else {
              this.element = this.initialElem.nativeElement;
          }
      };
      MbscImageComponent.prototype.ngOnInit = function () {
          var _this = this;
          _super.prototype.ngOnInit.call(this);
          this.addRemoveHandler = this.listService.onAddRemove().subscribe(function (item) {
              if (_this.instance) {
                  _this.instance.option({});
              }
          });
      };
      MbscImageComponent.prototype.ngAfterViewInit = function () {
          _super.prototype.ngAfterViewInit.call(this);
          this.setThemeClasses();
      };
      MbscImageComponent.prototype.initControl = function () {
          if (!this.target) {
              this.target = $$1('mbsc-input', this.initialElem.nativeElement)[0];
          }
          _super.prototype.initControl.call(this);
      };
      MbscImageComponent.prototype.ngOnDestroy = function () {
          this.listService.onAddRemove().unsubscribe(this.addRemoveHandler);
          _super.prototype.ngOnDestroy.call(this);
      };
      MbscImageComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-image',
                      exportAs: 'mobiscroll',
                      template: "<mbsc-input *ngIf=\"!inline || showInput\" \n        [name]=\"name\" \n        [theme]=\"theme\" \n        [disabled]=\"disabled\" \n        [error]=\"error\" \n        [errorMessage]=\"errorMessage\" \n        [icon]=\"inputIcon\" \n        [icon-align]=\"iconAlign\"\n        [placeholder]=\"placeholder\"\n        [controlNg]=\"false\">{{label}}\n        </mbsc-input>\n        <span #itemWrapper><ng-content></ng-content></span>",
                      providers: [MbscListService]
                  },] },
      ];
      MbscImageComponent.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: MbscListService, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscImageComponent.propDecorators = {
          'inputIcon': [{ type: core.Input, args: ['icon',] },],
          'iconAlign': [{ type: core.Input, args: ['icon-align',] },],
          'name': [{ type: core.Input },],
          'error': [{ type: core.Input },],
          'errorMessage': [{ type: core.Input },],
          'options': [{ type: core.Input },],
          'wheelArray': [{ type: core.Input, args: ['data',] },],
          'label': [{ type: core.Input },],
          'placeholder': [{ type: core.Input },],
          'itemWrapper': [{ type: core.ViewChild, args: ['itemWrapper', { static: false },] },],
          'showInput': [{ type: core.Input },],
      };
      return MbscImageComponent;
  }(MbscImage));
  var MbscImageItem = (function () {
      function MbscImageItem(listService) {
          this.listService = listService;
      }
      MbscImageItem.prototype.ngAfterViewInit = function () {
          this.listService.notifyAddRemove(this);
      };
      MbscImageItem.prototype.ngOnDestroy = function () {
          this.listService.notifyAddRemove(this);
      };
      MbscImageItem.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-image-item',
                      template: '<ng-content></ng-content>',
                      host: {
                          '[attr.data-val]': 'value',
                          '[attr.data-icon]': 'icon'
                      }
                  },] },
      ];
      MbscImageItem.ctorParameters = function () { return [
          { type: MbscListService, },
      ]; };
      MbscImageItem.propDecorators = {
          'value': [{ type: core.Input },],
          'icon': [{ type: core.Input },],
      };
      return MbscImageItem;
  }());
  var MbscImageModule = (function () {
      function MbscImageModule() {
      }
      MbscImageModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule, MbscScrollerBaseModule, MbscInputModule],
                      declarations: [MbscImage, MbscImageComponent, MbscImageItem],
                      exports: [MbscImage, MbscImageComponent, MbscImageItem]
                  },] },
      ];
      MbscImageModule.ctorParameters = function () { return []; };
      return MbscImageModule;
  }());

  var Measurement = Scroller;
  var defaults$6 = {
    batch: 50,
    min: 0,
    max: 100,
    defaultUnit: '',
    units: null,
    unitNames: null,
    invalid: [],
    sign: false,
    step: 0.05,
    scale: 2,
    convert: function convert(val) {
      return val;
    },
    // Localization
    decimalSeparator: '.',
    signText: '&nbsp;',
    wholeText: 'Whole',
    fractionText: 'Fraction',
    unitText: 'Unit'
  };

  presets.measurement = function (inst) {
    var orig = extend$1({}, inst.settings),
        s = extend$1(inst.settings, defaults$6, orig),
        wheel = {},
        w = [[]],
        wholeInvalids = {},
        wholeWheel = {},
        fractionWheel = {},
        fractions = [],
        useSign = s.sign,
        useUnits = s.units && s.units.length,
        baseUnit = useUnits ? s.defaultUnit || s.units[0] : '',
        units = [],
        useFract = s.step < 1,
        wholeStep = s.step > 1 ? s.step : 1,
        fractLength = useFract ? Math.max(s.scale, (s.step + '').split('.')[1].length) : 1,
        one = Math.pow(10, fractLength),
        steps = Math.round(useFract ? s.step * one : s.step),
        fractNr,
        realValue,
        oldUnit,
        idxFract,
        idxWhole,
        idxUnit,
        minVal,
        maxVal,
        minWhole,
        maxWhole,
        minFract,
        maxFract,
        wholeOffset = 0,
        fractOffset = 0,
        v,
        j,
        i = 0;

    function getWhole(k) {
      return Math.max(minWhole, Math.min(maxWhole, useFract ? k < 0 ? Math.ceil(k) : Math.floor(k) : step(Math.round(k - wholeOffset), steps) + wholeOffset));
    }

    function getFract(k) {
      return useFract ? step((Math.abs(k) - Math.abs(getWhole(k))) * one - fractOffset, steps) + fractOffset : 0;
    }

    function getParts(v) {
      var whole = getWhole(v),
          fract = getFract(v),
          sign = v < 0 ? '-' : '+';

      if (fract >= one) {
        if (v < 0) {
          whole--;
        } else {
          whole++;
        }

        fract = 0;
      }

      return [sign, whole, fract];
    }

    function getNr(d) {
      var whole = +d[idxWhole],
          fract = useFract ? d[idxFract] / one * (whole < 0 ? -1 : 1) : 0;
      return (useSign && d[0] == '-' ? -1 : 1) * (whole + fract);
    }

    function step(v, st) {
      return Math.round(v / st) * st;
    }

    function convert(v, u1, u2) {
      if (u1 === u2 || !s.convert) {
        return v;
      }

      return s.convert.call(this, v, u1, u2);
    }

    function setMinMax(unit) {
      var minv, maxv;
      minVal = convert(s.min, baseUnit, unit);
      maxVal = convert(s.max, baseUnit, unit);

      if (useFract) {
        minWhole = minVal < 0 ? Math.ceil(minVal) : Math.floor(minVal);
        maxWhole = maxVal < 0 ? Math.ceil(maxVal) : Math.floor(maxVal);
        minFract = getFract(minVal);
        maxFract = getFract(maxVal);
      } else {
        minWhole = Math.round(minVal);
        maxWhole = Math.round(maxVal);
        maxWhole = minWhole + Math.floor((maxWhole - minWhole) / steps) * steps;
        wholeOffset = minWhole % steps;
      }

      minv = minWhole;
      maxv = maxWhole;

      if (useSign) {
        maxv = Math.abs(minv) > Math.abs(maxv) ? Math.abs(minv) : Math.abs(maxv);
        minv = minv < 0 ? 0 : minv;
      }

      wholeWheel.min = minv < 0 ? Math.ceil(minv / wholeStep) : Math.floor(minv / wholeStep);
      wholeWheel.max = maxv < 0 ? Math.ceil(maxv / wholeStep) : Math.floor(maxv / wholeStep);
    }

    function format(d) {
      return getNr(d).toFixed(useFract ? fractLength : 0) + (useUnits ? ' ' + units[d[idxUnit]] : '');
    } // Extended methods
    // ---


    inst.setVal = function (val, fill, change, temp, time) {
      // Force parse if value is passed as an array
      inst._setVal($$1.isArray(val) ? format(val) : val, fill, change, temp, time);
    }; // ---
    // Inits
    // generate array from unitNames


    if (s.units) {
      for (j = 0; j < s.units.length; ++j) {
        v = s.units[j];
        units.push(s.unitNames ? s.unitNames[v] || v : v);
      }
    } // Check if sign is needed


    if (useSign) {
      useSign = false;

      if (useUnits) {
        for (j = 0; j < s.units.length; j++) {
          if (convert(s.min, baseUnit, s.units[j]) < 0) {
            useSign = true;
          }
        }
      } else {
        useSign = s.min < 0;
      }
    } // Sign wheel (if enabled)


    if (useSign) {
      w[0].push({
        data: ['-', '+'],
        label: s.signText
      });
      i++;
    } // Whole wheel (later generated)


    wholeWheel = {
      label: s.wholeText,
      data: function data(i) {
        return minWhole % wholeStep + i * wholeStep;
      },
      getIndex: function getIndex(i) {
        return Math.round((i - minWhole % wholeStep) / wholeStep);
      }
    };
    w[0].push(wholeWheel);
    idxWhole = i++;
    setMinMax(baseUnit); // Fraction wheel

    if (useFract) {
      w[0].push(fractionWheel);
      fractionWheel.data = [];
      fractionWheel.label = s.fractionText;

      for (j = fractOffset; j < one; j += steps) {
        fractions.push(j);
        fractionWheel.data.push({
          value: j,
          display: s.decimalSeparator + pad(j, fractLength)
        });
      }

      idxFract = i++;
      fractNr = Math.ceil(100 / steps);

      if (s.invalid && s.invalid.length) {
        // Calculate whole invalids
        $$1.each(s.invalid, function (i, v) {
          var w = v > 0 ? Math.floor(v) : Math.ceil(v);

          if (w === 0) {
            // We need to track +0 and -0 sepparately
            w = v <= 0 ? -0.001 : 0.001;
          }

          wholeInvalids[w] = (wholeInvalids[w] || 0) + 1;

          if (v === 0) {
            w = 0.001;
            wholeInvalids[w] = (wholeInvalids[w] || 0) + 1;
          }
        });
        $$1.each(wholeInvalids, function (i, v) {
          if (v < fractNr) {
            delete wholeInvalids[i];
          } else {
            wholeInvalids[i] = i;
          }
        });
      }
    } // Unit wheel


    if (useUnits) {
      wheel = {
        data: [],
        label: s.unitText,
        cssClass: 'mbsc-msr-whl-unit',
        circular: false
      };

      for (j = 0; j < s.units.length; j++) {
        wheel.data.push({
          value: j,
          display: units[j]
        });
      }

      w[0].push(wheel);
    }

    idxUnit = i;
    return {
      wheels: w,
      minWidth: useSign && useFract ? 70 : 80,
      showLabel: false,
      formatValue: format,
      compClass: 'mbsc-msr mbsc-sc',
      parseValue: function parseValue(v) {
        var vv = (typeof v === 'number' ? v + '' : v) || s.defaultValue,
            d = (vv + '').split(' '),
            val = +d[0],
            ret = [],
            parts,
            unit = '';

        if (useUnits) {
          unit = $$1.inArray(d[1], units);
          unit = unit == -1 ? $$1.inArray(baseUnit, s.units) : unit;
          unit = unit == -1 ? 0 : unit;
        }

        oldUnit = useUnits ? s.units[unit] : '';
        setMinMax(oldUnit);
        val = isNaN(val) ? 0 : val;
        val = constrain(val, minVal, maxVal);
        parts = getParts(val);
        parts[1] = constrain(parts[1], minWhole, maxWhole);
        realValue = val;

        if (useSign) {
          ret[0] = parts[0];
          parts[1] = Math.abs(parts[1]);
        }

        ret[idxWhole] = parts[1];

        if (useFract) {
          ret[idxFract] = parts[2];
        }

        if (useUnits) {
          ret[idxUnit] = unit;
        }

        return ret;
      },
      onCancel: function onCancel() {
        realValue = undefined;
      },
      validate: function validate(data) {
        var minus,
            parts,
            whole,
            iparts,
            from,
            values = data.values,
            index = data.index,
            dir = data.direction,
            dis = {},
            disabled = [],
            wheels = {},
            newUnit = useUnits ? s.units[values[idxUnit]] : ''; // Sign changed

        if (useSign && index === 0) {
          realValue = Math.abs(realValue) * (values[0] == '-' ? -1 : 1);
        } // Set real value if numbers changed


        if (index === idxWhole || index === idxFract && useFract || realValue === undefined || index === undefined) {
          realValue = getNr(values);
          oldUnit = newUnit;
        } // Convert value if unit changed


        if (useUnits && index === idxUnit && oldUnit !== newUnit || index === undefined) {
          setMinMax(newUnit);
          realValue = convert(realValue, oldUnit, newUnit);
          oldUnit = newUnit;
          parts = getParts(realValue);

          if (index !== undefined) {
            //wholeWheel._refresh();
            wheels[idxWhole] = wholeWheel;
            inst.changeWheel(wheels);
          }

          if (useSign) {
            values[0] = parts[0];
          }
        } // Disable invalid values


        disabled[idxWhole] = [];

        if (useSign) {
          // Disable +/- signs
          disabled[0] = [];

          if (minVal > 0) {
            disabled[0].push('-');
            values[0] = '+';
          }

          if (maxVal < 0) {
            disabled[0].push('+');
            values[0] = '-';
          }

          from = Math.abs(values[0] == '-' ? minWhole : maxWhole);

          for (i = from + wholeStep; i < from + 20 * wholeStep; i += wholeStep) {
            disabled[idxWhole].push(i);
            dis[i] = true;
          }
        }

        realValue = constrain(realValue, minVal, maxVal);
        parts = getParts(realValue);
        whole = useSign ? Math.abs(parts[1]) : parts[1];
        minus = useSign ? values[0] == '-' : realValue < 0;
        values[idxWhole] = whole;

        if (minus) {
          // Need this for 0
          parts[0] = '-';
        }

        if (useFract) {
          values[idxFract] = parts[2];
        } // Disable invalid values on whole wheel


        $$1.each(useFract ? wholeInvalids : s.invalid, function (i, v) {
          // disable whole user values
          if (useSign && minus) {
            if (v <= 0) {
              v = Math.abs(v);
            } else {
              return;
            }
          }

          v = step(convert(v, baseUnit, newUnit), useFract ? 1 : steps);
          dis[v] = true;
          disabled[idxWhole].push(v);
        }); // Find nearest valid whole value

        values[idxWhole] = inst.getValidValue(idxWhole, whole, dir, dis);
        parts[1] = values[idxWhole] * (useSign && minus ? -1 : 1); // Validate fraction wheel values

        if (useFract) {
          disabled[idxFract] = []; // We need to make difference between +0 and -0, so we compare the strings instead of numbers

          var p1 = useSign ? values[0] + values[1] : (realValue < 0 ? '-' : '+') + Math.abs(parts[1]),
              p2 = (minVal < 0 ? '-' : '+') + Math.abs(minWhole),
              p3 = (maxVal < 0 ? '-' : '+') + Math.abs(maxWhole); // Disable out of range fraction values

          if (p1 === p2) {
            $$1(fractions).each(function (i, v) {
              if (minus ? v > minFract : v < minFract) {
                disabled[idxFract].push(v);
              }
            });
          }

          if (p1 === p3) {
            $$1(fractions).each(function (i, v) {
              if (minus ? v < maxFract : v > maxFract) {
                disabled[idxFract].push(v);
              }
            });
          } // Disable invalid fraction values


          $$1.each(s.invalid, function (i, v) {
            iparts = getParts(convert(v, baseUnit, newUnit)); // Sign and whole part matches

            if ((parts[0] === iparts[0] || parts[1] === 0 && iparts[1] === 0 && iparts[2] === 0) && parts[1] === iparts[1]) {
              disabled[idxFract].push(iparts[2]);
            }
          });
        }

        return {
          disabled: disabled,
          valid: values
        };
      }
    };
  };

  var defaults$7 = {
    min: -20,
    max: 40,
    defaultUnit: 'c',
    units: ['c', 'k', 'f', 'r'],
    unitNames: {
      c: '°C',
      k: 'K',
      f: '°F',
      r: '°R'
    }
  },
      cobj = {
    c2k: function c2k(c) {
      return c + 273.15;
    },
    c2f: function c2f(c) {
      return c * 9 / 5 + 32;
    },
    c2r: function c2r(c) {
      return (c + 273.15) * 9 / 5;
    },
    k2c: function k2c(k) {
      return k - 273.15;
    },
    k2f: function k2f(k) {
      return k * 9 / 5 - 459.67;
    },
    k2r: function k2r(k) {
      return k * 9 / 5;
    },
    f2c: function f2c(f) {
      return (f - 32) * 5 / 9;
    },
    f2k: function f2k(f) {
      return (f + 459.67) * 5 / 9;
    },
    f2r: function f2r(f) {
      return f + 459.67;
    },
    r2c: function r2c(r) {
      return (r - 491.67) * 5 / 9;
    },
    r2k: function r2k(r) {
      return r * 5 / 9;
    },
    r2f: function r2f(r) {
      return r - 459.67;
    }
  };

  presets.temperature = function (inst) {
    var s = extend$1({}, defaults$7, inst.settings);
    extend$1(inst.settings, s, {
      sign: true,
      convert: function convert(val, unit1, unit2) {
        return cobj[unit1 + '2' + unit2](val);
      }
    });
    return presets.measurement.call(this, inst);
  };

  var defaults$8 = {
    min: 0,
    max: 100,
    defaultUnit: 'km',
    units: ['m', 'km', 'in', 'ft', 'yd', 'mi']
  },
      cobj$1 = {
    mm: 0.001,
    cm: 0.01,
    dm: 0.1,
    m: 1,
    dam: 10,
    hm: 100,
    km: 1000,
    'in': 0.0254,
    ft: 0.3048,
    yd: 0.9144,
    ch: 20.1168,
    fur: 201.168,
    mi: 1609.344,
    lea: 4828.032
  };

  presets.distance = function (inst) {
    var s = extend$1({}, defaults$8, inst.settings);
    extend$1(inst.settings, s, {
      sign: false,
      convert: function convert(val, unit1, unit2) {
        return val * cobj$1[unit1] / cobj$1[unit2];
      }
    });
    return presets.measurement.call(this, inst);
  };

  var defaults$9 = {
    min: 0,
    max: 100,
    defaultUnit: 'kph',
    units: ['kph', 'mph', 'mps', 'fps', 'knot'],
    unitNames: {
      kph: 'km/h',
      mph: 'mi/h',
      mps: 'm/s',
      fps: 'ft/s',
      knot: 'knot'
    }
  },
      cobj$2 = {
    kph: 1,
    mph: 1.60934,
    mps: 3.6,
    fps: 1.09728,
    knot: 1.852
  };

  presets.speed = function (inst) {
    var s = extend$1({}, defaults$9, inst.settings);
    extend$1(inst.settings, s, {
      sign: false,
      convert: function convert(val, unit1, unit2) {
        return val * cobj$2[unit1] / cobj$2[unit2];
      }
    });
    return presets.measurement.call(this, inst);
  };

  var defaults$a = {
    min: 0,
    max: 100,
    defaultUnit: 'N',
    units: ['N', 'kp', 'lbf', 'pdl']
  },
      cobj$3 = {
    N: 1,
    kp: 9.80665,
    lbf: 4.448222,
    pdl: 0.138255
  };

  presets.force = function (inst) {
    var s = extend$1({}, defaults$a, inst.settings);
    extend$1(inst.settings, s, {
      sign: false,
      convert: function convert(val, unit1, unit2) {
        return val * cobj$3[unit1] / cobj$3[unit2];
      }
    });
    return presets.measurement.call(this, inst);
  };

  var defaults$b = {
    min: 0,
    max: 1000,
    defaultUnit: 'kg',
    units: ['g', 'kg', 'oz', 'lb'],
    unitNames: {
      tlong: 't (long)',
      tshort: 't (short)'
    }
  },
      cobj$4 = {
    mg: 0.001,
    cg: 0.01,
    dg: 0.1,
    g: 1,
    dag: 10,
    hg: 100,
    kg: 1000,
    t: 1000000,
    drc: 1.7718452,
    oz: 28.3495,
    lb: 453.59237,
    st: 6350.29318,
    qtr: 12700.58636,
    cwt: 50802.34544,
    tlong: 1016046.9088,
    tshort: 907184.74
  };

  presets.mass = function (inst) {
    var s = extend$1({}, defaults$b, inst.settings);
    extend$1(inst.settings, s, {
      sign: false,
      convert: function convert(val, unit1, unit2) {
        return val * cobj$4[unit1] / cobj$4[unit2];
      }
    });
    return presets.measurement.call(this, inst);
  };

  var MbscMeasurementBase = (function (_super) {
      __extends(MbscMeasurementBase, _super);
      function MbscMeasurementBase(initialElement, zone, control, inputService, optionService, view) {
          var _this = _super.call(this, initialElement, zone, control, inputService, view) || this;
          _this.optionService = optionService;
          _this.preset = 'measurement';
          _this.onChangeEmitter = new core.EventEmitter();
          return _this;
      }
      Object.defineProperty(MbscMeasurementBase.prototype, "value", {
          set: function (v) {
              this.setNewValueProxy(v);
          },
          enumerable: true,
          configurable: true
      });
      MbscMeasurementBase.prototype.setNewValue = function (v) {
          if (this.instance) {
              var innerValue = this.instance.getVal();
              if (innerValue !== v) {
                  this.instance.setVal(v, true, false);
                  if (this._inputService && this._inputService.input) {
                      this._inputService.input.innerValue = this.instance._value;
                  }
              }
          }
      };
      MbscMeasurementBase.prototype.initControl = function () {
          var options = extend$1({ preset: this.preset }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
          this.instance = new Scroller(this.element, options);
          if (this.initialValue !== undefined) {
              this.instance.setVal(this.initialValue, true, false);
          }
      };
      MbscMeasurementBase.decorators = [
          { type: core.Directive, args: [{ selector: '[mbsc-m-b]' },] },
      ];
      MbscMeasurementBase.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, },
          { type: MbscInputService, },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: core.ViewContainerRef, },
      ]; };
      MbscMeasurementBase.propDecorators = {
          'max': [{ type: core.Input },],
          'min': [{ type: core.Input },],
          'decimalSeparator': [{ type: core.Input },],
          'defaultValue': [{ type: core.Input },],
          'invalid': [{ type: core.Input },],
          'scale': [{ type: core.Input },],
          'step': [{ type: core.Input },],
          'defaultUnit': [{ type: core.Input },],
          'unitNames': [{ type: core.Input },],
          'units': [{ type: core.Input },],
          'wholeText': [{ type: core.Input },],
          'fractionText': [{ type: core.Input },],
          'signText': [{ type: core.Input },],
          'value': [{ type: core.Input, args: ['mbsc-measurement',] },],
          'onChangeEmitter': [{ type: core.Output, args: ['mbsc-measurementChange',] },],
      };
      return MbscMeasurementBase;
  }(MbscScrollerBase));
  var MbscMeasurementChild = (function (_super) {
      __extends(MbscMeasurementChild, _super);
      function MbscMeasurementChild(initialElement, zone, control, inputService, optionService, view) {
          return _super.call(this, initialElement, zone, control, inputService, optionService, view) || this;
      }
      MbscMeasurementChild.decorators = [
          { type: core.Directive, args: [{ selector: '[mbsc-m-c]' },] },
      ];
      MbscMeasurementChild.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, },
          { type: MbscInputService, },
          { type: MbscOptionsService, },
          { type: core.ViewContainerRef, },
      ]; };
      MbscMeasurementChild.propDecorators = {
          'convert': [{ type: core.Input },],
      };
      return MbscMeasurementChild;
  }(MbscMeasurementBase));
  var MbscMeasurement = (function (_super) {
      __extends(MbscMeasurement, _super);
      function MbscMeasurement(initialElem, zone, control, inputService, optionService, view) {
          return _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;
      }
      MbscMeasurement.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mbsc-measurement]',
                      exportAs: 'mobiscroll'
                  },] },
      ];
      MbscMeasurement.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: core.ViewContainerRef, },
      ]; };
      MbscMeasurement.propDecorators = {
          'convert': [{ type: core.Input },],
          'options': [{ type: core.Input, args: ['mbsc-options',] },],
      };
      return MbscMeasurement;
  }(MbscMeasurementBase));
  var MbscMeasurementComponent = (function (_super) {
      __extends(MbscMeasurementComponent, _super);
      function MbscMeasurementComponent(initialElem, zone, control, inputService, optionService) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
          _this.errorMessage = '';
          _this.placeholder = '';
          return _this;
      }
      MbscMeasurementComponent.prototype.ngAfterViewInit = function () {
          _super.prototype.ngAfterViewInit.call(this);
          this.setThemeClasses();
      };
      MbscMeasurementComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-measurement',
                      exportAs: 'mobiscroll',
                      template: INPUT_TEMPLATE
                  },] },
      ];
      MbscMeasurementComponent.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscMeasurementComponent.propDecorators = {
          'inputIcon': [{ type: core.Input, args: ['icon',] },],
          'iconAlign': [{ type: core.Input, args: ['icon-align',] },],
          'name': [{ type: core.Input },],
          'error': [{ type: core.Input },],
          'errorMessage': [{ type: core.Input },],
          'options': [{ type: core.Input },],
          'placeholder': [{ type: core.Input },],
      };
      return MbscMeasurementComponent;
  }(MbscMeasurement));
  var MbscTemperature = (function (_super) {
      __extends(MbscTemperature, _super);
      function MbscTemperature(initialElem, zone, control, inputService, optionService, view) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;
          _this.options = {};
          _this.onChangeEmitter = new core.EventEmitter();
          _this.preset = 'temperature';
          return _this;
      }
      Object.defineProperty(MbscTemperature.prototype, "value", {
          set: function (v) {
              this.setNewValueProxy(v);
          },
          enumerable: true,
          configurable: true
      });
      MbscTemperature.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mbsc-temperature]',
                      exportAs: 'mobiscroll'
                  },] },
      ];
      MbscTemperature.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: core.ViewContainerRef, },
      ]; };
      MbscTemperature.propDecorators = {
          'options': [{ type: core.Input, args: ['mbsc-options',] },],
          'value': [{ type: core.Input, args: ['mbsc-temperature',] },],
          'onChangeEmitter': [{ type: core.Output, args: ['mbsc-temperatureChange',] },],
      };
      return MbscTemperature;
  }(MbscMeasurementChild));
  var MbscTemperatureComponent = (function (_super) {
      __extends(MbscTemperatureComponent, _super);
      function MbscTemperatureComponent(initialElem, zone, control, inputService, optionService) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
          _this.errorMessage = '';
          _this.placeholder = '';
          return _this;
      }
      MbscTemperatureComponent.prototype.ngAfterViewInit = function () {
          _super.prototype.ngAfterViewInit.call(this);
          this.setThemeClasses();
      };
      MbscTemperatureComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-temperature',
                      exportAs: 'mobiscroll',
                      template: INPUT_TEMPLATE
                  },] },
      ];
      MbscTemperatureComponent.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscTemperatureComponent.propDecorators = {
          'inputIcon': [{ type: core.Input, args: ['icon',] },],
          'iconAlign': [{ type: core.Input, args: ['icon-align',] },],
          'name': [{ type: core.Input },],
          'error': [{ type: core.Input },],
          'errorMessage': [{ type: core.Input },],
          'options': [{ type: core.Input },],
          'placeholder': [{ type: core.Input },],
      };
      return MbscTemperatureComponent;
  }(MbscTemperature));
  var MbscDistance = (function (_super) {
      __extends(MbscDistance, _super);
      function MbscDistance(initialElem, zone, control, inputService, optionService, view) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;
          _this.options = {};
          _this.onChangeEmitter = new core.EventEmitter();
          _this.preset = 'distance';
          return _this;
      }
      Object.defineProperty(MbscDistance.prototype, "value", {
          set: function (v) {
              this.setNewValueProxy(v);
          },
          enumerable: true,
          configurable: true
      });
      MbscDistance.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mbsc-distance]',
                      exportAs: 'mobiscroll'
                  },] },
      ];
      MbscDistance.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: core.ViewContainerRef, },
      ]; };
      MbscDistance.propDecorators = {
          'options': [{ type: core.Input, args: ['mbsc-options',] },],
          'value': [{ type: core.Input, args: ['mbsc-distance',] },],
          'onChangeEmitter': [{ type: core.Output, args: ['mbsc-distanceChange',] },],
      };
      return MbscDistance;
  }(MbscMeasurementBase));
  var MbscDistanceComponent = (function (_super) {
      __extends(MbscDistanceComponent, _super);
      function MbscDistanceComponent(initialElem, zone, control, inputService, optionService) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
          _this.errorMessage = '';
          _this.placeholder = '';
          return _this;
      }
      MbscDistanceComponent.prototype.ngAfterViewInit = function () {
          _super.prototype.ngAfterViewInit.call(this);
          this.setThemeClasses();
      };
      MbscDistanceComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-distance',
                      exportAs: 'mobiscroll',
                      template: INPUT_TEMPLATE
                  },] },
      ];
      MbscDistanceComponent.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscDistanceComponent.propDecorators = {
          'inputIcon': [{ type: core.Input, args: ['icon',] },],
          'iconAlign': [{ type: core.Input, args: ['icon-align',] },],
          'name': [{ type: core.Input },],
          'error': [{ type: core.Input },],
          'errorMessage': [{ type: core.Input },],
          'options': [{ type: core.Input },],
          'placeholder': [{ type: core.Input },],
      };
      return MbscDistanceComponent;
  }(MbscDistance));
  var MbscSpeed = (function (_super) {
      __extends(MbscSpeed, _super);
      function MbscSpeed(initialElem, zone, control, inputService, optionService, view) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;
          _this.options = {};
          _this.onChangeEmitter = new core.EventEmitter();
          _this.preset = 'speed';
          return _this;
      }
      Object.defineProperty(MbscSpeed.prototype, "value", {
          set: function (v) {
              this.setNewValueProxy(v);
          },
          enumerable: true,
          configurable: true
      });
      MbscSpeed.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mbsc-speed]',
                      exportAs: 'mobiscroll'
                  },] },
      ];
      MbscSpeed.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: core.ViewContainerRef, },
      ]; };
      MbscSpeed.propDecorators = {
          'options': [{ type: core.Input, args: ['mbsc-options',] },],
          'value': [{ type: core.Input, args: ['mbsc-speed',] },],
          'onChangeEmitter': [{ type: core.Output, args: ['mbsc-speedChange',] },],
      };
      return MbscSpeed;
  }(MbscMeasurementBase));
  var MbscSpeedComponent = (function (_super) {
      __extends(MbscSpeedComponent, _super);
      function MbscSpeedComponent(initialElem, zone, control, inputService, optionService) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
          _this.errorMessage = '';
          _this.placeholder = '';
          return _this;
      }
      MbscSpeedComponent.prototype.ngAfterViewInit = function () {
          _super.prototype.ngAfterViewInit.call(this);
          this.setThemeClasses();
      };
      MbscSpeedComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-speed',
                      exportAs: 'mobiscroll',
                      template: INPUT_TEMPLATE
                  },] },
      ];
      MbscSpeedComponent.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscSpeedComponent.propDecorators = {
          'inputIcon': [{ type: core.Input, args: ['icon',] },],
          'iconAlign': [{ type: core.Input, args: ['icon-align',] },],
          'name': [{ type: core.Input },],
          'error': [{ type: core.Input },],
          'errorMessage': [{ type: core.Input },],
          'options': [{ type: core.Input },],
          'placeholder': [{ type: core.Input },],
      };
      return MbscSpeedComponent;
  }(MbscSpeed));
  var MbscForce = (function (_super) {
      __extends(MbscForce, _super);
      function MbscForce(initialElem, zone, control, inputService, optionService, view) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;
          _this.options = {};
          _this.onChangeEmitter = new core.EventEmitter();
          _this.preset = 'force';
          return _this;
      }
      Object.defineProperty(MbscForce.prototype, "value", {
          set: function (v) {
              this.setNewValueProxy(v);
          },
          enumerable: true,
          configurable: true
      });
      MbscForce.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mbsc-force]',
                      exportAs: 'mobiscroll'
                  },] },
      ];
      MbscForce.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: core.ViewContainerRef, },
      ]; };
      MbscForce.propDecorators = {
          'options': [{ type: core.Input, args: ['mbsc-options',] },],
          'value': [{ type: core.Input, args: ['mbsc-force',] },],
          'onChangeEmitter': [{ type: core.Output, args: ['mbsc-forceChange',] },],
      };
      return MbscForce;
  }(MbscMeasurementBase));
  var MbscForceComponent = (function (_super) {
      __extends(MbscForceComponent, _super);
      function MbscForceComponent(initialElem, zone, control, inputService, optionService) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
          _this.errorMessage = '';
          _this.placeholder = '';
          return _this;
      }
      MbscForceComponent.prototype.ngAfterViewInit = function () {
          _super.prototype.ngAfterViewInit.call(this);
          this.setThemeClasses();
      };
      MbscForceComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-force',
                      exportAs: 'mobiscroll',
                      template: INPUT_TEMPLATE
                  },] },
      ];
      MbscForceComponent.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscForceComponent.propDecorators = {
          'inputIcon': [{ type: core.Input, args: ['icon',] },],
          'iconAlign': [{ type: core.Input, args: ['icon-align',] },],
          'name': [{ type: core.Input },],
          'error': [{ type: core.Input },],
          'errorMessage': [{ type: core.Input },],
          'options': [{ type: core.Input },],
          'placeholder': [{ type: core.Input },],
      };
      return MbscForceComponent;
  }(MbscForce));
  var MbscMass = (function (_super) {
      __extends(MbscMass, _super);
      function MbscMass(initialElem, zone, control, inputService, optionService, view) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;
          _this.options = {};
          _this.onChangeEmitter = new core.EventEmitter();
          _this.preset = 'mass';
          return _this;
      }
      Object.defineProperty(MbscMass.prototype, "value", {
          set: function (v) {
              this.setNewValueProxy(v);
          },
          enumerable: true,
          configurable: true
      });
      MbscMass.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mbsc-mass]',
                      exportAs: 'mobiscroll'
                  },] },
      ];
      MbscMass.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: core.ViewContainerRef, },
      ]; };
      MbscMass.propDecorators = {
          'options': [{ type: core.Input, args: ['mbsc-options',] },],
          'value': [{ type: core.Input, args: ['mbsc-mass',] },],
          'onChangeEmitter': [{ type: core.Output, args: ['mbsc-massChange',] },],
      };
      return MbscMass;
  }(MbscMeasurementBase));
  var MbscMassComponent = (function (_super) {
      __extends(MbscMassComponent, _super);
      function MbscMassComponent(initialElem, zone, control, inputService, optionService) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
          _this.errorMessage = '';
          _this.placeholder = '';
          return _this;
      }
      MbscMassComponent.prototype.ngAfterViewInit = function () {
          _super.prototype.ngAfterViewInit.call(this);
          this.setThemeClasses();
      };
      MbscMassComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-mass',
                      exportAs: 'mobiscroll',
                      template: INPUT_TEMPLATE
                  },] },
      ];
      MbscMassComponent.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscMassComponent.propDecorators = {
          'inputIcon': [{ type: core.Input, args: ['icon',] },],
          'iconAlign': [{ type: core.Input, args: ['icon-align',] },],
          'name': [{ type: core.Input },],
          'error': [{ type: core.Input },],
          'errorMessage': [{ type: core.Input },],
          'options': [{ type: core.Input },],
          'placeholder': [{ type: core.Input },],
      };
      return MbscMassComponent;
  }(MbscMass));
  var comp$4 = [
      MbscMeasurement,
      MbscMeasurementBase,
      MbscMeasurementChild,
      MbscMeasurementComponent,
      MbscTemperature,
      MbscTemperatureComponent,
      MbscDistance,
      MbscDistanceComponent,
      MbscSpeed,
      MbscSpeedComponent,
      MbscForce,
      MbscForceComponent,
      MbscMass,
      MbscMassComponent
  ];
  var MbscMeasurementModule = (function () {
      function MbscMeasurementModule() {
      }
      MbscMeasurementModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule, MbscScrollerBaseModule, MbscInputModule],
                      declarations: comp$4,
                      exports: comp$4
                  },] },
      ];
      MbscMeasurementModule.ctorParameters = function () { return []; };
      return MbscMeasurementModule;
  }());

  // eslint-disable-next-line no-unused-vars
  var guid$1 = 1;
  var ScrollView = function ScrollView(elm, settings, inherit) {
    var $activeItem,
        $cont,
        $ctx,
        $wnd,
        contWidth,
        itemWidth,
        isClick,
        observer,
        oldWidth,
        posDebounce,
        rtl,
        scrollView,
        snap,
        s,
        totalWidth,
        touched,
        trigger,
        cssClasses = {},
        that = this,
        $elm = $$1(elm);

    function onResize(ev) {
      clearTimeout(posDebounce);
      posDebounce = setTimeout(function () {
        size(!ev || ev.type !== 'load');
      }, 200);
    }

    function onClick() {
      if (isClick && this.parentNode === elm) {
        onItemTap($$1(this), true);
      }
    }

    function onItemTap($item, toggle, animTime) {
      if (!$item.length) {
        return;
      }

      if (animTime === undefined) {
        animTime = 1000;
      }

      toggle = that._onItemTap($item, toggle);
      $activeItem = $item;

      if ($item.parent()[0] == elm) {
        var bl = $item.offset().left,
            bp = $item[0].offsetLeft,
            bw = $item[0].offsetWidth,
            cl = $cont.offset().left;

        if (rtl) {
          bp = totalWidth - bp - bw;
        } // Scroll item to view


        if (s.variant == 'a') {
          if (bl < cl) {
            scrollView.scroll(rtl ? bp + bw - contWidth : -bp, animTime, true);
          } else if (bl + bw > cl + contWidth) {
            scrollView.scroll(rtl ? bp : contWidth - bp - bw, animTime, true);
          }
        } else {
          // Scroll item to center
          scrollView.scroll((contWidth / 2 - bp - bw / 2) * (rtl ? -1 : 1), animTime, true);
        }
      }

      if (toggle && !$item.hasClass('mbsc-disabled')) {
        // Trigger tap event
        trigger('onItemTap', {
          target: $item[0]
        });
      }
    }

    function initMarkup() {
      var $firstItem, props;

      that._initMarkup($cont);

      $elm.find('.mbsc-ripple').remove();
      that._$items = $elm.children();

      that._$items.each(function (i) {
        var cssClass,
            $item = $$1(this),
            ref = $item.attr('data-ref');

        if (!ref) {
          ref = guid$1++;
        }

        if (i === 0) {
          $firstItem = $item;
        }

        if (!$activeItem) {
          $activeItem = that._getActiveItem($item);
        }

        props = that._getItemProps($item) || {};
        cssClass = 'mbsc-scv-item mbsc-btn-e ' + (props.cssClass || '');
        $item.attr('data-ref', ref).removeClass(cssClasses[ref]).addClass(cssClass);
        cssClasses[ref] = cssClass;
        $item.append(that._getText(mobiscroll, 0.2));
      });

      if (!$activeItem) {
        $activeItem = $firstItem;
      }

      that._markupReady($cont);
    }

    function size(check, noScroll) {
      var w = s.itemWidth,
          layout = s.layout;
      that.contWidth = contWidth = $cont.width();

      if (that._checkResp()) {
        return false;
      }

      if (check && oldWidth === contWidth || !contWidth) {
        // Don't do anything if container width has not changed
        return;
      }

      oldWidth = contWidth;

      if (isNumeric(layout)) {
        itemWidth = contWidth ? contWidth / layout : w;

        if (itemWidth < w) {
          layout = 'liquid';
        }
      }

      if (w) {
        if (layout == 'liquid') {
          // The specified itemWidth will be handled as min width
          itemWidth = contWidth ? contWidth / Math.min(Math.floor(contWidth / w), that._$items.length) : w;
        } else if (layout == 'fixed') {
          // Fixed width
          itemWidth = w;
        }
      }

      that._size(contWidth, itemWidth);

      if (itemWidth) {
        $elm.children().css('width', itemWidth + 'px');
      }

      that.totalWidth = totalWidth = elm.offsetWidth;
      extend$1(scrollView.settings, {
        contSize: contWidth,
        maxSnapScroll: s.paging ? 1 : false,
        maxScroll: 0,
        minScroll: totalWidth > contWidth ? contWidth - totalWidth : 0,
        snap: s.paging ? contWidth : snap ? itemWidth || '.mbsc-scv-item' : false,
        elastic: totalWidth > contWidth ? itemWidth || contWidth : false
      }); // Pass new values to scrollview

      scrollView.refresh(noScroll); // Make sure the active item remains visible

      if ($activeItem) {
        onItemTap($activeItem, false);
      }
    } // Call the parent constructor


    Base.call(this, elm, settings, true);

    that.navigate = function ($item, toggle, animTime) {
      onItemTap(that._getItem($item), toggle, animTime);
    };

    that.next = function (toggle) {
      if ($activeItem) {
        var $next = $activeItem.next();

        if ($next.length) {
          $activeItem = $next;
          onItemTap($activeItem, toggle);
        }
      }
    };

    that.prev = function (toggle) {
      if ($activeItem) {
        var $prev = $activeItem.prev();

        if ($prev.length) {
          $activeItem = $prev;
          onItemTap($activeItem, toggle);
        }
      }
    };
    /**
     * Recalculates sizes.
     */


    that.refresh = that.position = function (noScroll) {
      initMarkup();
      size(false, noScroll);
    };
    /**
     * Initialization.
     */


    that._init = function () {
      var contClass;
      $ctx = $$1(s.context);
      $wnd = $$1(s.context == 'body' ? window : s.context);

      that.__init();
      /*
      rtl = s.rtl;
      snap = (s.itemWidth && s.layout != 'fixed' && s.snap === undefined) ? true : s.snap;
      contClass = 'mbsc-scv-c mbsc-no-touch' + ' mbsc-' + s.theme + ' ' +
          (s.cssClass || '') + ' ' +
          (s.wrapperClass || '') +
          (s.baseTheme ? ' mbsc-' + s.baseTheme : '') +
          (rtl ? ' mbsc-rtl' : ' mbsc-ltr') +
          (s.itemWidth ? ' mbsc-scv-hasw' : '') +
          (s.context == 'body' ? '' : ' mbsc-scv-ctx') + ' ' +
          (that._getContClass() || '');
          */
      // --- REMOTE TRIAL CODE START ---


      rtl = that.remote.menustrip.rtlSetting;
      snap = that.remote.menustrip.snapSetting;
      contClass = that.remote.menustrip.contClass + (that._getContClass() || ''); // --- REMOTE TRIAL CODE END ---

      if (!$cont) {
        $cont = $$1('<div class="' + contClass + '"><div class="mbsc-scv-sc"></div></div>').on('click', '.mbsc-scv-item', onClick).insertAfter($elm);
        $cont.find('.mbsc-scv-sc').append($elm); // When images are loaded, size migth change

        $cont.find('img').on('load', onResize);
        $wnd.on('orientationchange resize', onResize);
        observer = resizeObserver($cont[0], onResize, s.zone);
        scrollView = new ScrollViewBase($cont[0], {
          axis: 'X',
          contSize: 0,
          maxScroll: 0,
          maxSnapScroll: 1,
          minScroll: 0,
          snap: 1,
          elastic: 1,
          rtl: rtl,
          mousewheel: s.mousewheel,
          thresholdX: s.threshold,
          stopProp: s.stopProp,
          onStart: function onStart(ev) {
            if (ev.domEvent.type == 'touchstart') {
              isClick = false;

              if (!touched) {
                touched = true;
                $ctx.find('.mbsc-no-touch').removeClass('mbsc-no-touch');
              }
            }
          },
          onBtnTap: function onBtnTap(ev) {
            isClick = true; // Trigger click and activate target, if it's a form control

            var domEvent = ev.domEvent,
                target = domEvent.target;

            if (domEvent.type === 'touchend' && s.tap) {
              activateControl(target, getControlType($$1(target)), domEvent);
            }
          },
          onGestureStart: function onGestureStart(ev) {
            trigger('onGestureStart', ev);
          },
          onGestureEnd: function onGestureEnd(ev) {
            trigger('onGestureEnd', ev);
          },
          onMove: function onMove(ev) {
            trigger('onMove', ev);
          },
          onAnimationStart: function onAnimationStart(ev) {
            trigger('onAnimationStart', ev);
          },
          onAnimationEnd: function onAnimationEnd(ev) {
            trigger('onAnimationEnd', ev);
          }
        });
      } else {
        $cont.attr('class', contClass); // Remove ripple events (if theme changed)

        if (elm.__mbscRippleOff) {
          elm.__mbscRippleOff();
        }
      } // Prepare markup


      $elm.css('display', '').addClass('mbsc-scv').removeClass('mbsc-cloak');
      initMarkup();
      trigger('onMarkupReady', {
        target: $cont[0]
      });
      size();
    };

    that._size = noop;
    that._initMarkup = noop;
    that._markupReady = noop;
    that._getContClass = noop;
    that._getItemProps = noop;
    that._getActiveItem = noop;
    that.__init = noop;
    that.__destroy = noop;
    /**
     * Destroy
     */

    that._destroy = function () {
      that.__destroy();

      $wnd.off('orientationchange resize', onResize);
      $elm.removeClass('mbsc-scv').insertAfter($cont).find('.mbsc-scv-item').each(function () {
        var $item = $$1(this);
        $item.width('').removeClass(cssClasses[$item.attr('data-ref')]);
      });
      $cont.remove();
      scrollView.destroy();
      observer.detach();
    };

    that._getItem = function (item) {
      if (typeof item !== 'object') {
        item = that._$items.filter('[data-id="' + item + '"]');
      }

      return $$1(item);
    };

    that._onItemTap = function ($item, toggle) {
      if (toggle === undefined) {
        return true;
      }

      return toggle;
    }; // ---
    // Constructor


    s = that.settings;
    trigger = that.trigger;

    if (!inherit) {
      that.init();
    }
  }; // Defaults

  ScrollView.prototype = {
    _class: 'scrollview',
    _hasDef: true,
    _hasTheme: true,
    _hasLang: true,
    _responsive: true,
    _defaults: {
      tap: hasGhostClick,
      stopProp: false,
      context: 'body',
      layout: 'liquid'
    }
  };
  classes.ScrollView = ScrollView;

  var NavigationBase = function NavigationBase(elm, settings, inherit) {
    var $ctx,
        display,
        multiple,
        select,
        selectedClass,
        s,
        $elm = $$1(elm),
        that = this;

    function removePagePadding() {
      if (display && display != 'inline') {
        $ctx.find('.mbsc-page').css('padding-' + display, '');
      }
    }

    function selectItem($item) {
      $item.addClass(selectedClass).attr('data-selected', 'true').attr('aria-selected', 'true');
    }

    function deselectItem($item) {
      $item.removeClass(selectedClass).removeAttr('data-selected').removeAttr('aria-selected');
    } // Call the parent constructor


    ScrollView.call(this, elm, settings, true);

    that.select = function ($item) {
      if (!multiple) {
        deselectItem(that._$items.filter('.mbsc-ms-item-sel'));
      }

      selectItem(that._getItem($item));
    };

    that.deselect = function ($item) {
      deselectItem(that._getItem($item));
    };

    that.enable = function ($item) {
      that._getItem($item).removeClass('mbsc-disabled').removeAttr('data-disabled').removeAttr('aria-disabled');
    };

    that.disable = function ($item) {
      that._getItem($item).addClass('mbsc-disabled').attr('data-disabled', 'true').attr('aria-disabled', 'true');
    };

    that.setBadge = function ($item, content) {
      var $badge;
      $item = that._getItem($item).attr('data-badge', content);
      $badge = $$1('.mbsc-ms-badge', $item);

      if ($badge.length) {
        if (content) {
          $badge.html(content);
        } else {
          $badge.remove();
        }
      } else if (content) {
        $item.append('<span class="mbsc-ms-badge">' + content + '</span>');
      }
    };

    that._markupReady = function ($cont) {
      if (that._hasIcons) {
        $cont.addClass('mbsc-ms-icons');
      } else {
        $cont.removeClass('mbsc-ms-icons');
      }

      if (that._hasText) {
        $cont.addClass('mbsc-ms-txt');
      } else {
        $cont.removeClass('mbsc-ms-txt');
      }

      that.__markupReady($cont);
    };

    that._size = function (contWidth, itemWidth) {
      that.__size(contWidth, itemWidth); // Add space to pages within context


      if (display != 'inline') {
        $ctx.find('.mbsc-page').css('padding-' + display, elm.offsetHeight + 'px');
      }
    };

    that._onItemTap = function ($item, toggle) {
      if (that.__onItemTap($item, toggle) === false) {
        return false;
      }

      if (toggle === undefined) {
        toggle = !multiple;
      }

      if (select && toggle && !$item.hasClass('mbsc-disabled')) {
        if (multiple) {
          if ($item.attr('data-selected') == 'true') {
            deselectItem($item);
          } else {
            selectItem($item);
          }
        } else {
          deselectItem(that._$items.filter('.mbsc-ms-item-sel'));
          selectItem($item);
        }
      }

      return toggle;
    };

    that._getActiveItem = function ($item) {
      var selected = $item.attr('data-selected') == 'true';

      if (select && !multiple && selected) {
        return $item;
      }
    };

    that._getItemProps = function ($item) {
      var selected = $item.attr('data-selected') == 'true',
          disabled = $item.attr('data-disabled') == 'true',
          icon = $item.attr('data-icon'),
          badge = $item.attr('data-badge');
      $item.attr('data-role', 'button').attr('aria-selected', selected ? 'true' : 'false').attr('aria-disabled', disabled ? 'true' : 'false').find('.mbsc-ms-badge').remove();

      if (badge) {
        $item.append('<span class="mbsc-ms-badge">' + badge + '</span>');
      }

      if (icon) {
        that._hasIcons = true;
      }

      if ($item.text()) {
        that._hasText = true;
      }

      return {
        cssClass: 'mbsc-ms-item ' + (s.itemClass || '') + ' ' + (selected ? selectedClass : '') + (disabled ? ' mbsc-disabled ' + (s.disabledClass || '') : '') + (icon ? ' mbsc-ms-ic mbsc-ic mbsc-ic-' + icon : '')
      };
    };

    that._getContClass = function () {
      return ' mbsc-ms-c mbsc-ms-' + s.variant + ' mbsc-ms-' + display + (select ? '' : ' mbsc-ms-nosel') + (that.__getContClass() || '');
    };

    that.__init = function () {
      that.___init();

      $ctx = $$1(s.context); // Remove old padding from mbsc-page
      // if display changed dynamically

      removePagePadding();
      display = s.display;
      multiple = s.select == 'multiple';
      select = s.select != 'off';
      selectedClass = ' mbsc-ms-item-sel ' + (s.activeClass || '');
      $elm.addClass('mbsc-ms mbsc-ms-base ' + (s.groupClass || ''));
    };

    that.__destroy = function () {
      $elm.removeClass('mbsc-ms mbsc-ms-base ' + (s.groupClass || ''));
      removePagePadding();

      that.___destroy();
    };

    that.__onItemTap = noop;
    that.__getContClass = noop;
    that.__markupReady = noop;
    that.__size = noop;
    that.___init = noop;
    that.___destroy = noop; // ---
    // Constructor

    s = that.settings;

    if (!inherit) {
      that.init();
    }
  }; // Defaults

  NavigationBase.prototype = {
    _defaults: extend$1({}, ScrollView.prototype._defaults)
  };

  var Navigation = function Navigation(elm, settings) {
    var $elm = $$1(elm),
        $menu,
        $popup,
        menuClass,
        s,
        popup,
        isList = $elm.is('ul,ol'),
        that = this; // Call the parent constructor

    NavigationBase.call(this, elm, settings, true);

    that._initMarkup = function () {
      if ($menu) {
        $menu.remove();
      }

      if ($popup) {
        $elm.append($popup.children());
      }
    };

    that.__size = function (contWidth, itemWidth) {
      var showMore,
          showMoreWidth = itemWidth || 72,
          itemsNr = that._$items.length,
          itemsWidth = 0;
      popup.hide(); // show more menu

      if (s.type == 'bottom') {
        $elm.removeClass('mbsc-scv-liq'); //.empty(); // empty list

        $menu.remove();

        that._$items.remove().each(function (i) {
          var $item = $$1(this);
          $elm.append($item);
          itemsWidth += itemWidth || this.offsetWidth || 0; // if next item doesn't fit, add to show more menu

          if (Math.round(itemsWidth + (i < itemsNr - 1 ? showMoreWidth : 0)) > contWidth) {
            showMore = true;
            $popup.append($item.css('width', '').addClass('mbsc-fr-btn-e'));
          }
        });

        $menu.attr('class', menuClass + (s.moreIcon ? ' mbsc-menu-item-ic mbsc-ms-ic mbsc-ic mbsc-ic-' + s.moreIcon : '')).html(that._hasIcons && that._hasText ? s.moreText : ''); // add show more item if needed

        if (showMore) {
          $elm.append($menu);
        }
      }

      if (s.layout == 'liquid') {
        $elm.addClass('mbsc-scv-liq');
      }
    };

    that.__onItemTap = function ($item) {
      if ($item.hasClass('mbsc-menu-item') && that.trigger('onMenuShow', {
        target: $item[0],
        menu: popup
      }) !== false) {
        popup.show(false, true);
        return false;
      }
    };

    that.__getContClass = function () {
      return s.type == 'hamburger' ? ' mbsc-ms-hamburger' : '';
    };

    that.__markupReady = function ($cont) {
      if (s.type == 'hamburger') {
        $popup.append(that._$items.addClass('mbsc-fr-btn-e'));
        $menu.attr('class', menuClass + (s.menuIcon ? ' mbsc-menu-item-ic mbsc-ms-ic mbsc-ic mbsc-ic-' + s.menuIcon : '')).html(s.menuText || '');
        $elm.append($menu);

        if (!s.menuText || !s.menuIcon) {
          $cont.removeClass('mbsc-ms-icons');
        }

        if (!s.menuText) {
          $cont.removeClass('mbsc-ms-txt');
        } else {
          $cont.addClass('mbsc-ms-txt');
        }
      }
    };

    that.___init = function () {
      var $target;

      if (s.type == 'tab') {
        s.display = s.display || 'top';
        s.variant = s.variant || 'b';
      } else if (s.type == 'bottom') {
        s.display = s.display || 'bottom';
        s.variant = s.variant || 'a';
      } else if (s.type == 'hamburger') {
        s.display = s.display || 'inline';
        s.variant = s.variant || 'a';
      }

      menuClass = 'mbsc-scv-item mbsc-ms-item mbsc-btn-e mbsc-menu-item ' + (s.itemClass || '');

      if (!$menu) {
        $menu = $$1(isList ? '<li></li>' : '<div></div>');
        $popup = $$1(isList ? '<ul></ul>' : '<div></div>').addClass('mbsc-scv mbsc-ms');
      }

      popup = new Popup($popup[0], {
        display: 'bubble',
        theme: s.theme,
        lang: s.lang,
        context: s.context,
        buttons: [],
        anchor: $menu,
        onBeforeShow: function onBeforeShow(event, inst) {
          $target = null;
          inst.settings.cssClass = 'mbsc-wdg mbsc-ms-a mbsc-ms-more' + (that._hasText ? '' : ' mbsc-ms-more-icons');
        },
        onBeforeClose: function onBeforeClose() {
          return that.trigger('onMenuHide', {
            target: $target && $target[0],
            menu: popup
          });
        },
        onMarkupReady: function onMarkupReady(event, inst) {
          that.tap(inst._markup.find('.mbsc-fr-c'), function (ev) {
            $target = $$1(ev.target).closest('.mbsc-ms-item');

            if ($target.length && !$target.hasClass('mbsc-disabled')) {
              that.navigate($target, true);
              popup.hide();
            }
          });
        }
      });
    };

    that.___destroy = function () {
      popup.destroy();
      $elm.append(that._$items);
      $menu.remove();
    }; // ---
    // Constructor


    s = that.settings;
    that.init();
  }; // Defaults

  Navigation.prototype = {
    _class: 'navigation',
    _hasDef: true,
    _hasTheme: true,
    _hasLang: true,
    _responsive: true,
    _defaults: extend$1({}, NavigationBase.prototype._defaults, {
      type: 'bottom',
      moreText: 'More',
      moreIcon: 'material-more-horiz',
      menuIcon: 'material-menu'
    })
  };
  classes.Navigation = Navigation;

  var MbscNotifyItemService = (function () {
      function MbscNotifyItemService() {
          this._instanceObservable = new Observable();
          this._addRemoveObservable = new Observable();
          this.inst = null;
      }
      MbscNotifyItemService.prototype.notifyInstanceReady = function (instance) {
          this.inst = instance;
          this._instanceObservable.next(instance);
      };
      MbscNotifyItemService.prototype.notifyAddRemove = function (item) {
          this._addRemoveObservable.next(item);
      };
      MbscNotifyItemService.prototype.onInstanceReady = function () {
          return this._instanceObservable;
      };
      MbscNotifyItemService.prototype.onAddRemove = function () {
          return this._addRemoveObservable;
      };
      MbscNotifyItemService.decorators = [
          { type: core.Injectable },
      ];
      MbscNotifyItemService.ctorParameters = function () { return []; };
      return MbscNotifyItemService;
  }());
  var MbscScrollItemBase = (function () {
      function MbscScrollItemBase(notifyItemService, _elem) {
          var _this = this;
          this.notifyItemService = notifyItemService;
          this._elem = _elem;
          this._instance = undefined;
          this.instanceObserver = this.notifyItemService.onInstanceReady().subscribe(function (instance) {
              _this._instance = instance;
          });
          if (notifyItemService.inst) {
              this._instance = notifyItemService.inst;
          }
      }
      Object.defineProperty(MbscScrollItemBase.prototype, "nativeElement", {
          get: function () {
              return this._elem.nativeElement;
          },
          enumerable: true,
          configurable: true
      });
      MbscScrollItemBase.prototype.ngAfterViewInit = function () {
          this.notifyItemService.notifyAddRemove(this);
      };
      MbscScrollItemBase.prototype.ngOnDestroy = function () {
          this.notifyItemService.onInstanceReady().unsubscribe(this.instanceObserver);
          this.notifyItemService.notifyAddRemove(this);
      };
      MbscScrollItemBase.decorators = [
          { type: core.Directive, args: [{ selector: '[mbsc-si-b' },] },
      ];
      MbscScrollItemBase.ctorParameters = function () { return [
          { type: MbscNotifyItemService, },
          { type: core.ElementRef, },
      ]; };
      MbscScrollItemBase.propDecorators = {
          'id': [{ type: core.Input },],
      };
      return MbscScrollItemBase;
  }());
  var MbscScrollViewBase = (function (_super) {
      __extends(MbscScrollViewBase, _super);
      function MbscScrollViewBase(initialElem, zone, notifyItemService) {
          var _this = _super.call(this, initialElem, zone) || this;
          _this.notifyItemService = notifyItemService;
          _this.onItemTap = new core.EventEmitter();
          _this.onMarkupReady = new core.EventEmitter();
          _this.onAnimationStart = new core.EventEmitter();
          _this.onAnimationEnd = new core.EventEmitter();
          _this.onMove = new core.EventEmitter();
          _this.onGestureStart = new core.EventEmitter();
          _this.onGestureEnd = new core.EventEmitter();
          return _this;
      }
      MbscScrollViewBase.decorators = [
          { type: core.Directive, args: [{ selector: '[mbsc-s-b' },] },
      ];
      MbscScrollViewBase.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: MbscNotifyItemService, },
      ]; };
      MbscScrollViewBase.propDecorators = {
          'context': [{ type: core.Input },],
          'itemWidth': [{ type: core.Input },],
          'layout': [{ type: core.Input },],
          'mousewheel': [{ type: core.Input },],
          'snap': [{ type: core.Input },],
          'threshold': [{ type: core.Input },],
          'paging': [{ type: core.Input },],
          'onItemTap': [{ type: core.Output },],
          'onMarkupReady': [{ type: core.Output },],
          'onAnimationStart': [{ type: core.Output },],
          'onAnimationEnd': [{ type: core.Output },],
          'onMove': [{ type: core.Output },],
          'onGestureStart': [{ type: core.Output },],
          'onGestureEnd': [{ type: core.Output },],
      };
      return MbscScrollViewBase;
  }(MbscBase));
  var MbscScrollViewBaseModule = (function () {
      function MbscScrollViewBaseModule() {
      }
      MbscScrollViewBaseModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule, MbscBaseModule],
                      declarations: [MbscScrollItemBase, MbscScrollViewBase],
                  },] },
      ];
      MbscScrollViewBaseModule.ctorParameters = function () { return []; };
      return MbscScrollViewBaseModule;
  }());

  var MbscNavItemBase = (function (_super) {
      __extends(MbscNavItemBase, _super);
      function MbscNavItemBase(notifyItemService, elem) {
          var _this = _super.call(this, notifyItemService, elem) || this;
          _this.selectedChange = new core.EventEmitter();
          return _this;
      }
      Object.defineProperty(MbscNavItemBase.prototype, "disabled", {
          get: function () {
              return this._disabled;
          },
          set: function (v) {
              this._disabled = v;
              if (this._instance) {
                  if (this._disabled) {
                      this._instance.disable(this._elem.nativeElement);
                  }
                  else {
                      this._instance.enable(this._elem.nativeElement);
                  }
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MbscNavItemBase.prototype, "selected", {
          get: function () {
              return this._selected;
          },
          set: function (v) {
              this._selected = v;
              if (this._instance) {
                  if (this._selected) {
                      this._instance.select(this._elem.nativeElement);
                  }
                  else {
                      this._instance.deselect(this._elem.nativeElement);
                  }
              }
          },
          enumerable: true,
          configurable: true
      });
      MbscNavItemBase.prototype.toggle = function () {
          this._selected = !this._selected;
          this.selectedChange.emit(this._selected);
      };
      MbscNavItemBase.decorators = [
          { type: core.Directive, args: [{ selector: '[mbsc-ni-b' },] },
      ];
      MbscNavItemBase.ctorParameters = function () { return [
          { type: MbscNotifyItemService, },
          { type: core.ElementRef, },
      ]; };
      MbscNavItemBase.propDecorators = {
          'icon': [{ type: core.Input },],
          'disabled': [{ type: core.Input },],
          'selected': [{ type: core.Input },],
          'selectedChange': [{ type: core.Output },],
      };
      return MbscNavItemBase;
  }(MbscScrollItemBase));
  var MbscNavigationBase = (function (_super) {
      __extends(MbscNavigationBase, _super);
      function MbscNavigationBase(initialElem, zone, notifyItemService) {
          return _super.call(this, initialElem, zone, notifyItemService) || this;
      }
      MbscNavigationBase.prototype.tapHandler = function (event, inst) {
          var selection = this.select || (inst && inst.settings.select);
          switch (selection) {
              case 'multiple': {
                  var item = this._getItem(event.target);
                  item.toggle();
                  break;
              }
              case 'single': {
                  var item = this._getItem(event.target);
                  if (item && !item.selected) {
                      this.items.forEach(function (item) {
                          if (item.selected) {
                              item.toggle();
                          }
                      });
                      item.toggle();
                  }
              }
          }
          event.inst = inst;
          this.onItemTap.emit(event);
      };
      MbscNavigationBase.prototype._getItem = function (nativeEl) {
          return this.items.find(function (item) {
              return item.nativeElement === nativeEl;
          });
      };
      MbscNavigationBase.decorators = [
          { type: core.Directive, args: [{ selector: '[mbsc-n-b' },] },
      ];
      MbscNavigationBase.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: MbscNotifyItemService, },
      ]; };
      MbscNavigationBase.propDecorators = {
          'display': [{ type: core.Input },],
          'options': [{ type: core.Input, args: ['options',] },],
          'items': [{ type: core.ContentChildren, args: [MbscNavItemBase,] },],
      };
      return MbscNavigationBase;
  }(MbscScrollViewBase));
  var MbscNavigationBaseModule = (function () {
      function MbscNavigationBaseModule() {
      }
      MbscNavigationBaseModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule, MbscScrollViewBaseModule],
                      declarations: [MbscNavigationBase, MbscNavItemBase],
                  },] },
      ];
      MbscNavigationBaseModule.ctorParameters = function () { return []; };
      return MbscNavigationBaseModule;
  }());

  var MbscNavItem = (function (_super) {
      __extends(MbscNavItem, _super);
      function MbscNavItem(notifyItemService, elem, inj, routerToken) {
          var _this = _super.call(this, notifyItemService, elem) || this;
          _this.inj = inj;
          _this.routerLinkActiveOptions = { exact: false };
          _this.instObserver = notifyItemService.onInstanceReady().subscribe(function (instance) {
              if (_this.initialBadge) {
                  instance.setBadge(_this.nativeElement, _this.initialBadge);
              }
          });
          if (routerToken) {
              _this.injectedRouter = routerToken;
              _this.activatedRoute = _this.inj.get(_this.injectedRouter.routerState.root.__proto__.constructor, null);
          }
          if (_this.injectedRouter) {
              _this.injectedRouter.events.subscribe(function (ev) {
                  clearTimeout(_this.debounceHandler);
                  _this.debounceHandler = setTimeout(function () {
                      _this.checkSelected();
                  });
              });
          }
          return _this;
      }
      Object.defineProperty(MbscNavItem.prototype, "badge", {
          set: function (badge) {
              if (this._instance) {
                  this._instance.setBadge(this.nativeElement, badge);
              }
              else {
                  this.initialBadge = badge;
              }
          },
          enumerable: true,
          configurable: true
      });
      MbscNavItem.prototype.checkSelected = function () {
          if (this.injectedRouter && this.routerLink !== null && this.routerLink !== undefined) {
              var commands = Array.isArray(this.routerLink) ? this.routerLink : [this.routerLink];
              var urlTree = this.injectedRouter.createUrlTree(commands, { relativeTo: this.activatedRoute });
              var selected = this.injectedRouter.isActive(urlTree, this.routerLinkActiveOptions.exact);
              if (selected) {
                  this._selected = selected;
              }
              if (this._instance) {
                  if (selected) {
                      this._instance.select(this._elem.nativeElement);
                  }
                  else {
                      this._instance.deselect(this._elem.nativeElement);
                  }
              }
          }
      };
      MbscNavItem.prototype.ngOnDestroy = function () {
          this.notifyItemService.onInstanceReady().unsubscribe(this.instObserver);
          _super.prototype.ngOnDestroy.call(this);
      };
      MbscNavItem.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-nav-item',
                      template: '<ng-content></ng-content>',
                      host: {
                          '[attr.data-icon]': 'icon',
                          '[attr.data-disabled]': 'disabled',
                          '[attr.data-selected]': 'selected',
                          '[attr.data-id]': 'id'
                      }
                  },] },
      ];
      MbscNavItem.ctorParameters = function () { return [
          { type: MbscNotifyItemService, },
          { type: core.ElementRef, },
          { type: core.Injector, },
          { type: MbscRouterToken, decorators: [{ type: core.Optional },] },
      ]; };
      MbscNavItem.propDecorators = {
          'badge': [{ type: core.Input },],
          'routerLink': [{ type: core.Input },],
          'routerLinkActiveOptions': [{ type: core.Input },],
      };
      return MbscNavItem;
  }(MbscNavItemBase));
  var MbscNav = (function (_super) {
      __extends(MbscNav, _super);
      function MbscNav(initialElem, zone, notifyItemService, optionService) {
          var _this = _super.call(this, initialElem, zone, notifyItemService) || this;
          _this.optionService = optionService;
          _this.select = 'single';
          _this.onMenuHide = new core.EventEmitter();
          _this.onMenuShow = new core.EventEmitter();
          return _this;
      }
      MbscNav.prototype.initControl = function () {
          var _this = this;
          var onItemTap = this.tapHandler.bind(this);
          var onItemTapUser = this.options && this.options.onItemTap;
          if (onItemTapUser) {
              onItemTap = function (event, inst) {
                  _this.tapHandler(event, inst);
                  return onItemTapUser(event, inst);
              };
          }
          var options = extend$1({ type: this.type }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, { onItemTap: onItemTap });
          this.instance = new Navigation(this.initialElem.nativeElement, options);
          this.notifyItemService.notifyInstanceReady(this.instance);
          this.addRemoveObserver = this.notifyItemService.onAddRemove().subscribe(function (item) {
              _this.instance.refresh();
          });
      };
      MbscNav.prototype.ngOnDestroy = function () {
          this.notifyItemService.onAddRemove().unsubscribe(this.addRemoveObserver);
          _super.prototype.ngOnDestroy.call(this);
      };
      MbscNav.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-nav',
                      template: '<ng-content></ng-content>',
                      providers: [MbscNotifyItemService],
                      exportAs: 'mobiscroll',
                      host: { 'class': 'mbsc-cloak' }
                  },] },
      ];
      MbscNav.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: MbscNotifyItemService, },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscNav.propDecorators = {
          'moreText': [{ type: core.Input },],
          'moreIcon': [{ type: core.Input },],
          'menuText': [{ type: core.Input },],
          'menuIcon': [{ type: core.Input },],
          'onMenuHide': [{ type: core.Output },],
          'onMenuShow': [{ type: core.Output },],
          'items': [{ type: core.ContentChildren, args: [MbscNavItem,] },],
      };
      return MbscNav;
  }(MbscNavigationBase));
  var MbscBottomNav = (function (_super) {
      __extends(MbscBottomNav, _super);
      function MbscBottomNav(initialElem, zone, navItemService, optionService) {
          var _this = _super.call(this, initialElem, zone, navItemService, optionService) || this;
          _this.type = 'bottom';
          return _this;
      }
      MbscBottomNav.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-bottom-nav',
                      template: '<ng-content></ng-content>',
                      providers: [MbscNotifyItemService],
                      exportAs: 'mobiscroll',
                      host: { 'class': 'mbsc-cloak' }
                  },] },
      ];
      MbscBottomNav.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: MbscNotifyItemService, },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      return MbscBottomNav;
  }(MbscNav));
  var MbscHamburgerNav = (function (_super) {
      __extends(MbscHamburgerNav, _super);
      function MbscHamburgerNav(initialElem, zone, navItemService, optionService) {
          var _this = _super.call(this, initialElem, zone, navItemService, optionService) || this;
          _this.type = 'hamburger';
          return _this;
      }
      MbscHamburgerNav.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-hamburger-nav',
                      template: '<ng-content></ng-content>',
                      providers: [MbscNotifyItemService],
                      exportAs: 'mobiscroll',
                      host: { 'class': 'mbsc-cloak' }
                  },] },
      ];
      MbscHamburgerNav.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: MbscNotifyItemService, },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      return MbscHamburgerNav;
  }(MbscNav));
  var MbscTabNav = (function (_super) {
      __extends(MbscTabNav, _super);
      function MbscTabNav(initialElem, zone, navItemService, optionService) {
          var _this = _super.call(this, initialElem, zone, navItemService, optionService) || this;
          _this.type = 'tab';
          return _this;
      }
      MbscTabNav.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-tab-nav',
                      template: '<ng-content></ng-content>',
                      providers: [MbscNotifyItemService],
                      exportAs: 'mobiscroll',
                      host: { 'class': 'mbsc-cloak' }
                  },] },
      ];
      MbscTabNav.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: MbscNotifyItemService, },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      return MbscTabNav;
  }(MbscNav));
  var comps = [
      MbscNavItem,
      MbscNav,
      MbscBottomNav,
      MbscHamburgerNav,
      MbscTabNav
  ];
  var MbscNavigationModule = (function () {
      function MbscNavigationModule() {
      }
      MbscNavigationModule.forRoot = function (config) {
          return {
              ngModule: MbscNavigationModule,
              providers: [{
                      provide: MbscRouterToken,
                      useExisting: config.angularRouter
                  }]
          };
      };
      MbscNavigationModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule, MbscNavigationBaseModule],
                      declarations: comps,
                      exports: comps
                  },] },
      ];
      MbscNavigationModule.ctorParameters = function () { return []; };
      return MbscNavigationModule;
  }());

  var NumberScroller = Measurement;
  presets.number = presets.measurement;

  var MbscNumber = (function (_super) {
      __extends(MbscNumber, _super);
      function MbscNumber(initialElem, zone, control, inputService, optionService, view) {
          var _this = _super.call(this, initialElem, zone, control, inputService, view) || this;
          _this.optionService = optionService;
          _this.options = {};
          _this.onChangeEmitter = new core.EventEmitter();
          return _this;
      }
      Object.defineProperty(MbscNumber.prototype, "value", {
          set: function (v) {
              if (!this.control) {
                  this.setNewValueProxy(v);
              }
          },
          enumerable: true,
          configurable: true
      });
      MbscNumber.prototype.setNewValue = function (v) {
          if (this.instance) {
              var innerValue = this.instance.getVal();
              if (innerValue !== v) {
                  this.instance.setVal(v, true, false);
                  if (this._inputService && this._inputService.input) {
                      this._inputService.input.innerValue = this.instance._value;
                  }
              }
          }
      };
      MbscNumber.prototype.initControl = function () {
          var options = extend$1({ preset: 'number' }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
          this.instance = new NumberScroller(this.element, options);
          if (this.initialValue !== undefined) {
              this.instance.setVal(this.initialValue, true, false);
          }
      };
      MbscNumber.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mbsc-number]',
                      exportAs: 'mobiscroll'
                  },] },
      ];
      MbscNumber.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: core.ViewContainerRef, },
      ]; };
      MbscNumber.propDecorators = {
          'decimalSeparator': [{ type: core.Input },],
          'defaultValue': [{ type: core.Input },],
          'invalid': [{ type: core.Input },],
          'max': [{ type: core.Input },],
          'min': [{ type: core.Input },],
          'scale': [{ type: core.Input },],
          'step': [{ type: core.Input },],
          'wholeText': [{ type: core.Input },],
          'fractionText': [{ type: core.Input },],
          'signText': [{ type: core.Input },],
          'options': [{ type: core.Input, args: ['mbsc-options',] },],
          'value': [{ type: core.Input, args: ['mbsc-number',] },],
          'onChangeEmitter': [{ type: core.Output, args: ['mbsc-numberChange',] },],
      };
      return MbscNumber;
  }(MbscScrollerBase));
  var MbscNumberComponent = (function (_super) {
      __extends(MbscNumberComponent, _super);
      function MbscNumberComponent(initialElem, zone, control, inputService, optionService) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
          _this.errorMessage = '';
          _this.placeholder = '';
          return _this;
      }
      MbscNumberComponent.prototype.ngAfterViewInit = function () {
          _super.prototype.ngAfterViewInit.call(this);
          this.setThemeClasses();
      };
      MbscNumberComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-number',
                      exportAs: 'mobiscroll',
                      template: INPUT_TEMPLATE
                  },] },
      ];
      MbscNumberComponent.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscNumberComponent.propDecorators = {
          'inputIcon': [{ type: core.Input, args: ['icon',] },],
          'iconAlign': [{ type: core.Input, args: ['icon-align',] },],
          'name': [{ type: core.Input },],
          'error': [{ type: core.Input },],
          'errorMessage': [{ type: core.Input },],
          'options': [{ type: core.Input },],
          'placeholder': [{ type: core.Input },],
      };
      return MbscNumberComponent;
  }(MbscNumber));
  var MbscNumberModule = (function () {
      function MbscNumberModule() {
      }
      MbscNumberModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule, MbscScrollerBaseModule, MbscInputModule],
                      declarations: [MbscNumber, MbscNumberComponent],
                      exports: [MbscNumber, MbscNumberComponent]
                  },] },
      ];
      MbscNumberModule.ctorParameters = function () { return []; };
      return MbscNumberModule;
  }());

  var presets$1 = {};
  var Numpad = function Numpad(el, settings, inherit) {
    var $markup,
        deleteBtn,
        disabledClass,
        ph,
        pos,
        s,
        mask,
        sX,
        sY,
        eX,
        eY,
        diffX,
        diffY,
        action,
        interval,
        tempValueArray,
        tempTotal,
        trigger,
        total,
        valueArray,
        $elm = $$1(el),
        that = this,
        actions = [],
        tempActions = [],
        tempVariables = {},
        variables = {},
        customKeys = {},
        numericKeys = {
      48: 0,
      49: 1,
      50: 2,
      51: 3,
      52: 4,
      53: 5,
      54: 6,
      55: 7,
      56: 8,
      57: 9,
      96: 0,
      97: 1,
      98: 2,
      99: 3,
      100: 4,
      101: 5,
      102: 6,
      103: 7,
      104: 8,
      105: 9
    };

    function display(manual) {
      // Validate
      var i,
          ret = s.validate.call(el, {
        values: tempValueArray.slice(0),
        variables: tempVariables
      }, that) || [],
          disabled = ret && ret.disabled || [];
      that._isValid = ret.invalid ? false : true; // Generate formatted value

      that._tempValue = s.formatValue.call(el, tempValueArray.slice(0), tempVariables, that);
      pos = tempValueArray.length;
      tempTotal = ret.length || total;

      if (that._isVisible && mobiscroll.owfBP) {
        // Fill template with numbers
        $$1('.mbsc-np-ph', $markup).each(function (i) {
          $$1(this).html(s.fill == 'ltr' ? i >= pos ? ph : mask || tempValueArray[i] : i >= total - tempTotal ? i + pos < total ? ph : mask || tempValueArray[i + pos - total] : '');
        }); // Fill variable placeholders

        $$1('.mbsc-np-cph', $markup).each(function () {
          $$1(this).html(tempVariables[$$1(this).attr('data-var')] || $$1(this).attr('data-ph'));
        }); // Disable all numeric buttons if template is full

        if (pos === total) {
          for (i = 0; i <= 9; i++) {
            disabled.push(i);
          }
        } // Disable invalid buttons


        $$1('.mbsc-np-btn', $markup).removeClass(disabledClass);

        for (i = 0; i < disabled.length; i++) {
          $$1('.mbsc-np-btn[data-val="' + disabled[i] + '"]', $markup).addClass(disabledClass);
        } // Disable set button


        if (that._isValid) {
          $$1('.mbsc-fr-btn-s .mbsc-fr-btn', $markup).removeClass(disabledClass);
        } else {
          $$1('.mbsc-fr-btn-s .mbsc-fr-btn', $markup).addClass(disabledClass);
        } // Fill input if in live mode


        if (that.live) {
          that._hasValue = manual || that._hasValue;
          fillValue(manual, false, manual);

          if (manual) {
            trigger('onSet', {
              valueText: that._value
            });
          }
        }
      }
    }

    function fillValue(fill, disp, change, temp) {
      if (disp) {
        display();
      }

      if (!temp) {
        valueArray = tempValueArray.slice(0);
        variables = extend$1({}, tempVariables);
        actions = tempActions.slice(0);
        that._value = that._hasValue ? that._tempValue : null;
      }

      if (fill) {
        if (that._isInput) {
          $elm.val(that._hasValue && that._isValid ? that._value : '');
        }

        trigger('onFill', {
          valueText: that._hasValue ? that._tempValue : '',
          change: change
        });

        if (change) {
          that._preventChange = true;
          $elm.trigger('change');
        }
      }
    }

    function loadValues(values) {
      var i,
          vars,
          val = values || [],
          ret = [];
      tempActions = [];
      tempVariables = {};

      for (i = 0; i < val.length; i++) {
        //if (isNaN(parseInt(val[i]))) {
        if (/:/.test(val[i])) {
          vars = val[i].split(':');
          tempVariables[vars[0]] = vars[1];
          tempActions.push(vars[0]);
        } else {
          ret.push(val[i]);
          tempActions.push('digit');
        }
      }

      return ret;
    }

    function triggerInput(btn, ev) {
      trigger('onInput', {
        domEvent: ev,
        target: btn,
        values: tempValueArray.slice(0),
        valueText: that._tempValue,
        variables: tempVariables
      });
    }

    function addKeys(keys, pos) {
      if (keys) {
        keys = $$1.isArray(keys) ? keys : [keys];
        keys.forEach(function (key) {
          customKeys[key] = pos;
        });
      }
    }

    function onNumberTap(btn, val, ev) {
      if (!pos && !val && !s.allowLeadingZero || btn.hasClass('mbsc-disabled') || btn.hasClass('mbsc-np-btn-empty')) {
        return;
      }

      if (pos < total && mobiscroll.owfBP) {
        tempActions.push('digit');
        tempValueArray.push(val);
        display(true);
        triggerInput(btn[0], ev);
      }
    }

    function onCustomTap(btn, ev) {
      var i,
          v,
          val = btn.attr('data-val'),
          track = btn.attr('data-track') !== 'false',
          variable = btn.attr('data-var');

      if (!btn.hasClass('mbsc-disabled')) {
        if (variable) {
          v = variable.split(':');

          if (track) {
            tempActions.push(v[0]);
          }

          tempVariables[v[0]] = v[2] === undefined ? v[1] : tempVariables[v[0]] == v[1] ? v[2] : v[1];
        }

        if (val.length + pos <= tempTotal) {
          for (i = 0; i < val.length; ++i) {
            v = isNumeric(val[i]) ? +val[i] : val[i];

            if (s.allowLeadingZero || pos || v) {
              tempActions.push('digit');
              tempValueArray.push(v);
              pos = tempValueArray.length;
            }
          }
        }

        display(true);
        triggerInput(btn[0], ev);
      }
    }

    function onDeleteTap(ev) {
      var i,
          old,
          act = tempActions.pop();

      if (pos || act !== 'digit') {
        if (act !== 'digit' && tempVariables[act]) {
          delete tempVariables[act];
          old = tempActions.slice(0);
          tempActions = [];

          for (i = 0; i < old.length; i++) {
            if (old[i] !== act) {
              tempActions.push(old[i]);
            }
          }
        } else {
          tempValueArray.pop();
        }

        display(true);
        triggerInput(deleteBtn, ev);
      }
    }

    function startDelete(ev) {
      action = true;
      sX = getCoord(ev, 'X');
      sY = getCoord(ev, 'Y');
      clearInterval(interval);
      clearTimeout(interval);
      onDeleteTap(ev);
      interval = setInterval(function () {
        onDeleteTap(ev);
      }, 150);
    }

    function stopDelete() {
      clearInterval(interval);
      action = false;
    }

    function onStart(ev) {
      if (testTouch(ev, this)) {
        if (ev.type == 'keydown' && ev.keyCode != 32) {
          return;
        }

        startDelete(ev);

        if (ev.type == 'mousedown') {
          $$1(document).on('mousemove', onMove).on('mouseup', onEnd);
        }
      }
    }

    function onMove(ev) {
      if (action) {
        eX = getCoord(ev, 'X');
        eY = getCoord(ev, 'Y');
        diffX = eX - sX;
        diffY = eY - sY;

        if (Math.abs(diffX) > 7 || Math.abs(diffY) > 7) {
          stopDelete();
        }
      }
    }

    function onEnd(ev) {
      if (action) {
        ev.preventDefault();
        stopDelete();

        if (ev.type == 'mouseup') {
          $$1(document).off('mousemove', onMove).off('mouseup', onEnd);
        }
      }
    } // Call the parent constructor


    Frame.call(this, el, settings, true); // Public functions

    /**
     * Sets the value
     */

    that.setVal = that._setVal = function (val, fill, change, temp) {
      that._hasValue = val !== null && val !== undefined && val !== '';
      tempValueArray = loadValues($$1.isArray(val) ? val.slice(0) : s.parseValue.call(el, val, that));
      fillValue(fill, true, change === undefined ? fill : change, temp);
    };
    /**
     * Returns the selected value
     */


    that.getVal = that._getVal = function (temp) {
      return that._hasValue || temp ? that[temp ? '_tempValue' : '_value'] : null;
    };
    /*
     * Sets the value (passed as an array)
     */


    that.setArrayVal = that.setVal;
    /*
     * Returns the selected wheel values as an array
     */

    that.getArrayVal = function (temp) {
      return temp ? tempValueArray.slice(0) : that._hasValue ? valueArray.slice(0) : null;
    }; // Protected overrides


    that._readValue = function () {
      var v = $elm.val() || '';

      if (v !== '') {
        that._hasValue = true;
      }

      if (mask) {
        tempVariables = {};
        tempActions = [];
        tempValueArray = [];
      } else {
        tempVariables = that._hasValue ? variables : {};
        tempActions = that._hasValue ? actions : [];
        tempValueArray = that._hasValue && valueArray ? valueArray.slice(0) : loadValues(s.parseValue.call(el, v, that));
        fillValue(false, true);
      }
    };

    that._fillValue = function () {
      that._hasValue = true;
      fillValue(true, false, true);
    };

    that._generateContent = function () {
      var i,
          j,
          v,
          k = 1,
          leftKey = s.leftKey,
          rightKey = s.rightKey,
          template = '',
          html = ''; // Display

      html += '<div class="mbsc-np-hdr"><div role="button" tabindex="0" aria-label="' + s.deleteText + '" class="mbsc-np-del mbsc-fr-btn-e mbsc-ic mbsc-ic-' + s.deleteIcon + '"></div><div class="mbsc-np-dsp">'; // Process template

      template = s.template.replace(/d/g, '<span class="mbsc-np-ph">' + ph + '</span>').replace(/&#100;/g, 'd'); // Generate the template for custom buttons

      template = template.replace(/{([a-zA-Z0-9]*):?([a-zA-Z0-9\-_]*)}/g, '<span class="mbsc-np-cph" data-var="$1" data-ph="$2">$2</span>');
      html += template;
      html += '</div></div>'; // Digit buttons

      html += '<div class="mbsc-np-tbl-c mbsc-w-p"><div class="mbsc-np-tbl">';

      for (i = 0; i < 4; i++) {
        html += '<div class="mbsc-np-row">';

        for (j = 0; j < 3; j++) {
          v = k;

          if (k == 10 || k == 12) {
            v = '';
          } else if (k == 11) {
            v = 0;
          }

          if (v === '') {
            if (k == 10 && leftKey) {
              addKeys(leftKey.keys, 'left');
              html += '<div role="button" tabindex="0" class="mbsc-np-btn mbsc-np-btn-custom mbsc-np-btn-custom-left mbsc-fr-btn-e" ' + (leftKey.variable ? 'data-var="' + leftKey.variable + '"' : '') + ' data-val="' + (leftKey.value || '') + '" ' + (leftKey.track !== undefined ? ' data-track="' + leftKey.track + '"' : '') + '>' + leftKey.text + '</div>';
            } else if (k == 12 && s.rightKey) {
              addKeys(rightKey.keys, 'right');
              html += '<div role="button" tabindex="0" class="mbsc-np-btn mbsc-np-btn-custom mbsc-np-btn-custom-right mbsc-fr-btn-e" ' + (rightKey.variable ? 'data-var="' + rightKey.variable + '"' : '') + ' data-val="' + (rightKey.value || '') + '" ' + (rightKey.track !== undefined ? ' data-track="' + rightKey.track + '"' : '') + ' >' + rightKey.text + '</div>';
            } else {
              html += '<div class="mbsc-np-btn mbsc-np-btn-empty"></div>';
            }
          } else {
            html += '<div tabindex="0" role="button" class="mbsc-np-btn mbsc-fr-btn-e" data-val="' + v + '">' + v + that._getText(mobiscroll, 0.2) + '</div>';
          }

          k++;
        }

        html += '</div>';
      }

      html += '</div></div>';
      return html;
    };

    that._markupReady = function () {
      $markup = that._markup;
      display();
    };

    that._attachEvents = function ($m) {
      $m.on('keydown', function (ev) {
        var btn,
            key = ev.keyCode;

        if (customKeys[key] !== undefined) {
          btn = $$1('.mbsc-np-btn-custom-' + customKeys[key], $m);

          if (btn.length) {
            if (btn.attr('data-var') === 'sign:-:') {
              tempVariables.sign = key === 107 || key === 187 ? '-' : '';
            }

            onCustomTap(btn, ev);
          }
        } else if (numericKeys[key] !== undefined) {
          onNumberTap($$1('.mbsc-np-btn[data-val="' + numericKeys[key] + '"]', $m), numericKeys[key], ev);
        } else if (key == 8) {
          ev.preventDefault();
          onDeleteTap(ev);
        }
      });
      that.tap($$1('.mbsc-np-btn', $m), function (ev) {
        var btn = $$1(this);

        if (btn.hasClass('mbsc-np-btn-custom')) {
          onCustomTap(btn, ev);
        } else {
          onNumberTap(btn, +btn.attr('data-val'), ev);
        }
      }, false, 30, true);
      deleteBtn = $$1('.mbsc-np-del', $m)[0];
      listen(deleteBtn, 'touchstart', onStart, {
        passive: true
      });
      listen(deleteBtn, 'mousedown', onStart);
      listen(deleteBtn, 'keydown', onStart);
      listen(deleteBtn, 'touchmove', onMove, {
        passive: true
      });
      listen(deleteBtn, 'mousemove', onMove);
      listen(deleteBtn, 'touchend', onEnd);
      listen(deleteBtn, 'mouseup', onEnd);
      listen(deleteBtn, 'keyup', onEnd);
    };

    that.__init = function () {
      s = that.settings;
      s.template = s.template.replace(/\\d/, '&#100;');
      ph = s.placeholder;
      total = (s.template.match(/d/g) || []).length;
      disabledClass = 'mbsc-disabled ' + (s.disabledClass || '');
      mask = s.mask;
      trigger = that.trigger;

      if (mask && $elm.is('input')) {
        $elm.attr('type', 'password');
      }
    };

    that._indexOf = function (cont, v) {
      var i;

      for (i = 0; i < cont.length; ++i) {
        if (cont[i].toString() === v.toString()) {
          return i;
        }
      }

      return -1;
    }; // Constructor


    if (!inherit) {
      that.init();
    }
  }; // Extend defaults

  Numpad.prototype = {
    _hasDef: true,
    _hasTheme: true,
    _hasLang: true,
    _responsive: true,
    _class: 'numpad',
    _presets: presets$1,
    _defaults: extend$1({}, Frame.prototype._defaults, {
      template: 'dd.dd',
      placeholder: '0',
      deleteIcon: 'backspace',
      allowLeadingZero: false,
      headerText: false,
      fill: 'rtl',
      compClass: 'mbsc-np',
      // Localization
      deleteText: 'Delete',
      decimalSeparator: '.',
      thousandsSeparator: ',',
      // @todo
      // ---
      //fillFullTemplate: true,
      // ---
      validate: noop,
      parseValue: noop,
      formatValue: function formatValue(value, variables, inst) {
        var i,
            j = 1,
            s = inst.settings,
            ph = s.placeholder,
            template = s.template,
            valueLen = value.length,
            tempLen = template.length,
            res = '';

        for (i = 0; i < tempLen; i++) {
          if (template[tempLen - i - 1] == 'd') {
            if (j <= valueLen) {
              res = value[valueLen - j] + res;
            } else {
              res = ph + res;
            }

            j++;
          } else {
            res = template[tempLen - i - 1] + res;
          }
        }

        $$1.each(variables, function (i, v) {
          res = res.replace('{' + i + '}', v);
        });
        return $$1('<div>' + res + '</div>').text();
      }
    })
  };
  classes.Numpad = Numpad;
  mobiscroll.themes.numpad = mobiscroll.themes.frame; // Decimal preset
  // ---

  var decimalDefaults = {
    entryMode: 'template',
    min: 0,
    max: 99.99,
    maxScale: 4,
    prefix: '',
    suffix: '',
    returnAffix: false
  };

  presets$1.decimal = function (inst) {
    var orig = extend$1({}, inst.settings),
        conditionalDefaults = {
      scale: orig.entryMode == 'freeform' ? undefined : 2
    },
        s = extend$1(inst.settings, decimalDefaults, conditionalDefaults, orig),
        scale = s.scale,
        min = +s.min.toFixed(scale),
        max = +s.max.toFixed(scale),
        negativeNum = min < 0,
        thousandRegex = new RegExp(s.thousandsSeparator, 'g'),
        maxIntLength = (Math.floor(Math.max(max, Math.abs(min))) + '').length + 1,
        freeEntry = s.entryMode == 'freeform';
    /**
     * Returns the number from the digits
     * @param {Array} digitArray
     * @param {boolean} isNegative
     */

    function getNumber(digitArray, isNegative) {
      if (!digitArray.length) {
        return null;
      }

      var ret = +digitArray.map(function (v, i) {
        return (i === 0 && v === '.' ? '0' : '') + v;
      }).join(''); // in the case of NOT the freeEntry mode, the decimal point wont be part of the digits array
      // in that case the value will need to be adjusted to the right scale

      if (!freeEntry) {
        for (var i = 0; i < scale; i++) {
          ret /= 10;
        }
      }

      return isNegative ? ret * -1 : ret;
    }
    /**
     * Returns the formatted value from the array of digits
     * @param {Array} digitArray
     */


    function getFormatted(digitArray, forInput) {
      var numberStr = '';

      if (freeEntry && (scale === undefined || !forInput)) {
        if (digitArray[0] === '.') {
          // add missing leading zero when only the decimal point is pressed
          numberStr += '0';
        }

        numberStr += digitArray.join('');
      } else {
        var nr = getNumber(digitArray);

        if (forInput && freeEntry) {
          numberStr = nr === null ? '' : nr.toFixed(scale);
        } else {
          numberStr = (nr === null ? 0 : nr).toFixed(scale);
        }
      } // split the value by the decimal separator to add thousand separators to the integer part


      var parts = numberStr.split('.'),
          integer = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, s.thousandsSeparator),
          dec = parts[1] ? s.decimalSeparator + parts[1] : ''; // when decimal separator also needed when there is no decimal part in free entry mode
      // because this function also used for the displayed number on the numpad, not only for the input

      if (parts[1] !== undefined && !parts[1].length && freeEntry) {
        dec = s.decimalSeparator;
      }

      return integer + dec;
    } // Extended methods
    // ---


    inst.setVal = function (val, fill, change, temp) {
      if (val || val === 0) {
        if (typeof val === 'string') {
          val = +val.replace(s.thousandsSeparator, '').replace(s.decimalSeparator, '.');
        }

        val = constrain(val, min, max);
      }

      return inst._setVal(val, fill, change, temp);
    };

    inst.getVal = function (temp) {
      var val = inst._getVal(temp),
          valNr = (val + '').replace(thousandRegex, '').replace(s.decimalSeparator, '.');

      return isNumeric(valNr) ? +valNr : val;
    }; // ---


    var numberTemplate = Array(maxIntLength).join('d'); // in the case of freeEntry, the decimal point should not be part of the template

    if (freeEntry) {
      if (scale !== undefined) {
        // +2 index required:
        // - 1 for the decimal point
        // - 1 for the join method, since the "d"s will be the separators (and there's one separator less than value)
        numberTemplate += scale ? Array(scale + 2).join('d') : '';
      } else {
        numberTemplate += Array(s.maxScale + 2).join('d');
      }
    } else {
      // +1 required for the join method, since the "d"s will be the separators (and there's one separator less than value)
      numberTemplate += scale ? '.' + Array(scale + 1).join('d') : '';
    }

    var template = (negativeNum ? '{sign}' : '') + s.prefix.replace(/d/g, '\\d') + numberTemplate + s.suffix.replace(/d/g, '\\d');
    return {
      template: template,
      leftKey: negativeNum ? {
        text: '-/+',
        variable: 'sign:-:',
        track: false,
        keys: [107, 109, 187, 189]
      } : undefined,
      rightKey: freeEntry ? {
        text: s.decimalSeparator,
        value: '.',
        keys: [110, 190]
      } : undefined,
      allowLeadingZero: freeEntry,
      parseValue: function parseValue(value) {
        var i,
            m,
            v = value || s.defaultValue,
            ret = [],
            fixScale = scale !== undefined ? scale : s.maxScale;

        if (value === '' || value === null || value === undefined) {
          return ret;
        }

        if (+value === 0) {
          if (freeEntry) {
            return [0];
          } else {
            return [];
          }
        }

        if (v) {
          v = (v + '').replace(thousandRegex, '').replace(s.decimalSeparator, '.');
          m = v.match(/\d+\.?\d*/g);

          if (m) {
            m = (+m[0]).toFixed(fixScale);

            for (i = 0; i < m.length; i++) {
              if (m[i] != '.') {
                if (+m[i]) {
                  ret.push(+m[i]);
                } else if (ret.length) {
                  // No leading 0s
                  // in freeEntry mode, zeros after the decimal point are only necessary if there are other nonzero digits after them
                  // for example 10.0001 - decimal zeros are required => 10.0001 => [1, 0, ., 0, 0, 0, 1]
                  // for example 10.1000 - decimal zeros are not required => 10.1 => [1, 0, ., 1]
                  var decIndex = m.indexOf('.');
                  var nonZero = m.length > i + 1 && m.substring(i + 1).match(/[1-9]+/);

                  if (!freeEntry || i < decIndex || nonZero) {
                    ret.push(0);
                  }
                }
              } else if (freeEntry) {
                // in the case of freeEntry, the decimal point should be part of the input digits
                ret.push('.');
              }
            }

            var decimalIndex = m.indexOf('.'); // if there are no digits after the point remove the point

            if (ret.indexOf('.') >= 0 && (m.length <= decimalIndex + 1 || !m.substring(decimalIndex + 1).match(/[1-9]+/))) {
              ret.splice(ret.indexOf('.'), 1);
            }
          }
        }

        if (value < 0) {
          // make the sign the last thing to manipulate
          ret.unshift('sign:' + '-');
        }

        return ret;
      },
      formatValue: function formatValue(value, variables) {
        var v = getFormatted(value, true),
            nr = getNumber(value, variables && variables.sign == '-');
        return (nr < 0 ? '-' : '') + (s.returnAffix ? s.prefix + v + s.suffix : v);
      },
      validate: function validate(data) {
        var i,
            digits = data.values,
            v = getFormatted(digits),
            nr = getNumber(digits, data.variables && data.variables.sign == '-'),
            disabled = [],
            invalid = nr > max || nr < min || (s.invalid ? inst._indexOf(s.invalid, nr) != -1 : false);

        if (!digits.length && !s.allowLeadingZero && !freeEntry) {
          disabled.push(0);
        }

        if (digits.length >= maxIntLength || digits.indexOf('.') !== -1) {
          disabled.push('.');
        }

        if (freeEntry) {
          if (digits.length == 1 && digits[0] === 0) {
            for (i = 0; i <= 9; i++) {
              disabled.push(i);
            }
          }

          if (!digits.length || digits[digits.length - 1] == '.') {
            invalid = true;
          } // Only allow max maxScale decimal values


          var sca = scale !== undefined ? scale : s.maxScale; // >= meaning: starting zero digit may be missing, that's why

          if (digits.length >= sca + 1 && digits[digits.length - sca - 1] == '.') {
            for (i = 0; i <= 9; i++) {
              disabled.push(i);
            }
          }
        } // Display the formatted value


        if (inst.isVisible()) {
          $$1('.mbsc-np-dsp', inst._markup).html((data.variables.sign || '') + s.prefix + v + s.suffix || '&nbsp;');
        }

        return {
          disabled: disabled,
          invalid: invalid
        };
      }
    };
  }; // ---
  // Timespan preset
  // ---


  function getSeconds(value) {
    var i = 0,
        m = 1,
        ret = 0;

    while (value.length) {
      if (i > 3) {
        m = 60 * 60;
      } else if (i > 1) {
        m = 60;
      }

      ret = ret + value.pop() * m * (i % 2 ? 10 : 1);
      i++;
    }

    return ret;
  }

  var parts = ['h', 'm', 's'],
      timespanDefaults = {
    min: 0,
    max: 362439,
    //99 * 60 * 60 + 99 * 60 + 99
    defaultValue: 0,
    hourTextShort: 'h',
    minuteTextShort: 'm',
    secTextShort: 's'
  };

  presets$1.timespan = function (inst) {
    var orig = extend$1({}, inst.settings),
        s = extend$1(inst.settings, timespanDefaults, orig),
        labels = {
      h: s.hourTextShort.replace(/d/g, '\\d'),
      m: s.minuteTextShort.replace(/d/g, '\\d'),
      s: s.secTextShort.replace(/d/g, '\\d')
    },
        template = 'd<span class="mbsc-np-sup mbsc-np-time">' + labels.s + '</span>';

    function formatTime(seconds) {
      var p,
          ret = '',
          m = 60 * 60;
      $$1(parts).each(function (i, v) {
        p = Math.floor(seconds / m);
        seconds -= p * m;
        m /= 60;

        if (p > 0 || v == 's' && !ret) {
          ret = ret + (ret ? ' ' : '') + p + labels[v];
        }
      });
      return ret;
    }

    if (s.max > 9) {
      template = 'd' + template;
    }

    if (s.max > 99) {
      template = '<span class="mbsc-np-ts-m">' + (s.max > 639 ? 'd' : '') + 'd</span><span class="mbsc-np-sup mbsc-np-time">' + labels.m + '</span>' + template;
    }

    if (s.max > 6039) {
      template = '<span class="mbsc-np-ts-h">' + (s.max > 38439 ? 'd' : '') + 'd</span><span class="mbsc-np-sup mbsc-np-time">' + labels.h + '</span>' + template;
    } // Extended methods
    // ---


    inst.setVal = function (val, fill, change, temp) {
      if (isNumeric(val)) {
        val = formatTime(val);
      }

      return inst._setVal(val, fill, change, temp);
    };

    inst.getVal = function (temp) {
      return inst._hasValue || temp ? getSeconds(inst.getArrayVal(temp)) : null;
    }; // ---


    return {
      template: template,
      parseValue: function parseValue(value) {
        var p,
            vv = value || formatTime(s.defaultValue),
            ret = [];

        if (vv) {
          $$1(parts).each(function (i, v) {
            p = new RegExp('(\\d+)' + labels[v], 'gi').exec(vv);

            if (p) {
              p = +p[1];

              if (p > 9) {
                ret.push(Math.floor(p / 10));
                ret.push(p % 10);
              } else {
                if (ret.length) {
                  // No leading 0s
                  ret.push(0);
                }

                if (p || ret.length) {
                  // No leading 0s
                  ret.push(p);
                }
              }
            } else if (ret.length) {
              ret.push(0);
              ret.push(0);
            }
          });
        }

        return ret;
      },
      formatValue: function formatValue(value) {
        return formatTime(getSeconds(value));
      },
      validate: function validate(data) {
        var value = data.values,
            v = getSeconds(value.slice(0)),
            disabled = [];

        if (!value.length) {
          disabled.push(0);
        }

        return {
          disabled: disabled,
          invalid: v > s.max || v < s.min || (s.invalid ? inst._indexOf(s.invalid, +v) != -1 : false)
        };
      }
    };
  }; // ---
  // Time preset
  // ---


  var timeDefaults = {
    timeFormat: 'hh:ii A',
    amText: 'am',
    pmText: 'pm'
  };

  presets$1.time = function (inst) {
    var orig = extend$1({}, inst.settings),
        s = extend$1(inst.settings, timeDefaults, orig),
        timeFormat = s.timeFormat.split(':'),
        isAmPM = s.timeFormat.match(/a/i),
        am = isAmPM ? isAmPM[0] == 'a' ? s.amText : s.amText.toUpperCase() : '',
        pm = isAmPM ? isAmPM[0] == 'a' ? s.pmText : s.pmText.toUpperCase() : '',
        l = 0,
        minH = s.min ? '' + s.min.getHours() : '',
        maxH = s.max ? '' + s.max.getHours() : '',
        minM = s.min ? '' + (s.min.getMinutes() < 10 ? '0' + s.min.getMinutes() : s.min.getMinutes()) : '',
        maxM = s.max ? '' + (s.max.getMinutes() < 10 ? '0' + s.max.getMinutes() : s.max.getMinutes()) : '',
        minS = s.min ? '' + (s.min.getSeconds() < 10 ? '0' + s.min.getSeconds() : s.min.getSeconds()) : '',
        maxS = s.max ? '' + (s.max.getSeconds() < 10 ? '0' + s.max.getSeconds() : s.max.getSeconds()) : '';

    if (s.min) {
      s.min.setFullYear(2014, 7, 20);
    }

    if (s.max) {
      s.max.setFullYear(2014, 7, 20);
    }

    function getFormattedTime(value, variables) {
      var i,
          ret = '';

      for (i = 0; i < value.length; ++i) {
        ret += value[i] + (i % 2 == (value.length % 2 == 1 ? 0 : 1) && i != value.length - 1 ? ':' : '');
      }

      $$1.each(variables, function (i, v) {
        ret += ' ' + v;
      });
      return ret;
    }

    function disableButtons(value) {
      var i,
          isMinH,
          isMaxH,
          isMinM,
          isMaxM,
          invH,
          invM,
          invS,
          hour,
          minutes,
          length = value.length,
          disabled = [],
          digitNr = 2 * timeFormat.length;
      l = digitNr;

      if (!length) {
        if (isAmPM) {
          disabled.push(0);
          disabled.push(s.leftKey.value);
        }

        disabled.push(s.rightKey.value);
      }

      if (!isAmPM && (digitNr - length < 2 || value[0] != 1 && (value[0] > 2 || value[1] > 3) && digitNr - length <= 2)) {
        disabled.push('30');
        disabled.push('00');
      }

      if ((isAmPM ? value[0] > 1 || value[1] > 2 : value[0] != 1 && (value[0] > 2 || value[1] > 3)) && value[0]) {
        // if the hour number is not a two digit number
        value.unshift(0);
        l = digitNr - 1;
      }

      if (length == l || length === digitNr - 1 && value[2] > 5) {
        for (i = 0; i <= 9; ++i) {
          disabled.push(i);
        }
      } else if (length == 1 && isAmPM && value[0] == 1 || !isAmPM && value[0] == 2 && value[1] > 3 && length % 2 == 1) {
        for (i = 6; i <= 9; ++i) {
          disabled.push(i);
        }
      }

      hour = value[1] !== undefined ? '' + value[0] + value[1] : '';
      minutes = +maxM == +(value[3] !== undefined ? '' + value[2] + value[3] : '');

      if (s.invalid) {
        for (i = 0; i < s.invalid.length; ++i) {
          invH = s.invalid[i].getHours();
          invM = s.invalid[i].getMinutes();
          invS = s.invalid[i].getSeconds();

          if (invH == +hour) {
            if (timeFormat.length == 2 && (invM < 10 ? 0 : +('' + invM)[0]) == +value[2]) {
              // disable invalid minutes
              disabled.push(invM < 10 ? invM : +('' + invM)[1]);
              break;
            } else if ((invS < 10 ? 0 : +('' + invS)[0]) == +value[4]) {
              // disable invalid sec
              disabled.push(invS < 10 ? invS : +('' + invS)[1]);
              break;
            }
          }
        }
      }

      if (s.min || s.max) {
        isMinH = +minH == +hour;
        isMaxH = +maxH == +hour;
        isMaxM = isMaxH && minutes;
        isMinM = isMinH && minutes;

        if (length === 0) {
          for (i = isAmPM ? 2 : minH > 19 ? minH[0] : 3; i <= (minH[0] == 1 ? 9 : minH[0] - 1); ++i) {
            // disables values lower than min and leves the 1,2 buttons
            disabled.push(i);
          }

          if (minH >= 10) {
            disabled.push(0);

            if (minH[0] == 2) {
              //if 2x hour is min
              for (i = 3; i <= 9; ++i) {
                disabled.push(i);
              }
            }
          }

          if (maxH && maxH < 10 || minH && minH >= 10) {
            //disables values between min and max values
            for (i = maxH && maxH < 10 ? +maxH[0] + 1 : 0; i < (minH && minH >= 10 ? minH[0] : 10); ++i) {
              disabled.push(i);
            }
          }
        }

        if (length == 1) {
          if (value[0] === 0) {
            // disable min values if 24h format, and starts with 0
            for (i = 0; i < minH[0]; ++i) {
              //kiveve minH[0] == 1 ? 9 :
              disabled.push(i);
            }
          }

          if (minH && value[0] !== 0 && (isAmPM ? value[0] == 1 : value[0] == 2)) {
            // don't allow lower values entered, ex. 2:56
            for (i = isAmPM ? 3 : 4; i <= 9; ++i) {
              disabled.push(i);
            }
          }

          if (value[0] == minH[0]) {
            // is min value
            for (i = 0; i < minH[1]; ++i) {
              disabled.push(i);
            }
          }

          if (value[0] == maxH[0] && !isAmPM) {
            // is max value
            for (i = +maxH[1] + 1; i <= 9; ++i) {
              disabled.push(i);
            }
          }
        }

        if (length == 2 && (isMinH || isMaxH)) {
          for (i = isMaxH ? +maxM[0] + 1 : 0; i < (isMinH ? +minM[0] : 10); ++i) {
            disabled.push(i);
          }
        }

        if (length == 3 && (isMaxH && value[2] == maxM[0] || isMinH && value[2] == minM[0])) {
          for (i = isMaxH && value[2] == maxM[0] ? +maxM[1] + 1 : 0; i < (isMinH && value[2] == minM[0] ? +minM[1] : 10); ++i) {
            disabled.push(i);
          }
        }

        if (length == 4 && (isMinM || isMaxM)) {
          for (i = isMaxM ? +maxS[0] + 1 : 0; i < (isMinM ? +minS[0] : 10); ++i) {
            disabled.push(i);
          }
        }

        if (length == 5 && (isMinM && value[4] == minS[0] || isMaxM && value[4] == maxS[0])) {
          for (i = isMaxM && value[4] == maxS[0] ? +maxS[1] + 1 : 0; i < (isMinM && value[4] == minS[0] ? +minS[1] : 10); ++i) {
            disabled.push(i);
          }
        }
      }

      return disabled;
    }

    return {
      placeholder: '-',
      allowLeadingZero: true,
      template: (timeFormat.length == 3 ? 'dd:dd:dd' : timeFormat.length == 2 ? 'dd:dd' : 'dd') + (isAmPM ? '<span class="mbsc-np-sup">{ampm:--}</span>' : ''),
      leftKey: isAmPM ? {
        text: am,
        variable: 'ampm:' + am,
        value: '00'
      } : {
        text: ':00',
        value: '00'
      },
      rightKey: isAmPM ? {
        text: pm,
        variable: 'ampm:' + pm,
        value: '00'
      } : {
        text: ':30',
        value: '30'
      },
      parseValue: function parseValue(value) {
        var i,
            m,
            v = value || s.defaultValue,
            ret = [];

        if (v) {
          v = v + '';
          m = v.match(/\d/g);

          if (m) {
            for (i = 0; i < m.length; i++) {
              ret.push(+m[i]);
            }
          }

          if (isAmPM) {
            ret.push('ampm:' + (v.match(new RegExp(s.pmText, 'gi')) ? pm : am));
          }
        }

        return ret;
      },
      formatValue: function formatValue(value, variables) {
        return getFormattedTime(value, variables);
      },
      validate: function validate(data) {
        var value = data.values,
            variables = data.variables,
            formattedTime = getFormattedTime(value, variables),
            d = value.length >= 3 ? new Date(2014, 7, 20, '' + value[0] + (value.length % 2 === 0 ? value[1] : ''), '' + value[value.length % 2 === 0 ? 2 : 1] + value[value.length % 2 === 0 ? 3 : 2]) : '';
        return {
          disabled: disableButtons(value),
          length: l,
          invalid: (isAmPM ? !new RegExp('^(0?[1-9]|1[012])(:[0-5]\\d)?(:[0-5][0-9])' + ' (?:' + s.amText + '|' + s.pmText + ')$', 'i').test(formattedTime) : !/^([0-1]?[0-9]|2[0-4]):([0-5][0-9])(:[0-5][0-9])?$/.test(formattedTime)) || (s.invalid ? inst._indexOf(s.invalid, d) != -1 : false) || !((s.min ? s.min <= d : true) && (s.max ? d <= s.max : true))
        };
      }
    };
  }; // Date preset
  // ---


  var dateDefaults = {
    dateOrder: 'mdy',
    dateFormat: 'mm/dd/yy',
    delimiter: '/'
  };

  presets$1.date = function (inst) {
    var yi,
        mi,
        di,
        i,
        indexArray = [],
        orig = extend$1({}, inst.settings),
        s = extend$1(inst.settings, dateTimeDefaults, dateDefaults, orig),
        templ = s.dateOrder,
        minM = s.min ? '' + (s.getMonth(s.min) + 1) : 0,
        maxM = s.max ? '' + (s.getMonth(s.max) + 1) : 0,
        minD = s.min ? '' + s.getDay(s.min) : 0,
        maxD = s.max ? '' + s.getDay(s.max) : 0,
        minY = s.min ? '' + s.getYear(s.min) : 0,
        maxY = s.max ? '' + s.getYear(s.max) : 0;
    templ = templ.replace(/y+/gi, 'yyyy');
    templ = templ.replace(/m+/gi, 'mm');
    templ = templ.replace(/d+/gi, 'dd');
    yi = templ.toUpperCase().indexOf('Y');
    mi = templ.toUpperCase().indexOf('M');
    di = templ.toUpperCase().indexOf('D');
    templ = '';
    indexArray.push({
      val: yi,
      n: 'yyyy'
    }, {
      val: mi,
      n: 'mm'
    }, {
      val: di,
      n: 'dd'
    });
    indexArray.sort(function (a, b) {
      return a.val - b.val;
    });
    $$1.each(indexArray, function (i, v) {
      templ += v.n;
    });
    yi = templ.indexOf('y');
    mi = templ.indexOf('m');
    di = templ.indexOf('d');
    templ = '';

    for (i = 0; i < 8; ++i) {
      templ += 'd';

      if (i + 1 == yi || i + 1 == mi || i + 1 == di) {
        templ += s.delimiter;
      }
    }

    function isleapYear(year) {
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }

    function disableButtons(value) {
      var i,
          j,
          invY,
          invM,
          invD,
          disabled = [],
          year = value[yi + 3] !== undefined ? '' + value[yi] + value[yi + 1] + value[yi + 2] + value[yi + 3] : '',
          month = value[mi + 1] !== undefined ? '' + value[mi] + value[mi + 1] : '',
          day = value[di + 1] !== undefined ? '' + value[di] + value[di + 1] : '',
          maxDay = '' + s.getMaxDayOfMonth(year || 2012, month - 1 || 0),
          // Use a leap year if no year present to allow day 29 to be enetered
      isMin = minY === year && +minM === +month,
          isMax = maxY === year && +maxM === +month;

      if (s.invalid) {
        for (i = 0; i < s.invalid.length; ++i) {
          invY = s.getYear(s.invalid[i]);
          invM = s.getMonth(s.invalid[i]);
          invD = s.getDay(s.invalid[i]);

          if (invY == +year && invM + 1 == +month) {
            //disable the ivalid day
            if ((invD < 10 ? 0 : +('' + invD)[0]) == +value[di]) {
              disabled.push(invD < 10 ? invD : +('' + invD)[1]);
              break;
            }
          }

          if (invM + 1 == +month && invD == +day) {
            //disable invalid year
            if (('' + invY).substring(0, 3) == '' + value[yi] + value[yi + 1] + value[yi + 2]) {
              disabled.push(('' + invY)[3]);
              break;
            }
          }

          if (invY == +year && invD == +day) {
            //disable the ivalid month
            if ((invM < 10 ? 0 : +('' + (invM + 1))[0]) == +value[mi]) {
              disabled.push(invM < 10 ? invM : +('' + (invM + 1))[1]);
              break;
            }
          }
        }
      } // month check


      if (day == '31' && (value.length == mi || value.length == mi + 1)) {
        // disable 30 day months
        if (value[mi] != 1) {
          disabled.push(2, 4, 6, 9, 11);
        } else {
          disabled.push(1);
        }
      }

      if (day == '30' && value[mi] === 0 && value.length <= mi + 1) {
        // disable february
        disabled.push(2);
      }

      if (value.length == mi) {
        // before month's first digit set, disable values outside min/max
        for (i = maxY === year && +maxM < 10 ? 1 : 2; i <= 9; ++i) {
          disabled.push(i);
        }

        if (minY === year && +minM >= 10) {
          disabled.push(0);
        }
      }

      if (value.length == mi + 1) {
        // before month's second digit set
        if (value[mi] == 1) {
          // if two digit month number
          for (i = maxY === year ? +maxM[1] + 1 : 3; i <= 9; ++i) {
            disabled.push(i);
          }

          if (minY == year) {
            // if min year diable lower values
            for (i = 0; i < +minM[1]; ++i) {
              disabled.push(i);
            }
          }
        }

        if (value[mi] === 0) {
          //if month number starts with 0
          disabled.push(0);

          if (maxY === year || minY === year) {
            // if min/max diable lower/greater values
            for (i = maxY === year ? +day > +maxD ? +maxM : +maxM + 1 : 0; i <= (minY === year ? +day < +minD ? +minM - 1 : +minM - 1 : 9); ++i) {
              disabled.push(i);
            }
          }
        }
      } // day check


      if (value.length == di) {
        // before day first digit set
        for (i = isMax ? (+maxD > 10 ? +maxD[0] : 0) + 1 : +maxDay[0] + 1; i <= 9; ++i) {
          disabled.push(i);
        }

        if (isMin) {
          // if is min year and month disable lower values
          for (i = 0; i < (+minD < 10 ? 0 : minD[0]); ++i) {
            disabled.push(i);
          }
        }
      }

      if (value.length == di + 1) {
        // before day second digit set
        if (value[di] >= 3 || month == '02') {
          //disable greater values than the maxDay's second digit
          for (i = +maxDay[1] + 1; i <= 9; ++i) {
            disabled.push(i);
          }
        }

        if (isMax && +maxD[0] == value[di]) {
          //if max year and month disable greater values
          for (i = +maxD[1] + 1; i <= 9; ++i) {
            disabled.push(i);
          }
        }

        if (isMin && minD[0] == value[di]) {
          //if min year and month disable lower values
          for (i = 0; i < +minD[1]; ++i) {
            disabled.push(i);
          }
        }

        if (value[di] === 0) {
          // if month first digit 0
          disabled.push(0);

          if (isMax || isMin) {
            // disable greater/lower valies if min or max
            for (i = isMax ? +maxD + 1 : 1; i <= (isMin ? +minD - 1 : 9); ++i) {
              disabled.push(i);
            }
          }
        }
      } // year check


      if (value[yi + 2] !== undefined && month == '02' && day == '29') {
        // if 29th and february than just leap years allowed
        for (j = +('' + value[yi] + value[yi + 1] + value[yi + 2] + 0); j <= +('' + value[yi] + value[yi + 1] + value[yi + 2] + 9); ++j) {
          disabled.push(!isleapYear(j) ? j % 10 : '');
        }
      }

      if (value.length == yi) {
        // before year's first digit set
        if (s.min) {
          // disable lower values
          for (i = 0; i < +minY[0]; ++i) {
            disabled.push(i);
          }
        }

        if (s.max) {
          //disable greater values
          for (i = +maxY[0] + 1; i <= 9; ++i) {
            disabled.push(i);
          }
        }

        disabled.push(0);
      }

      if (s.min || s.max) {
        for (j = 1; j < 4; ++j) {
          if (value.length == yi + j) {
            // before year's i-th digit set
            if (value[yi + j - 1] == +minY[j - 1] && (j == 3 ? value[yi + j - 2] == +minY[j - 2] : true)) {
              for (i = 0; i < +minY[j] + (j == 3 && value[mi + 1] && +minM > +month ? 1 : 0); ++i) {
                //if month less than min-month than doesn't allow minYear
                disabled.push(i);
              }
            }

            if (value[yi + j - 1] == +maxY[j - 1] && (j == 3 ? value[yi + j - 2] == +maxY[j - 2] : true)) {
              for (i = +maxY[j] + (j == 3 && +maxM < +month ? 0 : 1); i <= 9; ++i) {
                //if month greater than max-month than doesn't allow maxYear
                disabled.push(i);
              }
            }
          }
        }
      }

      return disabled;
    }

    function calcDate(value) {
      return new Date(+('' + value[yi] + value[yi + 1] + value[yi + 2] + value[yi + 3]), +('' + value[mi] + value[mi + 1]) - 1, +('' + value[di] + value[di + 1]));
    } // Extended methods
    // ---


    inst.getVal = function (temp) {
      return inst._hasValue || temp ? calcDate(inst.getArrayVal(temp)) : null;
    }; // ---


    return {
      placeholder: '-',
      fill: 'ltr',
      allowLeadingZero: true,
      template: templ,
      parseValue: function parseValue(value) {
        var i,
            ret = [],
            v = value || s.defaultValue,
            d = parseDate(s.dateFormat, v, s);

        if (v) {
          for (i = 0; i < indexArray.length; ++i) {
            if (/m/i.test(indexArray[i].n)) {
              ret = ret.concat(((s.getMonth(d) < 9 ? '0' : '') + (s.getMonth(d) + 1)).split(''));
            } else if (/d/i.test(indexArray[i].n)) {
              ret = ret.concat(((s.getDay(d) < 10 ? '0' : '') + s.getDay(d)).split(''));
            } else {
              ret = ret.concat((s.getYear(d) + '').split(''));
            }
          }
        }

        return ret;
      },
      formatValue: function formatValue(value) {
        return formatDate(s.dateFormat, calcDate(value), s);
      },
      validate: function validate(data) {
        var value = data.values,
            d = calcDate(value);
        return {
          disabled: disableButtons(value),
          invalid: !(d != 'Invalid Date' && (s.min ? s.min <= d : true) && (s.max ? d <= s.max : true)) || (s.invalid ? inst._indexOf(s.invalid, d) != -1 : false)
        };
      }
    };
  }; // ---

  var MbscNumpadBase = (function (_super) {
      __extends(MbscNumpadBase, _super);
      function MbscNumpadBase(initialElem, zone, control, inputService, optionService, view) {
          var _this = _super.call(this, initialElem, zone, control, inputService, view) || this;
          _this.optionService = optionService;
          _this.onSet = new core.EventEmitter();
          _this.onClear = new core.EventEmitter();
          _this.onInput = new core.EventEmitter();
          return _this;
      }
      MbscNumpadBase.decorators = [
          { type: core.Directive, args: [{ selector: '[mbsc-n-b]' },] },
      ];
      MbscNumpadBase.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: core.ViewContainerRef, },
      ]; };
      MbscNumpadBase.propDecorators = {
          'allowLeadingZero': [{ type: core.Input },],
          'deleteIcon': [{ type: core.Input },],
          'fill': [{ type: core.Input },],
          'leftKey': [{ type: core.Input },],
          'mask': [{ type: core.Input },],
          'placeholderChar': [{ type: core.Input, args: ['char-placeholder',] },],
          'rightKey': [{ type: core.Input },],
          'template': [{ type: core.Input },],
          'validate': [{ type: core.Input },],
          'onSet': [{ type: core.Output },],
          'onClear': [{ type: core.Output },],
          'onInput': [{ type: core.Output },],
          'cancelText': [{ type: core.Input },],
          'clearText': [{ type: core.Input },],
          'setText': [{ type: core.Input },],
      };
      return MbscNumpadBase;
  }(MbscFrameBase));
  var MbscNumpad = (function (_super) {
      __extends(MbscNumpad, _super);
      function MbscNumpad(initialElem, zone, control, inputService, optionService, view) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;
          _this.options = {};
          _this.preset = undefined;
          _this.onChangeEmitter = new core.EventEmitter();
          return _this;
      }
      Object.defineProperty(MbscNumpad.prototype, "value", {
          set: function (v) {
              if (!this.control) {
                  this.setNewValueProxy(v);
              }
          },
          enumerable: true,
          configurable: true
      });
      MbscNumpad.prototype.setNewValue = function (v) {
          if (this.instance) {
              var innerValue = this.instance.getVal();
              if (innerValue !== v) {
                  this.instance.setVal(v, true, false);
                  if (this._inputService && this._inputService.input) {
                      this._inputService.input.innerValue = this.instance._value;
                  }
              }
          }
      };
      MbscNumpad.prototype.initControl = function () {
          var options = extend$1({ preset: this.preset }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
          this.instance = new Numpad(this.element, options);
          if (this.initialValue !== undefined) {
              this.instance.setVal(this.initialValue, true, false);
          }
      };
      MbscNumpad.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mbsc-numpad]',
                      exportAs: 'mobiscroll'
                  },] },
      ];
      MbscNumpad.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: core.ViewContainerRef, },
      ]; };
      MbscNumpad.propDecorators = {
          'options': [{ type: core.Input, args: ['mbsc-options',] },],
          'value': [{ type: core.Input, args: ['mbsc-numpad',] },],
          'onChangeEmitter': [{ type: core.Output, args: ['mbsc-numpadChange',] },],
      };
      return MbscNumpad;
  }(MbscNumpadBase));
  var MbscNumpadComponent = (function (_super) {
      __extends(MbscNumpadComponent, _super);
      function MbscNumpadComponent(initialElem, zone, control, inputService, optionService) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
          _this.errorMessage = '';
          _this.placeholder = '';
          return _this;
      }
      MbscNumpadComponent.prototype.ngAfterViewInit = function () {
          _super.prototype.ngAfterViewInit.call(this);
          this.setThemeClasses();
      };
      MbscNumpadComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-numpad',
                      exportAs: 'mobiscroll',
                      template: INPUT_TEMPLATE
                  },] },
      ];
      MbscNumpadComponent.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscNumpadComponent.propDecorators = {
          'inputIcon': [{ type: core.Input, args: ['icon',] },],
          'iconAlign': [{ type: core.Input, args: ['icon-align',] },],
          'name': [{ type: core.Input },],
          'error': [{ type: core.Input },],
          'errorMessage': [{ type: core.Input },],
          'options': [{ type: core.Input },],
          'placeholder': [{ type: core.Input },],
      };
      return MbscNumpadComponent;
  }(MbscNumpad));
  var MbscNumpadDecimal = (function (_super) {
      __extends(MbscNumpadDecimal, _super);
      function MbscNumpadDecimal(initialElem, zone, control, inputService, optionService, view) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;
          _this.options = {};
          _this.onChangeEmitter = new core.EventEmitter();
          _this.preset = 'decimal';
          return _this;
      }
      Object.defineProperty(MbscNumpadDecimal.prototype, "value", {
          set: function (v) {
              if (this.instance || v !== '') {
                  this.setNewValueProxy(v);
              }
          },
          enumerable: true,
          configurable: true
      });
      MbscNumpadDecimal.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mbsc-numpad-decimal]',
                      exportAs: 'mobiscroll'
                  },] },
      ];
      MbscNumpadDecimal.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: core.ViewContainerRef, },
      ]; };
      MbscNumpadDecimal.propDecorators = {
          'value': [{ type: core.Input, args: ['mbsc-numpad-decimal',] },],
          'decimalSeparator': [{ type: core.Input },],
          'defaultValue': [{ type: core.Input },],
          'entryMode': [{ type: core.Input },],
          'invalid': [{ type: core.Input },],
          'scale': [{ type: core.Input },],
          'maxScale': [{ type: core.Input },],
          'min': [{ type: core.Input },],
          'max': [{ type: core.Input },],
          'prefix': [{ type: core.Input },],
          'returnAffix': [{ type: core.Input },],
          'suffix': [{ type: core.Input },],
          'thousandsSeparator': [{ type: core.Input },],
          'options': [{ type: core.Input, args: ['mbsc-options',] },],
          'onChangeEmitter': [{ type: core.Output, args: ['mbsc-numpad-decimalChange',] },],
      };
      return MbscNumpadDecimal;
  }(MbscNumpad));
  var MbscNumpadDecimalComponent = (function (_super) {
      __extends(MbscNumpadDecimalComponent, _super);
      function MbscNumpadDecimalComponent(initialElem, zone, control, inputService, optionService) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
          _this.errorMessage = '';
          _this.placeholder = '';
          return _this;
      }
      MbscNumpadDecimalComponent.prototype.ngAfterViewInit = function () {
          _super.prototype.ngAfterViewInit.call(this);
          this.setThemeClasses();
      };
      MbscNumpadDecimalComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-numpad-decimal',
                      exportAs: 'mobiscroll',
                      template: INPUT_TEMPLATE
                  },] },
      ];
      MbscNumpadDecimalComponent.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscNumpadDecimalComponent.propDecorators = {
          'inputIcon': [{ type: core.Input, args: ['icon',] },],
          'iconAlign': [{ type: core.Input, args: ['icon-align',] },],
          'name': [{ type: core.Input },],
          'error': [{ type: core.Input },],
          'errorMessage': [{ type: core.Input },],
          'options': [{ type: core.Input },],
          'placeholder': [{ type: core.Input },],
      };
      return MbscNumpadDecimalComponent;
  }(MbscNumpadDecimal));
  var MbscNumpadDate = (function (_super) {
      __extends(MbscNumpadDate, _super);
      function MbscNumpadDate(initialElem, zone, control, inputService, optionService, view) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;
          _this.options = {};
          _this.onChangeEmitter = new core.EventEmitter();
          return _this;
      }
      Object.defineProperty(MbscNumpadDate.prototype, "value", {
          set: function (v) {
              if (this.instance || v !== '') {
                  this.setNewValueProxy(v);
              }
          },
          enumerable: true,
          configurable: true
      });
      MbscNumpadDate.prototype.setNewValue = function (v) {
          if (this.instance) {
              var innerValue = this.instance.getVal();
              if ((innerValue && !v) ||
                  (!innerValue && v) ||
                  (innerValue && v && innerValue.getTime() !== v.getTime())) {
                  this.instance.setVal(v, true, false);
                  if (this._inputService && this._inputService.input) {
                      this._inputService.input.innerValue = this.instance._value;
                  }
              }
          }
      };
      MbscNumpadDate.prototype.initControl = function () {
          var options = extend$1({ preset: 'date' }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
          this.instance = new Numpad(this.element, options);
          if (this.initialValue !== undefined && this.initialValue !== "") {
              this.instance.setVal(this.initialValue, true, false);
          }
      };
      MbscNumpadDate.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mbsc-numpad-date]',
                      exportAs: 'mobiscroll'
                  },] },
      ];
      MbscNumpadDate.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: core.ViewContainerRef, },
      ]; };
      MbscNumpadDate.propDecorators = {
          'value': [{ type: core.Input, args: ['mbsc-numpad-date',] },],
          'dateFormat': [{ type: core.Input },],
          'dateOrder': [{ type: core.Input },],
          'delimiter': [{ type: core.Input },],
          'defaultValue': [{ type: core.Input },],
          'invalid': [{ type: core.Input },],
          'min': [{ type: core.Input },],
          'max': [{ type: core.Input },],
          'options': [{ type: core.Input, args: ['mbsc-options',] },],
          'onChangeEmitter': [{ type: core.Output, args: ['mbsc-numpad-dateChange',] },],
      };
      return MbscNumpadDate;
  }(MbscNumpadBase));
  var MbscNumpadDateComponent = (function (_super) {
      __extends(MbscNumpadDateComponent, _super);
      function MbscNumpadDateComponent(initialElem, zone, control, inputService, optionService) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
          _this.errorMessage = '';
          _this.placeholder = '';
          return _this;
      }
      MbscNumpadDateComponent.prototype.ngAfterViewInit = function () {
          _super.prototype.ngAfterViewInit.call(this);
          this.setThemeClasses();
      };
      MbscNumpadDateComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-numpad-date',
                      exportAs: 'mobiscroll',
                      template: INPUT_TEMPLATE
                  },] },
      ];
      MbscNumpadDateComponent.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscNumpadDateComponent.propDecorators = {
          'inputIcon': [{ type: core.Input, args: ['icon',] },],
          'iconAlign': [{ type: core.Input, args: ['icon-align',] },],
          'name': [{ type: core.Input },],
          'error': [{ type: core.Input },],
          'errorMessage': [{ type: core.Input },],
          'options': [{ type: core.Input },],
          'placeholder': [{ type: core.Input },],
      };
      return MbscNumpadDateComponent;
  }(MbscNumpadDate));
  var MbscNumpadTime = (function (_super) {
      __extends(MbscNumpadTime, _super);
      function MbscNumpadTime(initialElem, zone, control, inputService, optionService, view) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;
          _this.options = {};
          _this.onChangeEmitter = new core.EventEmitter();
          return _this;
      }
      Object.defineProperty(MbscNumpadTime.prototype, "value", {
          set: function (v) {
              if (this.instance || v !== '') {
                  this.setNewValueProxy(v);
              }
          },
          enumerable: true,
          configurable: true
      });
      MbscNumpadTime.prototype.setNewValue = function (v) {
          if (this.instance) {
              var innerValue = this.instance.getVal();
              if (innerValue !== v) {
                  this.instance.setVal(v, true, false);
                  if (this._inputService && this._inputService.input) {
                      this._inputService.input.innerValue = this.instance._value;
                  }
              }
          }
      };
      MbscNumpadTime.prototype.initControl = function () {
          var options = extend$1({ preset: 'time' }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
          this.instance = new Numpad(this.element, options);
          if (this.initialValue !== undefined && this.initialValue !== "") {
              this.instance.setVal(this.initialValue, true, false);
          }
      };
      MbscNumpadTime.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mbsc-numpad-time]',
                      exportAs: 'mobiscroll'
                  },] },
      ];
      MbscNumpadTime.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: core.ViewContainerRef, },
      ]; };
      MbscNumpadTime.propDecorators = {
          'value': [{ type: core.Input, args: ['mbsc-numpad-time',] },],
          'defaultValue': [{ type: core.Input },],
          'invalid': [{ type: core.Input },],
          'max': [{ type: core.Input },],
          'min': [{ type: core.Input },],
          'timeFormat': [{ type: core.Input },],
          'options': [{ type: core.Input, args: ['mbsc-options',] },],
          'onChangeEmitter': [{ type: core.Output, args: ['mbsc-numpad-timeChange',] },],
      };
      return MbscNumpadTime;
  }(MbscNumpadBase));
  var MbscNumpadTimeComponent = (function (_super) {
      __extends(MbscNumpadTimeComponent, _super);
      function MbscNumpadTimeComponent(initialElem, zone, control, inputService, optionService) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
          _this.errorMessage = '';
          _this.placeholder = '';
          return _this;
      }
      MbscNumpadTimeComponent.prototype.ngAfterViewInit = function () {
          _super.prototype.ngAfterViewInit.call(this);
          this.setThemeClasses();
      };
      MbscNumpadTimeComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-numpad-time',
                      exportAs: 'mobiscroll',
                      template: INPUT_TEMPLATE
                  },] },
      ];
      MbscNumpadTimeComponent.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscNumpadTimeComponent.propDecorators = {
          'inputIcon': [{ type: core.Input, args: ['icon',] },],
          'iconAlign': [{ type: core.Input, args: ['icon-align',] },],
          'name': [{ type: core.Input },],
          'error': [{ type: core.Input },],
          'errorMessage': [{ type: core.Input },],
          'options': [{ type: core.Input },],
          'placeholder': [{ type: core.Input },],
      };
      return MbscNumpadTimeComponent;
  }(MbscNumpadTime));
  var MbscNumpadTimespan = (function (_super) {
      __extends(MbscNumpadTimespan, _super);
      function MbscNumpadTimespan(initialElem, zone, control, inputService, optionService, view) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;
          _this.options = {};
          _this.onChangeEmitter = new core.EventEmitter();
          _this.preset = 'timespan';
          return _this;
      }
      Object.defineProperty(MbscNumpadTimespan.prototype, "value", {
          set: function (v) {
              if (this.instance || v !== '') {
                  this.setNewValueProxy(v);
              }
          },
          enumerable: true,
          configurable: true
      });
      MbscNumpadTimespan.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mbsc-numpad-timespan]',
                      exportAs: 'mobiscroll'
                  },] },
      ];
      MbscNumpadTimespan.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: core.ViewContainerRef, },
      ]; };
      MbscNumpadTimespan.propDecorators = {
          'value': [{ type: core.Input, args: ['mbsc-numpad-timespan',] },],
          'defaultValue': [{ type: core.Input },],
          'invalid': [{ type: core.Input },],
          'min': [{ type: core.Input },],
          'max': [{ type: core.Input },],
          'options': [{ type: core.Input, args: ['mbsc-options',] },],
          'onChangeEmitter': [{ type: core.Output, args: ['mbsc-numpad-timespanChange',] },],
      };
      return MbscNumpadTimespan;
  }(MbscNumpad));
  var MbscNumpadTimespanComponent = (function (_super) {
      __extends(MbscNumpadTimespanComponent, _super);
      function MbscNumpadTimespanComponent(initialElem, zone, control, inputService, optionService) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
          _this.errorMessage = '';
          _this.placeholder = '';
          return _this;
      }
      MbscNumpadTimespanComponent.prototype.ngAfterViewInit = function () {
          _super.prototype.ngAfterViewInit.call(this);
          this.setThemeClasses();
      };
      MbscNumpadTimespanComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-numpad-timespan',
                      exportAs: 'mobiscroll',
                      template: INPUT_TEMPLATE
                  },] },
      ];
      MbscNumpadTimespanComponent.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscNumpadTimespanComponent.propDecorators = {
          'inputIcon': [{ type: core.Input, args: ['icon',] },],
          'iconAlign': [{ type: core.Input, args: ['icon-align',] },],
          'name': [{ type: core.Input },],
          'error': [{ type: core.Input },],
          'errorMessage': [{ type: core.Input },],
          'options': [{ type: core.Input },],
          'placeholder': [{ type: core.Input },],
      };
      return MbscNumpadTimespanComponent;
  }(MbscNumpadTimespan));
  var comps$1 = [
      MbscNumpad,
      MbscNumpadBase,
      MbscNumpadComponent,
      MbscNumpadDecimal,
      MbscNumpadDecimalComponent,
      MbscNumpadDate,
      MbscNumpadDateComponent,
      MbscNumpadTime,
      MbscNumpadTimeComponent,
      MbscNumpadTimespan,
      MbscNumpadTimespanComponent
  ];
  var MbscNumpadModule = (function () {
      function MbscNumpadModule() {
      }
      MbscNumpadModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule, MbscFrameBaseModule, MbscInputModule],
                      declarations: comps$1,
                      exports: comps$1
                  },] },
      ];
      MbscNumpadModule.ctorParameters = function () { return []; };
      return MbscNumpadModule;
  }());

  var Optionlist = function Optionlist(elm, settings) {
    var that = this; // Call the parent constructor

    NavigationBase.call(this, elm, settings, true);
    /**
     * Optionlist initialization.
     */

    that.___init = function () {}; // Constructor


    that.init();
  }; // Defaults

  Optionlist.prototype = {
    _class: 'optionlist',
    _hasDef: true,
    _hasTheme: true,
    _hasLang: true,
    _responsive: true,
    _defaults: extend$1({}, NavigationBase.prototype._defaults, {
      select: 'multiple',
      variant: 'a',
      display: 'inline'
    })
  };
  classes.Optionlist = Optionlist;
  mobiscroll.themes.optionlist = mobiscroll.themes.navigation;

  var MbscOptionItem = (function (_super) {
      __extends(MbscOptionItem, _super);
      function MbscOptionItem(notifyItemService, _elem) {
          return _super.call(this, notifyItemService, _elem) || this;
      }
      MbscOptionItem.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-option-item',
                      template: '<ng-content></ng-content>',
                      host: {
                          '[attr.data-icon]': 'icon',
                          '[attr.data-disabled]': 'disabled',
                          '[attr.data-selected]': 'selected',
                          '[attr.data-id]': 'id'
                      }
                  },] },
      ];
      MbscOptionItem.ctorParameters = function () { return [
          { type: MbscNotifyItemService, },
          { type: core.ElementRef, },
      ]; };
      return MbscOptionItem;
  }(MbscNavItemBase));
  var MbscOptionlist = (function (_super) {
      __extends(MbscOptionlist, _super);
      function MbscOptionlist(initialElem, zone, notifyItemService, optionService) {
          var _this = _super.call(this, initialElem, zone, notifyItemService) || this;
          _this.optionService = optionService;
          return _this;
      }
      MbscOptionlist.prototype.initControl = function () {
          var _this = this;
          var onItemTap = this.tapHandler.bind(this);
          var onItemTapUser = this.options && this.options.onItemTap;
          if (onItemTapUser) {
              onItemTap = function (event, inst) {
                  _this.tapHandler(event, inst);
                  return onItemTapUser(event, inst);
              };
          }
          var options = extend$1({}, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, { onItemTap: onItemTap });
          this.instance = new Optionlist(this.initialElem.nativeElement, options);
          this.notifyItemService.notifyInstanceReady(this.instance);
          this.addRemoveObserver = this.notifyItemService.onAddRemove().subscribe(function (item) {
              _this.instance.refresh();
          });
      };
      MbscOptionlist.prototype.ngOnDestroy = function () {
          this.notifyItemService.onAddRemove().unsubscribe(this.addRemoveObserver);
          _super.prototype.ngOnDestroy.call(this);
      };
      MbscOptionlist.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-optionlist',
                      template: '<ng-content></ng-content>',
                      providers: [MbscNotifyItemService],
                      exportAs: 'mobiscroll',
                      host: { 'class': 'mbsc-cloak' }
                  },] },
      ];
      MbscOptionlist.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: MbscNotifyItemService, },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscOptionlist.propDecorators = {
          'select': [{ type: core.Input },],
          'items': [{ type: core.ContentChildren, args: [MbscOptionItem,] },],
      };
      return MbscOptionlist;
  }(MbscNavigationBase));
  var MbscOptionlistModule = (function () {
      function MbscOptionlistModule() {
      }
      MbscOptionlistModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [MbscNavigationBaseModule],
                      declarations: [MbscOptionItem, MbscOptionlist],
                      exports: [MbscOptionItem, MbscOptionlist]
                  },] },
      ];
      MbscOptionlistModule.ctorParameters = function () { return []; };
      return MbscOptionlistModule;
  }());

  // ---

  var Page = function Page(el, settings) {
    var cssClass = '',
        $elm = $$1(el),
        that = this,
        s = that.settings; // Call the parent constructor

    Base.call(this, el, settings, true);
    /**
     * Page initialization.
     */

    that._init = function () {
      var ctx = s.context,
          $ctx = $$1(ctx),
          $topMenu = $ctx.find('.mbsc-ms-top .mbsc-ms'),
          $bottomMenu = $ctx.find('.mbsc-ms-bottom .mbsc-ms'),
          css = {};

      if (ctx == 'body') {
        $$1('body,html').addClass('mbsc-page-ctx');
      } else {
        $ctx.addClass('mbsc-page-ctx');
      }

      if (cssClass) {
        $elm.removeClass(cssClass);
      }

      if ($topMenu.length) {
        css.paddingTop = $topMenu[0].offsetHeight;
      }

      if ($bottomMenu.length) {
        css.paddingBottom = $bottomMenu[0].offsetHeight;
      }

      cssClass = 'mbsc-page mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr');
      $elm.addClass(cssClass).removeClass('mbsc-cloak').css(css);
    };
    /**
     * Destroys the mobiscroll instance.
     */


    that._destroy = function () {
      $elm.removeClass(cssClass);
    }; // Constructor


    s = that.settings;
    that.init();
  }; // Extend defaults

  Page.prototype = {
    _hasDef: true,
    _hasTheme: true,
    _hasLang: true,
    _class: 'page',
    _defaults: {
      context: 'body'
    }
  };
  classes.Page = Page;
  mobiscroll.themes.page.mobiscroll = {}; // ---
  // Page end
  // Init mbsc-page elements on page load or when mbsc-enhance event is triggeres

  autoInit('[mbsc-page]', Page);

  var MbscPage = (function (_super) {
      __extends(MbscPage, _super);
      function MbscPage(hostElement, optionsService, zone) {
          var _this = _super.call(this, hostElement, zone) || this;
          _this.optionsService = optionsService;
          return _this;
      }
      MbscPage.prototype.ngOnInit = function () {
          var optionsObj = extend$1({}, this.options, this.inlineOptionsObj);
          this.optionsService.options = optionsObj;
      };
      MbscPage.prototype.initControl = function () {
          var options = extend$1({}, this.options, this.inlineOptionsObj);
          this.instance = new Page(this.initElem.nativeElement, options);
      };
      MbscPage.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-page',
                      template: '<div #initElement><ng-content></ng-content></div>',
                      providers: [MbscOptionsService],
                      exportAs: 'mobiscroll'
                  },] },
      ];
      MbscPage.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: MbscOptionsService, },
          { type: core.NgZone, },
      ]; };
      MbscPage.propDecorators = {
          'options': [{ type: core.Input },],
          'context': [{ type: core.Input },],
          'initElem': [{ type: core.ViewChild, args: ['initElement', { static: false },] },],
      };
      return MbscPage;
  }(MbscBase));
  var MbscNote = (function () {
      function MbscNote(initialElem) {
          this.initialElem = initialElem;
          this.color = 'primary';
      }
      Object.defineProperty(MbscNote.prototype, "classNames", {
          get: function () {
              return 'mbsc-note mbsc-note-' + this.color;
          },
          enumerable: true,
          configurable: true
      });
      MbscNote.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-note',
                      template: '<ng-content></ng-content>',
                      host: {
                          '[class]': 'classNames'
                      },
                      styles: [':host { display: block; }']
                  },] },
      ];
      MbscNote.ctorParameters = function () { return [
          { type: core.ElementRef, },
      ]; };
      MbscNote.propDecorators = {
          'color': [{ type: core.Input },],
      };
      return MbscNote;
  }());
  var MbscAvatar = (function () {
      function MbscAvatar() {
          this.draggable = false;
      }
      MbscAvatar.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-avatar',
                      template: '<img class="mbsc-avatar" [src]="src" [alt]="alt" [draggable]="draggable" />'
                  },] },
      ];
      MbscAvatar.ctorParameters = function () { return []; };
      MbscAvatar.propDecorators = {
          'draggable': [{ type: core.Input },],
          'src': [{ type: core.Input },],
          'alt': [{ type: core.Input },],
      };
      return MbscAvatar;
  }());
  var MbscPageModule = (function () {
      function MbscPageModule() {
      }
      MbscPageModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [MbscBaseModule],
                      declarations: [MbscPage, MbscNote, MbscAvatar],
                      exports: [MbscPage, MbscNote, MbscAvatar]
                  },] },
      ];
      MbscPageModule.ctorParameters = function () { return []; };
      return MbscPageModule;
  }());

  var MbscPopup = (function (_super) {
      __extends(MbscPopup, _super);
      function MbscPopup(initialElem, optionService, zone) {
          var _this = _super.call(this, initialElem, zone) || this;
          _this.optionService = optionService;
          _this.onBeforeClose = new core.EventEmitter();
          _this.onBeforeShow = new core.EventEmitter();
          _this.onCancel = new core.EventEmitter();
          _this.onClose = new core.EventEmitter();
          _this.onDestroy = new core.EventEmitter();
          _this.onFill = new core.EventEmitter();
          _this.onMarkupReady = new core.EventEmitter();
          _this.onPosition = new core.EventEmitter();
          _this.onShow = new core.EventEmitter();
          _this.onSet = new core.EventEmitter();
          return _this;
      }
      MbscPopup.prototype.ngAfterViewInit = function () {
          this.getInlineEvents();
          var options = extend$1({}, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj);
          this.instance = new Popup(this.initialElem.nativeElement, options);
      };
      MbscPopup.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-popup',
                      template: "<ng-content></ng-content>",
                      exportAs: 'mobiscroll',
                      host: { 'class': 'mbsc-cloak' }
                  },] },
      ];
      MbscPopup.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: core.NgZone, },
      ]; };
      MbscPopup.propDecorators = {
          'options': [{ type: core.Input, args: ['options',] },],
          'anchor': [{ type: core.Input },],
          'animate': [{ type: core.Input },],
          'buttons': [{ type: core.Input },],
          'closeOnOverlayTap': [{ type: core.Input },],
          'context': [{ type: core.Input },],
          'disabled': [{ type: core.Input },],
          'display': [{ type: core.Input },],
          'focusOnClose': [{ type: core.Input },],
          'focusTrap': [{ type: core.Input },],
          'headerText': [{ type: core.Input },],
          'showOnFocus': [{ type: core.Input },],
          'showOnTap': [{ type: core.Input },],
          'touchUi': [{ type: core.Input },],
          'okText': [{ type: core.Input },],
          'cancelText': [{ type: core.Input },],
          'onBeforeClose': [{ type: core.Output },],
          'onBeforeShow': [{ type: core.Output },],
          'onCancel': [{ type: core.Output },],
          'onClose': [{ type: core.Output },],
          'onDestroy': [{ type: core.Output },],
          'onFill': [{ type: core.Output },],
          'onMarkupReady': [{ type: core.Output },],
          'onPosition': [{ type: core.Output },],
          'onShow': [{ type: core.Output },],
          'onSet': [{ type: core.Output },],
      };
      return MbscPopup;
  }(MbscBase));
  var MbscWidget = (function (_super) {
      __extends(MbscWidget, _super);
      function MbscWidget() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      MbscWidget.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-widget',
                      template: "<ng-content></ng-content>",
                      exportAs: 'mobiscroll',
                      host: { 'class': 'mbsc-cloak' }
                  },] },
      ];
      MbscWidget.ctorParameters = function () { return []; };
      return MbscWidget;
  }(MbscPopup));
  var MbscPopupModule = (function () {
      function MbscPopupModule() {
      }
      MbscPopupModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [MbscBaseModule],
                      declarations: [MbscPopup, MbscWidget],
                      exports: [MbscPopup, MbscWidget]
                  },] },
      ];
      MbscPopupModule.ctorParameters = function () { return []; };
      return MbscPopupModule;
  }());

  var RangePicker = Scroller;
  var defaults$c = {
    autoCorrect: true,
    showSelector: true,
    minRange: 1,
    rangeTap: true
  };

  presets.range = function (inst) {
    // Private functions
    // ---
    function normalize(d, ref) {
      if (d) {
        d.setFullYear(ref.getFullYear());
        d.setMonth(ref.getMonth());
        d.setDate(ref.getDate());
      }
    }

    function normalizeTime(date, isEnd) {
      var o = inst._order,
          d = new Date(date);

      if (o.h === undefined) {
        d.setHours(isEnd ? 23 : 0);
      }

      if (o.i === undefined) {
        d.setMinutes(isEnd ? 59 : 0);
      }

      if (o.s === undefined) {
        d.setSeconds(isEnd ? 59 : 0);
      }

      d.setMilliseconds(isEnd ? 999 : 0);
      return d;
    }

    function updateInputs(change) {
      inst._startDate = startDate = tempStartDate;
      inst._endDate = endDate = tempEndDate;

      if (s.startInput) {
        $$1(s.startInput).val(inst.startVal);

        if (change) {
          $$1(s.startInput).trigger('change');
        }
      }

      if (s.endInput) {
        $$1(s.endInput).val(inst.endVal);

        if (change) {
          $$1(s.endInput).trigger('change');
        }
      }
    }

    function addDays(d, days) {
      return new Date(d.getFullYear(), d.getMonth(), d.getDate() + days);
    }

    function checkRangeSize(curr) {
      if (hasTime) {
        // Check exact times in milliseconds for min and max ranges
        if (tempEndDate - tempStartDate > s.maxRange - 1) {
          if (curr) {
            tempStartDate = new Date(Math.max(minDate, tempEndDate - s.maxRange + 1));
          } else {
            tempEndDate = new Date(Math.min(maxDate, +tempStartDate + s.maxRange - 1));
          }
        }

        if (tempEndDate - tempStartDate < s.minRange - 1) {
          if (curr) {
            tempStartDate = new Date(Math.max(minDate, tempEndDate - s.minRange + 1));
          } else {
            tempEndDate = new Date(Math.min(maxDate, +tempStartDate + s.minRange - 1));
          }
        }
      } else {
        // Work with days only, not milliseconds. This way daylight saving times are handled
        if (Math.ceil((tempEndDate - tempStartDate) / oneDay) > maxDays) {
          if (curr) {
            tempStartDate = normalizeTime(Math.max(minDate, addDays(tempEndDate, 1 - maxDays)), false);
          } else {
            tempEndDate = normalizeTime(Math.min(maxDate, addDays(tempStartDate, maxDays - 1)), true);
          }
        }

        if (Math.ceil((tempEndDate - tempStartDate) / oneDay) < minDays) {
          if (curr) {
            tempStartDate = normalizeTime(Math.max(minDate, addDays(tempEndDate, 1 - minDays)), false);
          } else {
            tempEndDate = normalizeTime(Math.min(maxDate, addDays(tempStartDate, minDays - 1)), true);
          }
        }
      }
    }

    function validate(dates, ui) {
      var ret = true;

      if (dates && tempStartDate && tempEndDate) {
        // We need to check this 2 times, because the
        // corrected range is constrained by min/max dates
        checkRangeSize(curr);
        checkRangeSize(!curr);
      }

      if (!tempStartDate || !tempEndDate) {
        ret = false;
      }

      if (ui) {
        highlightDays();
      }

      return ret;
    }

    function calcDayNr() {
      return tempStartDate && tempEndDate ? Math.max(1, Math.round((new Date(tempEndDate).setHours(0, 0, 0, 0) - new Date(tempStartDate).setHours(0, 0, 0, 0)) / 86400000) + 1) : 0;
    }

    function selectTab(tab) {
      tab.addClass(selectedClass).attr('aria-checked', 'true');
    }

    function setActiveTab() {
      if (showSelector && ctx) {
        $$1('.mbsc-range-btn', ctx).removeClass(selectedClass).removeAttr('aria-checked');
        selectTab($$1('.mbsc-range-btn', ctx).eq(curr));
      }
    }

    function highlightDays() {
      var start,
          startT,
          end,
          endT,
          hl,
          nr = 0,
          startClass = autoChange || !curr ? ' mbsc-cal-day-hl mbsc-cal-sel-start' : ' mbsc-cal-sel-start',
          endClass = autoChange || curr ? ' mbsc-cal-day-hl mbsc-cal-sel-end' : ' mbsc-cal-sel-end';
      inst.startVal = tempStartDate ? formatDate(format, tempStartDate, s) : '';
      inst.endVal = tempEndDate ? formatDate(format, tempEndDate, s) : '';

      if (ctx) {
        $$1('.mbsc-range-btn-v-start', ctx).html(inst.startVal || '&nbsp;');
        $$1('.mbsc-range-btn-v-end', ctx).html(inst.endVal || '&nbsp;'); // Highlight dates

        start = tempStartDate ? new Date(tempStartDate) : null;
        end = tempEndDate ? new Date(tempEndDate) : null;

        if (!start && end) {
          start = new Date(end);
        }

        if (!end && start) {
          end = new Date(start);
        }

        hl = curr ? end : start;
        $$1('.mbsc-cal-day-picker .mbsc-cal-day-hl', ctx).removeClass(highlightClass);
        $$1('.mbsc-cal-day-picker .mbsc-selected', ctx).removeClass('mbsc-cal-sel-start mbsc-cal-sel-end ' + selectedClass).removeAttr('aria-selected');

        if (start && end) {
          startT = start.setHours(0, 0, 0, 0);
          endT = end.setHours(0, 0, 0, 0);

          while (end >= start && nr < 126) {
            $$1('.mbsc-cal-day[data-full="' + hl.getFullYear() + '-' + (hl.getMonth() + 1) + '-' + hl.getDate() + '"]', ctx).addClass(selectedClass + ' ' + (hl.getTime() === startT ? startClass : '') + (hl.getTime() === endT ? endClass : '')).attr('aria-selected', 'true');
            hl.setDate(hl.getDate() + (curr ? -1 : 1));
            hl.setHours(0, 0, 0, 0);
            nr++;
          }
        }
      }
    }

    function setTimeInfo(d, end) {
      return {
        h: d ? d.getHours() : end ? 23 : 0,
        i: d ? d.getMinutes() : end ? 59 : 0,
        s: d ? d.getSeconds() : end ? 59 : 0
      };
    }

    function validateDates() {
      if (tempStartDate) {
        init = true;
        inst.setDate(tempStartDate, false, 0, true);
        tempStartDate = inst.getDate(true);
      }

      if (tempEndDate) {
        init = true;
        inst.setDate(tempEndDate, false, 0, true);
        tempEndDate = inst.getDate(true);
      }
    }

    function onBtnClick(ev) {
      if (testTouch(ev, this)) {
        inst._showDayPicker();

        inst.setActiveDate($$1(this).attr('data-select'));
      }
    } // ---


    var base,
        ctx,
        dayChange,
        format,
        hasTime,
        init,
        maxDate,
        minDate,
        set,
        tempStartDate,
        tempStartTime,
        tempEndDate,
        tempEndTime,
        timeOnly,
        showSelector,
        startDate = inst._startDate,
        endDate = inst._endDate,
        curr = 0,
        now = new Date(),
        orig = extend$1({}, inst.settings),
        s = extend$1(inst.settings, defaults$c, orig),
        startAnchor = s.anchor,
        autoChange = s.rangeTap,
        oneDay = 24 * 60 * 60 * 1000,
        minDays = Math.max(1, Math.ceil(s.minRange / oneDay)),
        maxDays = Math.max(1, Math.ceil(s.maxRange / oneDay)),
        disabledClass = 'mbsc-disabled ' + (s.disabledClass || ''),
        selectedClass = 'mbsc-selected ' + (s.selectedClass || ''),
        highlightClass = 'mbsc-cal-day-hl',
        def = s.defaultValue === null ? [] : s.defaultValue || [new Date(now.setHours(0, 0, 0, 0)), new Date(now.getFullYear(), now.getMonth(), now.getDate() + 6, 23, 59, 59, 999)];

    if (autoChange) {
      s.tabs = true;
    }

    base = CalendarBase.call(this, inst);
    format = inst._format;
    hasTime = /time/i.test(s.controls.join(','));
    timeOnly = s.controls.join('') === 'time';
    showSelector = s.showSelector;
    maxDate = s.max ? normalizeTime(makeDate(s.max, format, s), true) : Infinity;
    minDate = s.min ? normalizeTime(makeDate(s.min, format, s), false) : -Infinity;
    def[0] = makeDate(def[0], format, s, s.isoParts);
    def[1] = makeDate(def[1], format, s, s.isoParts);

    if (s.startInput) {
      inst.attachShow($$1(s.startInput), function () {
        curr = 0;
        s.anchor = startAnchor || $$1(s.startInput);
      });
    }

    if (s.endInput) {
      inst.attachShow($$1(s.endInput), function () {
        curr = 1;
        s.anchor = startAnchor || $$1(s.endInput);
      });
    }

    inst._getDayProps = function (d, props) {
      var start = tempStartDate ? new Date(tempStartDate.getFullYear(), tempStartDate.getMonth(), tempStartDate.getDate()) : null,
          end = tempEndDate ? new Date(tempEndDate.getFullYear(), tempEndDate.getMonth(), tempEndDate.getDate()) : null;
      return {
        selected: start && end && d >= start && d <= tempEndDate,
        cssClass: props.cssClass + ' ' + ((autoChange || !curr) && start && start.getTime() === d.getTime() || (autoChange || curr) && end && end.getTime() === d.getTime() ? highlightClass : '') + (start && start.getTime() === d.getTime() ? ' mbsc-cal-sel-start' : '') + (end && end.getTime() === d.getTime() ? ' mbsc-cal-sel-end' : '')
      };
    }; // Extended methods
    // ---


    inst.setVal = function (values, fill, change, temp, time) {
      var v = values || [],
          d = values;
      tempStartDate = makeDate(v[0], format, s, s.isoParts);
      tempEndDate = makeDate(v[1], format, s, s.isoParts);
      validateDates();
      inst.startVal = tempStartDate ? formatDate(format, tempStartDate, s) : '';
      inst.endVal = tempEndDate ? formatDate(format, tempEndDate, s) : '';
      d = base.parseValue(curr ? tempEndDate : tempStartDate, inst);

      if (!temp) {
        inst._startDate = startDate = tempStartDate;
        inst._endDate = endDate = tempEndDate;
      }

      set = true;

      inst._setVal(d, fill, change, temp, time);
    };

    inst.getVal = function (temp) {
      return temp ? [returnDate(tempStartDate, s, format), returnDate(tempEndDate, s, format)] : inst._hasValue ? [returnDate(startDate, s, format), returnDate(endDate, s, format)] : null;
    };

    inst.setActiveDate = function (active) {
      var hl; //if (!autoChange) {

      curr = active == 'start' ? 0 : 1; //}

      hl = active == 'start' ? tempStartDate : tempEndDate;

      if (inst.isVisible()) {
        //if (!autoChange) {
        setActiveTab();

        if (!autoChange) {
          $$1('.mbsc-cal-table .mbsc-cal-day-hl', ctx).removeClass(highlightClass);

          if (hl) {
            $$1('.mbsc-cal-day[data-full="' + hl.getFullYear() + '-' + (hl.getMonth() + 1) + '-' + hl.getDate() + '"]', ctx).addClass(highlightClass);
          }
        }

        if (hl) {
          init = true;
          inst.setDate(hl, false, 1000, true);
        }
      }
    };

    inst.getValue = inst.getVal; // ---
    // ---

    return extend$1({}, base, {
      highlight: false,
      outerMonthChange: false,
      formatValue: function formatValue() {
        return inst.startVal + (s.endInput ? '' : inst.endVal ? ' - ' + inst.endVal : '');
      },
      parseValue: function parseValue(v) {
        var parts = v ? v.split(' - ') : [],
            startVal = s.startInput ? $$1(s.startInput).val() : parts[0],
            endVal = s.endInput ? $$1(s.endInput).val() : parts[1];
        s.defaultValue = def[1]; // used by parseDate

        endDate = endVal ? parseDate(format, endVal, s) : def[1];
        s.defaultValue = def[0]; // used by parseDate

        startDate = startVal ? parseDate(format, startVal, s) : def[2];
        s.defaultValue = def[curr];
        inst.startVal = startDate ? formatDate(format, startDate, s) : '';
        inst.endVal = endDate ? formatDate(format, endDate, s) : '';
        inst._startDate = startDate;
        inst._endDate = endDate;
        return base.parseValue(curr ? endDate : startDate, inst);
      },
      onFill: function onFill(ev) {
        updateInputs(ev.change);
      },
      onBeforeClose: function onBeforeClose(ev) {
        // Don't allow invalid selection
        if (ev.button === 'set' && !validate(true, true)) {
          inst.setActiveDate(curr ? 'start' : 'end');
          return false;
        }
      },
      onHide: function onHide() {
        base.onHide.call(inst);
        curr = 0;
        ctx = null;
        s.anchor = startAnchor;
      },
      onClear: function onClear() {
        if (autoChange) {
          curr = 0;
        }
      },
      onBeforeShow: function onBeforeShow() {
        tempStartDate = startDate || def[0];
        tempEndDate = endDate || def[1];
        tempStartTime = setTimeInfo(tempStartDate, 0);
        tempEndTime = setTimeInfo(tempEndDate, 1);

        if (s.counter) {
          s.headerText = function () {
            var nr = calcDayNr();
            return (nr > 1 ? s.selectedPluralText || s.selectedText : s.selectedText).replace(/{count}/, nr);
          };
        }

        set = true;
      },
      onMarkupReady: function onMarkupReady(ev) {
        var html; // Validate start end end dates

        validateDates(); // Set the current date (start or end)

        if (curr && tempEndDate || !curr && tempStartDate) {
          init = true;
          inst.setDate(curr ? tempEndDate : tempStartDate, false, 0, true);
        }

        highlightDays(); // Call calbase

        base.onMarkupReady.call(this, ev);
        ctx = $$1(ev.target);
        ctx.addClass('mbsc-range');

        if (showSelector) {
          html = '<div class="mbsc-range-btn-t" role="radiogroup">' + '<div class="mbsc-range-btn-c mbsc-range-btn-start"><div role="radio" data-select="start" class="mbsc-fr-btn-e mbsc-fr-btn-nhl mbsc-range-btn">' + s.fromText + '<div class="mbsc-range-btn-v mbsc-range-btn-v-start">' + (inst.startVal || '&nbsp;') + '</div></div></div>' + '<div class="mbsc-range-btn-c mbsc-range-btn-end"><div role="radio" data-select="end" class="mbsc-fr-btn-e mbsc-fr-btn-nhl mbsc-range-btn">' + s.toText + '<div class="mbsc-range-btn-v mbsc-range-btn-v-end">' + (inst.endVal || '&nbsp;') + '</div></div></div>' + '</div>';

          if (s.headerText) {
            $$1('.mbsc-fr-hdr', ctx).after(html);
          } else {
            $$1('.mbsc-fr-w', ctx).prepend(html);
          }

          setActiveTab();
        }

        $$1('.mbsc-range-btn', ctx).each(function (i, el) {
          listen(el, 'touchstart', onBtnClick, {
            passive: true
          });
          listen(el, 'click', onBtnClick);
        });
      },
      onDayChange: function onDayChange(day) {
        day.active = curr ? 'end' : 'start';
        dayChange = true;
      },
      onSetDate: function onSetDate(day) {
        var d;

        if (!init) {
          d = normalizeTime(day.date, curr);

          if (!set || dayChange) {
            if (autoChange && dayChange) {
              if (curr == 1 && d < tempStartDate) {
                curr = 0;
              }

              if (curr) {
                d.setHours(tempEndTime.h, tempEndTime.i, tempEndTime.s, 999);
              } else {
                d.setHours(tempStartTime.h, tempStartTime.i, tempStartTime.s, 0);
              }
            }

            if (curr) {
              tempEndDate = new Date(d);
              tempEndTime = setTimeInfo(tempEndDate);
            } else {
              tempStartDate = new Date(d);
              tempStartTime = setTimeInfo(tempStartDate);
            } // Make sure times are on the same day for comparison


            if (timeOnly && s.autoCorrect) {
              normalize(tempStartDate, d);
              normalize(tempEndDate, d);
            } // Set end date on start selection if rangeTap is enabled


            if (autoChange && dayChange && !curr) {
              //tempEndDate = new Date(d.setHours(23, 59, 59, 999));
              tempEndDate = null;
            }
          }
        }

        if (timeOnly && !s.autoCorrect && tempEndDate < tempStartDate) {
          // Set end time to next day
          tempEndDate = new Date(tempEndDate.setDate(tempEndDate.getDate() + 1));
        } // Validate min/max ranges


        inst._isValid = validate(set || dayChange || s.autoCorrect, !init);
        day.active = curr ? 'end' : 'start'; // Toggle start/end if rangeTap is enabled

        if (!init && autoChange) {
          if (dayChange) {
            curr = curr ? 0 : 1;
          }

          setActiveTab();
        }

        if (inst.isVisible()) {
          // Disable set button
          if (inst._isValid) {
            $$1('.mbsc-fr-btn-s .mbsc-fr-btn', inst._markup).removeClass(disabledClass);
          } else {
            $$1('.mbsc-fr-btn-s .mbsc-fr-btn', inst._markup).addClass(disabledClass);
          }
        }

        dayChange = false;
        set = false;
        init = false;
      },
      onTabChange: function onTabChange(ev) {
        if (ev.tab != 'calendar') {
          inst.setDate(curr ? tempEndDate : tempStartDate, false, 1000, true);
        }

        validate(true, true);
      }
    });
  };

  var RANGE_SUB_TEMPLATE = "<mbsc-input\n    [controlNg]=\"false\" [name]=\"name\" [theme]=\"theme\" [disabled]=\"disabled\" [placeholder]=\"placeholder\"\n    [error]=\"error\" [errorMessage]=\"errorMessage\" \n    [icon]=\"inputIcon\" [icon-align]=\"iconAlign\">\n    <ng-content></ng-content>\n</mbsc-input>";
  var MbscRangeStartComponent = (function () {
      function MbscRangeStartComponent(host, parent, zone, control) {
          this.host = host;
          this.parent = parent;
          this.zone = zone;
          this.control = control;
          this.theme = undefined;
          this.errorMessage = '';
          this.placeholder = '';
          this.rangeIndex = 0;
          this.oldAccessor = null;
          this.onChange = function (value) { };
          this.onTouch = function () { };
          this.initialSet = true;
          this.checkAccessor();
      }
      Object.defineProperty(MbscRangeStartComponent.prototype, "element", {
          get: function () {
              var i = $$1(this.host.nativeElement).find('input');
              return i[0];
          },
          enumerable: true,
          configurable: true
      });
      MbscRangeStartComponent.prototype.checkAccessor = function () {
          if (this.control) {
              if (this.control.valueAccessor !== this) {
                  this.oldAccessor = this.control.valueAccessor;
              }
              this.control.valueAccessor = this;
          }
      };
      MbscRangeStartComponent.prototype.handleChange = function () {
          var _this = this;
          $$1(this.element).on('change', function () {
              _this.zone.run(function () {
                  var arr = _this.parent.instance.getVal(), value = arr ? arr[_this.rangeIndex] : undefined, current = undefined, valueText = _this.parent.instance[_this.rangeIndex === 0 ? 'startVal' : 'endVal'];
                  if (arr && value && _this.element.value !== valueText && _this.parent.enableManualEdit) {
                      var newArr = new Array(2), otherIndex = _this.rangeIndex === 1 ? 0 : 1;
                      newArr[_this.rangeIndex] = _this.element.value;
                      newArr[otherIndex] = arr[otherIndex];
                      _this.parent.instance.setVal(newArr, true, true);
                  }
                  else {
                      if (_this.control && _this.control.value && _this.control.value instanceof Array) {
                          current = _this.control.value[_this.rangeIndex];
                      }
                      else if (_this.control && _this.control.value) {
                          current = _this.control.value;
                      }
                      if (_this.control) {
                          if (!isDateEqual(current, value)) {
                              _this.onChange(value);
                              _this.control.control.patchValue(value);
                          }
                      }
                  }
              });
          });
      };
      MbscRangeStartComponent.prototype.ngAfterViewInit = function () {
          this.handleChange();
          this.checkAccessor();
      };
      MbscRangeStartComponent.prototype.registerOnChange = function (fn) {
          this.onChange = fn;
      };
      MbscRangeStartComponent.prototype.registerOnTouched = function (fn) {
          this.onTouch = fn;
      };
      MbscRangeStartComponent.prototype.setDisabledState = function (isDisabled) {
          this.disabled = isDisabled;
          if (this.oldAccessor && this.oldAccessor.setDisabledState) {
              this.oldAccessor.setDisabledState(isDisabled);
          }
      };
      MbscRangeStartComponent.prototype.writeValue = function (v) {
          var _this = this;
          if (this.parent && this.parent.instance) {
              var arr_1 = this.parent.instance.getVal(), val = (arr_1 && arr_1.length) ? arr_1[this.rangeIndex] : undefined;
              if (!isDateEqual(v, val)) {
                  if (v === undefined) {
                      arr_1 = undefined;
                  }
                  else {
                      arr_1 = arr_1 || [];
                      arr_1[this.rangeIndex] = v;
                  }
                  this.parent.instance.setVal(arr_1, true, false);
                  if (this.initialSet) {
                      setTimeout(function () {
                          _this.parent.instance.setVal(arr_1, true, false);
                          _this.initialSet = false;
                      });
                  }
              }
          }
      };
      MbscRangeStartComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-range-start',
                      template: RANGE_SUB_TEMPLATE
                  },] },
      ];
      MbscRangeStartComponent.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: MbscRangeComponent, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return MbscRangeComponent; }),] },] },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
      ]; };
      MbscRangeStartComponent.propDecorators = {
          'inputIcon': [{ type: core.Input, args: ['icon',] },],
          'iconAlign': [{ type: core.Input, args: ['icon-align',] },],
          'name': [{ type: core.Input },],
          'error': [{ type: core.Input },],
          'errorMessage': [{ type: core.Input },],
          'disabled': [{ type: core.Input },],
          'placeholder': [{ type: core.Input },],
      };
      return MbscRangeStartComponent;
  }());
  var MbscRangeEndComponent = (function (_super) {
      __extends(MbscRangeEndComponent, _super);
      function MbscRangeEndComponent(el, parent, zone, control) {
          var _this = _super.call(this, el, parent, zone, control) || this;
          _this.rangeIndex = 1;
          return _this;
      }
      MbscRangeEndComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-range-end',
                      template: RANGE_SUB_TEMPLATE,
                  },] },
      ];
      MbscRangeEndComponent.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: MbscRangeComponent, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return MbscRangeComponent; }),] },] },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
      ]; };
      return MbscRangeEndComponent;
  }(MbscRangeStartComponent));
  var MbscRange = (function (_super) {
      __extends(MbscRange, _super);
      function MbscRange(initialElem, zone, control, inputService, optionService, view) {
          var _this = _super.call(this, initialElem, zone, control, inputService, view) || this;
          _this.optionService = optionService;
          _this.onSetDate = new core.EventEmitter();
          _this.onCellHoverIn = new core.EventEmitter();
          _this.onCellHoverOut = new core.EventEmitter();
          _this.onDayChange = new core.EventEmitter();
          _this.options = {};
          _this.onChangeEmitter = new core.EventEmitter();
          return _this;
      }
      Object.defineProperty(MbscRange.prototype, "endInput", {
          set: function (v) {
              var element = v;
              if (typeof v == "string") {
                  var hasInput = $$1(v).find('input');
                  if (hasInput.length) {
                      element = hasInput[0];
                  }
              }
              this._endInput = element;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MbscRange.prototype, "startInput", {
          set: function (v) {
              var element = v;
              if (typeof v == "string") {
                  var hasInput = $$1(v).find('input');
                  if (hasInput.length) {
                      element = hasInput[0];
                  }
              }
              this._startInput = element;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MbscRange.prototype, "value", {
          set: function (v) {
              this.setNewValueProxy(v);
          },
          enumerable: true,
          configurable: true
      });
      MbscRange.prototype.setNewValue = function (v) {
          if (this.instance) {
              if (!deepEqualsArray(v, this.instance.getVal())) {
                  this.instance.setVal(v, true, false);
                  if (this._inputService && this._inputService.input) {
                      this._inputService.input.innerValue = this.instance._value;
                  }
              }
          }
      };
      Object.defineProperty(MbscRange.prototype, "optionExtensions", {
          get: function () {
              var _this = this;
              var externalOnClose = this.options && this.options.onClose;
              var externalOnFill = this.options && this.options.onFill;
              var onCloseEmitter = this.onClose;
              return {
                  onFill: function (event, inst) {
                      if (!_this._wrapper) {
                          if (_this.oldAccessor) {
                              _this.oldAccessor.writeValue(event.valueText);
                          }
                      }
                      if (externalOnFill) {
                          externalOnFill(event, inst);
                      }
                  },
                  onClose: function (event, inst) {
                      _this.onTouch();
                      if (externalOnClose) {
                          externalOnClose(event, inst);
                      }
                      if (onCloseEmitter) {
                          event.inst = inst;
                          onCloseEmitter.emit(event);
                      }
                  }
              };
          },
          enumerable: true,
          configurable: true
      });
      MbscRange.prototype.initControl = function () {
          var options = extend$1({
              preset: 'range',
              skipShow: this._wrapper
          }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, {
              endInput: this._wrapper ? this.end.element : this._endInput,
              startInput: this._wrapper ? this.start.element : this._startInput
          }, this.optionExtensions);
          this.instance = new RangePicker(this._wrapper ? this.initialElem.nativeElement : this.element, options);
          if (this.initialValue) {
              this.instance.setVal(this.initialValue, true, false);
          }
      };
      MbscRange.prototype.ngAfterContentInit = function () {
          if (this.start || this.end) {
              this._wrapper = true;
          }
          else {
              this._wrapper = false;
          }
      };
      MbscRange.prototype.handleChange = function () {
          var _this = this;
          if (this._wrapper) {
              $$1(this.start.element).on('change', function () {
                  _this.zone.run(function () {
                      var value = _this.instance.getVal();
                      if (_this.control) {
                          if (!deepEqualsArray(_this.control.value, value)) {
                              _this.onChange(value);
                              _this.control.control.patchValue(value);
                          }
                      }
                      else {
                          _this.onChangeEmitter.emit(value);
                      }
                  });
              });
              $$1(this.end.element).on('change', function () {
                  _this.zone.run(function () {
                      var value = _this.instance.getVal();
                      if (_this.control) {
                          if (!deepEqualsArray(_this.control.value, value)) {
                              _this.onChange(value);
                              _this.control.control.patchValue(value);
                          }
                      }
                      else {
                          _this.onChangeEmitter.emit(value);
                      }
                  });
              });
          }
          else {
              var that_1 = this;
              $$1(this.element).on('change', function () {
                  that_1.zone.run(function () {
                      if (that_1.element.value !== that_1.instance._value && that_1.enableManualEdit) {
                          var v = that_1.element.value && that_1.element.value.split(' - ');
                          if (v) {
                              that_1.instance.setVal(v, true, true);
                          }
                      }
                      else {
                          var value = that_1.instance.getVal();
                          if (that_1.control) {
                              that_1.onChange(value);
                              that_1.control.control.patchValue(value);
                          }
                          else {
                              that_1.onChangeEmitter.emit(value);
                          }
                      }
                  });
              });
          }
      };
      MbscRange.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mbsc-range]',
                      exportAs: 'mobiscroll'
                  },] },
      ];
      MbscRange.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: core.ViewContainerRef, },
      ]; };
      MbscRange.propDecorators = {
          'autoCorrect': [{ type: core.Input },],
          'controls': [{ type: core.Input },],
          'endInput': [{ type: core.Input },],
          'maxRange': [{ type: core.Input },],
          'minRange': [{ type: core.Input },],
          'showSelector': [{ type: core.Input },],
          'startInput': [{ type: core.Input },],
          'fromText': [{ type: core.Input },],
          'toText': [{ type: core.Input },],
          'onSetDate': [{ type: core.Output },],
          'onCellHoverIn': [{ type: core.Output },],
          'onCellHoverOut': [{ type: core.Output },],
          'onDayChange': [{ type: core.Output },],
          'start': [{ type: core.ContentChild, args: [MbscRangeStartComponent, { static: false },] },],
          'end': [{ type: core.ContentChild, args: [MbscRangeEndComponent, { static: false },] },],
          'options': [{ type: core.Input, args: ['mbsc-options',] },],
          'value': [{ type: core.Input, args: ['mbsc-range',] },],
          'onChangeEmitter': [{ type: core.Output, args: ['mbsc-rangeChange',] },],
      };
      return MbscRange;
  }(MbscCalBase));
  var MbscRangeComponent = (function (_super) {
      __extends(MbscRangeComponent, _super);
      function MbscRangeComponent(initialElem, zone, control, inputService, optionService) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
          _this.errorMessage = '';
          _this.placeholder = '';
          return _this;
      }
      MbscRangeComponent.prototype.ngAfterViewInit = function () {
          _super.prototype.ngAfterViewInit.call(this);
          this.setThemeClasses();
      };
      MbscRangeComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-range',
                      exportAs: 'mobiscroll',
                      template: "<ng-content select=\"mbsc-range-start\"></ng-content>\n    <ng-content select=\"mbsc-range-end\"></ng-content>\n    <mbsc-input *ngIf=\"!_wrapper && (!inline || showInput)\" \n        [controlNg]=\"false\" [name]=\"name\" [theme]=\"theme\" [disabled]=\"disabled\" [dropdown]=\"dropdown\" [placeholder]=\"placeholder\"\n        [error]=\"error\" [errorMessage]=\"errorMessage\" \n        [icon]=\"inputIcon\" [icon-align]=\"iconAlign\">\n        <ng-content></ng-content>\n    </mbsc-input>",
                  },] },
      ];
      MbscRangeComponent.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscRangeComponent.propDecorators = {
          'inputIcon': [{ type: core.Input, args: ['icon',] },],
          'iconAlign': [{ type: core.Input, args: ['icon-align',] },],
          'name': [{ type: core.Input },],
          'error': [{ type: core.Input },],
          'errorMessage': [{ type: core.Input },],
          'options': [{ type: core.Input },],
          'placeholder': [{ type: core.Input },],
      };
      return MbscRangeComponent;
  }(MbscRange));
  var MbscRangeModule = (function () {
      function MbscRangeModule() {
      }
      MbscRangeModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule, MbscCalBaseModule, MbscInputModule],
                      declarations: [MbscRangeStartComponent, MbscRangeEndComponent, MbscRange, MbscRangeComponent],
                      exports: [MbscRangeStartComponent, MbscRangeEndComponent, MbscRange, MbscRangeComponent]
                  },] },
      ];
      MbscRangeModule.ctorParameters = function () { return []; };
      return MbscRangeModule;
  }());

  var MbscScroller = (function (_super) {
      __extends(MbscScroller, _super);
      function MbscScroller(initialElement, zone, control, inputService, optionService, view) {
          var _this = _super.call(this, initialElement, zone, control, inputService, view) || this;
          _this.optionService = optionService;
          _this.options = {};
          _this.onChangeEmitter = new core.EventEmitter();
          return _this;
      }
      Object.defineProperty(MbscScroller.prototype, "value", {
          set: function (v) {
              this.setNewValueProxy(v);
          },
          enumerable: true,
          configurable: true
      });
      MbscScroller.prototype.setNewValue = function (v) {
          if (this.instance) {
              var innerValue = this.instance.getVal();
              if (innerValue !== v) {
                  this.instance.setVal(v, true, false);
                  if (this._inputService && this._inputService.input) {
                      this._inputService.input.innerValue = this.instance._value;
                  }
              }
          }
      };
      MbscScroller.prototype.initControl = function () {
          var options = extend$1({}, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
          this.instance = new Scroller(this.element, options);
          if (this.initialValue !== undefined) {
              this.instance.setVal(this.initialValue, true, false);
          }
      };
      MbscScroller.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mbsc-scroller]',
                      exportAs: 'mobiscroll'
                  },] },
      ];
      MbscScroller.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: core.ViewContainerRef, },
      ]; };
      MbscScroller.propDecorators = {
          'options': [{ type: core.Input, args: ['mbsc-options',] },],
          'value': [{ type: core.Input, args: ['mbsc-scroller',] },],
          'onChangeEmitter': [{ type: core.Output, args: ['mbsc-scrollerChange',] },],
      };
      return MbscScroller;
  }(MbscScrollerBase));
  var MbscScrollerComponent = (function (_super) {
      __extends(MbscScrollerComponent, _super);
      function MbscScrollerComponent(initialElem, zone, control, inputService, optionService) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
          _this.errorMessage = '';
          _this.placeholder = '';
          return _this;
      }
      MbscScrollerComponent.prototype.ngAfterViewInit = function () {
          _super.prototype.ngAfterViewInit.call(this);
          this.setThemeClasses();
      };
      MbscScrollerComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-scroller',
                      exportAs: 'mobiscroll',
                      template: INPUT_TEMPLATE
                  },] },
      ];
      MbscScrollerComponent.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscScrollerComponent.propDecorators = {
          'inputIcon': [{ type: core.Input, args: ['icon',] },],
          'iconAlign': [{ type: core.Input, args: ['icon-align',] },],
          'name': [{ type: core.Input },],
          'error': [{ type: core.Input },],
          'errorMessage': [{ type: core.Input },],
          'options': [{ type: core.Input },],
          'placeholder': [{ type: core.Input },],
      };
      return MbscScrollerComponent;
  }(MbscScroller));
  var MbscScrollerModule = (function () {
      function MbscScrollerModule() {
      }
      MbscScrollerModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule, MbscScrollerBaseModule, MbscInputModule],
                      declarations: [MbscScroller, MbscScrollerComponent],
                      exports: [MbscScroller, MbscScrollerComponent]
                  },] },
      ];
      MbscScrollerModule.ctorParameters = function () { return []; };
      return MbscScrollerModule;
  }());

  var MbscScrollView = (function (_super) {
      __extends(MbscScrollView, _super);
      function MbscScrollView(initialElem, zone, notifyItemService, optionService) {
          var _this = _super.call(this, initialElem, zone, notifyItemService) || this;
          _this.optionService = optionService;
          return _this;
      }
      MbscScrollView.prototype.initControl = function () {
          var _this = this;
          var options = extend$1({}, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj);
          this.instance = new ScrollView(this.initialElem.nativeElement, options);
          this.notifyItemService.notifyInstanceReady(this.instance);
          this.addRemoveObserver = this.notifyItemService.onAddRemove().subscribe(function (item) {
              _this.instance.refresh();
          });
      };
      MbscScrollView.prototype.ngOnDestroy = function () {
          this.notifyItemService.onAddRemove().unsubscribe(this.addRemoveObserver);
          _super.prototype.ngOnDestroy.call(this);
      };
      MbscScrollView.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mbsc-scrollview]',
                      exportAs: 'mobiscroll',
                      providers: [MbscNotifyItemService],
                      host: { 'class': 'mbsc-cloak' }
                  },] },
      ];
      MbscScrollView.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: MbscNotifyItemService, },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscScrollView.propDecorators = {
          'options': [{ type: core.Input, args: ['mbsc-options',] },],
      };
      return MbscScrollView;
  }(MbscScrollViewBase));
  var MbscScrollViewItem = (function (_super) {
      __extends(MbscScrollViewItem, _super);
      function MbscScrollViewItem(initialElem, notifyItemService) {
          return _super.call(this, notifyItemService, initialElem) || this;
      }
      MbscScrollViewItem.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mbsc-scrollview-item]',
                      host: {
                          '[attr.data-id]': 'id'
                      }
                  },] },
      ];
      MbscScrollViewItem.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: MbscNotifyItemService, },
      ]; };
      return MbscScrollViewItem;
  }(MbscScrollItemBase));
  var MbscScrollViewComponent = (function (_super) {
      __extends(MbscScrollViewComponent, _super);
      function MbscScrollViewComponent(initialElem, zone, notifyItemService, optionService) {
          return _super.call(this, initialElem, zone, notifyItemService, optionService) || this;
      }
      MbscScrollViewComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-scrollview',
                      exportAs: 'mobiscroll',
                      template: "<ng-content></ng-content>",
                      providers: [MbscNotifyItemService]
                  },] },
      ];
      MbscScrollViewComponent.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: MbscNotifyItemService, },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscScrollViewComponent.propDecorators = {
          'options': [{ type: core.Input, args: ['options',] },],
      };
      return MbscScrollViewComponent;
  }(MbscScrollView));
  var MbscScrollViewItemComponent = (function (_super) {
      __extends(MbscScrollViewItemComponent, _super);
      function MbscScrollViewItemComponent(initialElem, notifyItemService) {
          return _super.call(this, initialElem, notifyItemService) || this;
      }
      MbscScrollViewItemComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-scrollview-item',
                      template: '<ng-content></ng-content>',
                      host: {
                          '[attr.data-id]': 'id'
                      }
                  },] },
      ];
      MbscScrollViewItemComponent.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: MbscNotifyItemService, },
      ]; };
      return MbscScrollViewItemComponent;
  }(MbscScrollViewItem));
  var MbscScrollViewModule = (function () {
      function MbscScrollViewModule() {
      }
      MbscScrollViewModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [MbscScrollViewBaseModule],
                      declarations: [MbscScrollView, MbscScrollViewComponent, MbscScrollViewItem, MbscScrollViewItemComponent],
                      exports: [MbscScrollView, MbscScrollViewComponent, MbscScrollViewItem, MbscScrollViewItemComponent]
                  },] },
      ];
      MbscScrollViewModule.ctorParameters = function () { return []; };
      return MbscScrollViewModule;
  }());

  var Select$1 = Scroller;
  var defaults$d = {
    inputClass: '',
    rtl: false,
    showInput: true,
    groupLabel: 'Groups',
    dataHtml: 'html',
    dataText: 'text',
    dataValue: 'value',
    dataGroup: 'group',
    dataDisabled: 'disabled',
    filterPlaceholderText: 'Type to filter',
    filterEmptyText: 'No results',
    filterClearIcon: 'material-close'
  };

  presets.select = function (inst, settings) {
    var $input,
        dataArray,
        filterLength,
        filterText,
        group,
        groupArray,
        groupWheel,
        groups,
        groupWheelIdx,
        hasRemoteData,
        option,
        optionArray,
        optionWheel,
        optionWheelIdx,
        prevent,
        defaultValue = '',
        selectedTexts = {},
        animTime = 1000,
        elm = this,
        $elm = $$1(elm),
        orig = extend$1({}, inst.settings),
        s = extend$1(inst.settings, defaults$d, orig),
        $filterEmpty = $$1('<div class="mbsc-sel-empty">' + s.filterEmptyText + '</div>'),
        origReadOnly = s.readonly,
        options = {},
        layout = s.layout || (/top|bottom|inline/.test(s.display) || s.filter ? 'liquid' : ''),
        isLiquid = layout == 'liquid' || !s.touchUi,
        multiple = isNumeric(s.select) ? s.select : s.select == 'multiple' || $elm.prop('multiple'),
        tapSelect = multiple || (s.filter || s.tapSelect ? 1 : false),
        id = this.id + '_dummy',
        lbl = $$1('label[for="' + this.id + '"]').attr('for', id),
        label = s.label !== undefined ? s.label : lbl.length ? lbl.text() : $elm.attr('name'),
        groupSetup = s.group,
        hasData = !!s.data,
        hasGroups = hasData ? !!s.group : $$1('optgroup', $elm).length,
        hasGroupWheel = hasGroups && groupSetup && groupSetup.groupWheel !== false,
        groupSep = hasGroups && groupSetup && hasGroupWheel && groupSetup.clustered === true,
        groupHdr = hasGroups && (!groupSetup || groupSetup.header !== false && !groupSep),
        values = $elm.val() || (multiple ? [] : ['']),
        invalid = [];

    function prepareData(filter) {
      var gr,
          html,
          lbl,
          opt,
          txt,
          val,
          l = 0,
          c = 0,
          groupIndexes = {};
      options = {};
      groups = {};
      optionArray = [];
      groupArray = []; // Reset invalids

      invalid.length = 0;

      if (hasData) {
        $$1.each(dataArray, function (i, v) {
          txt = v[s.dataText] + ''; // Convert to string

          html = v[s.dataHtml];
          val = v[s.dataValue];
          lbl = v[s.dataGroup];
          opt = {
            value: val,
            html: html,
            text: txt,
            index: i,
            cssClass: groupHdr ? 'mbsc-sel-gr-itm' : ''
          };
          options[val] = opt;

          if (!filter || matchesFilter(txt, filter)) {
            optionArray.push(opt);

            if (hasGroups) {
              if (groupIndexes[lbl] === undefined) {
                gr = {
                  text: lbl,
                  value: c,
                  options: [],
                  index: c
                };
                groups[c] = gr;
                groupIndexes[lbl] = c;
                groupArray.push(gr);
                c++;
              } else {
                gr = groups[groupIndexes[lbl]];
              }

              if (groupSep) {
                opt.index = gr.options.length;
              }

              opt.group = groupIndexes[lbl];
              gr.options.push(opt);
            }

            if (v[s.dataDisabled]) {
              invalid.push(val);
            }
          }
        });
      } else {
        if (hasGroups) {
          var addGroup = true;
          $$1('optgroup', $elm).each(function (i) {
            groups[i] = {
              text: this.label,
              value: i,
              options: [],
              index: i
            };
            addGroup = true;
            $$1('option', this).each(function (j) {
              opt = {
                value: this.value,
                text: this.text,
                index: groupSep ? j : l++,
                group: i,
                cssClass: groupHdr ? 'mbsc-sel-gr-itm' : ''
              };
              options[this.value] = opt;

              if (!filter || matchesFilter(this.text, filter)) {
                if (addGroup) {
                  groupArray.push(groups[i]);
                  addGroup = false;
                }

                optionArray.push(opt);
                groups[i].options.push(opt);

                if (this.disabled) {
                  invalid.push(this.value);
                }
              }
            });
          });
        } else {
          $$1('option', $elm).each(function (i) {
            opt = {
              value: this.value,
              text: this.text,
              index: i
            };
            options[this.value] = opt;

            if (!filter || matchesFilter(this.text, filter)) {
              optionArray.push(opt);

              if (this.disabled) {
                invalid.push(this.value);
              }
            }
          });
        }
      }

      if (s.defaultValue) {
        defaultValue = s.defaultValue;
      } else if (optionArray.length) {
        defaultValue = optionArray[0].value;
      } else {
        defaultValue = '';
      }

      if (groupHdr) {
        optionArray = [];
        l = 0;
        $$1.each(groups, function (i, gr) {
          if (gr.options.length) {
            val = '__group' + i;
            opt = {
              text: gr.text,
              value: val,
              group: i,
              index: l++,
              cssClass: 'mbsc-sel-gr'
            };
            options[val] = opt;
            optionArray.push(opt);
            invalid.push(opt.value);
            $$1.each(gr.options, function (j, opt) {
              opt.index = l++;
              optionArray.push(opt);
            });
          }
        });
      }

      if ($filterEmpty) {
        if (optionArray.length) {
          $filterEmpty.removeClass('mbsc-sel-empty-v');
        } else {
          $filterEmpty.addClass('mbsc-sel-empty-v');
        }
      }
    }

    function genValues(data, tapSelect, label, multiple, cssClass) {
      var i,
          values = [];

      if (data) {
        for (i = 0; i < data.length; i++) {
          values.push({
            value: data[i].value,
            display: data[i].html || data[i].text,
            cssClass: data[i].cssClass
          });
        }
      }

      return {
        circular: false,
        multiple: tapSelect && !multiple ? 1 : multiple,
        cssClass: (tapSelect && !multiple ? 'mbsc-sel-one' : '') + ' ' + cssClass,
        data: values,
        label: label
      };
    }

    function genGroupWheel() {
      return genValues(groupArray, tapSelect, s.groupLabel, false, 'mbsc-sel-gr-whl');
    }

    function genOptWheel() {
      return genValues(groupSep && groups[group] ? groups[group].options : optionArray, tapSelect, label, multiple, '');
    }

    function genWheels() {
      var w = [[]];

      if (hasGroupWheel) {
        groupWheel = genGroupWheel();

        if (isLiquid) {
          w[0][groupWheelIdx] = groupWheel;
        } else {
          w[groupWheelIdx] = [groupWheel];
        }
      }

      optionWheel = genOptWheel();

      if (isLiquid) {
        w[0][optionWheelIdx] = optionWheel;
      } else {
        w[optionWheelIdx] = [optionWheel];
      }

      return w;
    }

    function getOption(v) {
      if (multiple) {
        if (v && isString(v)) {
          v = v.split(',');
        }

        if ($$1.isArray(v)) {
          v = v[0];
        }
      }

      option = v === undefined || v === null || v === '' ? defaultValue : v;

      if (!options[option] && optionArray && optionArray.length) {
        option = optionArray[0].value;
      }

      if (hasGroupWheel) {
        group = options[option] ? options[option].group : null;
      }
    }

    function getText(opt) {
      return selectedTexts[opt] || (options[opt] ? options[opt].text : '');
    }

    function formatValue(d, inst, fill) {
      var i,
          opt,
          sel = [],
          selected = fill ? inst._selected : inst._tempSelected;

      if (tapSelect) {
        for (i in selected[optionWheelIdx]) {
          sel.push(getText(i));
        }

        return sel.join(', ');
      }

      opt = d[optionWheelIdx];
      return getText(opt);
    }

    function onFill() {
      var i,
          html = '',
          val = inst.getVal(),
          txt = s.formatValue.call(elm, inst.getArrayVal(), inst, true);

      if (!(s.filter && s.display == 'inline')) {
        $input.val(txt);
      } // If we have a native select, but data was passed in setting,
      // create an option tag with the selected value


      if ($elm.is('select') && hasData) {
        if (multiple) {
          for (i = 0; i < val.length; i++) {
            html += '<option value="' + val[i] + '">' + getText(val[i]) + '</option>';
          }
        } else {
          html = '<option value="' + (val === null ? '' : val) + '">' + txt + '</option>';
        }

        $elm.html(html);
      }

      if (elm !== $input[0]) {
        // if the target is the same, we should not overwrite it
        $elm.val(val);
      }
    }

    function changeWheel() {
      var wheels = {};
      wheels[optionWheelIdx] = genOptWheel();
      prevent = true;
      inst.changeWheel(wheels);
    }

    function matchesFilter(str, filter) {
      filter = filter.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&'); // escape the special characters

      return str.match(new RegExp(filter, 'ig'));
    }

    function getData(data) {
      return s.data.dataField ? data[s.data.dataField] : s.data.processResponse ? s.data.processResponse(data) : data;
    }

    function prepareWheels(filter) {
      var wheels = {};
      prepareData(filter);
      getOption(option);
      s.wheels = genWheels();
      wheels[optionWheelIdx] = optionWheel;
      inst._tempWheelArray[optionWheelIdx] = option;

      if (hasGroupWheel) {
        wheels[groupWheelIdx] = groupWheel;
        inst._tempWheelArray[groupWheelIdx] = group;
      }

      inst.changeWheel(wheels, 0, true);
      onFill();
    }

    function triggerOnFilter(value) {
      return inst.trigger('onFilter', {
        filterText: value
      });
    }

    function loadGroupOptions(values) {
      if (values[groupWheelIdx] != group) {
        group = values[groupWheelIdx];
        option = groups[group].options[0].value;
        values[optionWheelIdx] = option;

        if (groupSep) {
          changeWheel();
        } else {
          inst.setArrayVal(values, false, false, true, animTime);
        }
      }
    } // Extended methods
    // ---


    inst.setVal = function (val, fill, change, temp, time) {
      if (tapSelect) {
        if (val !== null && val !== undefined && !multiple) {
          val = [val];
        }

        if (val && isString(val)) {
          val = val.split(',');
        }

        inst._tempSelected[optionWheelIdx] = arrayToObject(val);

        if (!temp) {
          inst._selected[optionWheelIdx] = arrayToObject(val);
        }

        val = val ? val[0] : null;

        if (hasGroupWheel) {
          var opt = options[val],
              gr = opt && opt.group;
          inst._tempSelected[groupWheelIdx] = arrayToObject([gr]);

          if (!temp) {
            inst._selected[groupWheelIdx] = arrayToObject([gr]);
          }
        }
      }

      inst._setVal(val, fill, change, temp, time);
    };

    inst.getVal = function (temp, group) {
      var val;

      if (tapSelect) {
        val = objectToArray(temp ? inst._tempSelected[optionWheelIdx] : inst._selected[optionWheelIdx]);
        val = multiple ? val : val.length ? val[0] : null;
      } else {
        val = temp ? inst._tempWheelArray : inst._hasValue ? inst._wheelArray : null;
        val = val ? val[optionWheelIdx] : null;
      }

      return multiple ? val : val !== undefined ? hasGroups && group ? [options[val] ? options[val].group : null, val] : val : null;
    };

    inst.refresh = function (data, filter, callback) {
      callback = callback || noop;

      if (data) {
        dataArray = data;

        if (!hasRemoteData) {
          // Save data, otherwise it will get lost on an option call,
          // and filtering does not work as well after async data update
          s.data = data;
        }
      } else if ($$1.isArray(s.data)) {
        dataArray = s.data;
      }

      if (!data && hasRemoteData && filter === undefined) {
        // reload the data from remote source
        getJson(s.data.url, function (data) {
          dataArray = getData(data);
          prepareWheels();
          callback();
        }, s.data.dataType);
      } else {
        prepareWheels(filter);
        callback();
      }
    }; // ---
    // Inits
    // ---


    if (!settings.invalid) {
      s.invalid = invalid;
    }

    if (hasGroupWheel) {
      groupWheelIdx = 0;
      optionWheelIdx = 1;
    } else {
      groupWheelIdx = -1;
      optionWheelIdx = 0;
    }

    if (tapSelect) {
      if (multiple && $elm.is('select')) {
        $elm.prop('multiple', true);
      }

      if (values && isString(values)) {
        values = values.split(',');
      }

      inst._selected[optionWheelIdx] = arrayToObject(values);
    } // Remove dummy element if exists


    if (inst._$input) {
      inst._$input.remove();
    } // Check if mobiscroll form already initialized this select


    if ($elm.next().is('.mbsc-select-input')) {
      $input = $elm.next().removeAttr('tabindex');
    } else {
      if (s.input) {
        $input = $$1(s.input);
      } else {
        // Create dummy input
        if (s.filter && s.display == 'inline') {
          inst._$input = $$1('<div class="mbsc-sel-input-wrap"><input type="text" id="' + id + '" class="mbsc-select-input mbsc-control ' + s.inputClass + '" readonly /></div>');
        } else {
          $input = $$1('<input type="text" id="' + id + '" class="mbsc-select-input mbsc-control ' + s.inputClass + '" readonly />');
          inst._$input = $input;
        }

        if (s.showInput) {
          inst._$input.insertAfter($elm);

          if (!$input) {
            $input = inst._$input.find('#' + id);
          }
        }
      }
    } // Show scroller on input tap


    inst.attachShow($input.attr('placeholder', s.placeholder || ''));

    if ($input[0] !== elm) {
      $elm.addClass('mbsc-sel-hdn').attr('tabindex', -1);

      if (!s.showInput) {
        $elm.attr('data-enhance', false);
      }
    }

    if (tapSelect && !(s.rows % 2)) {
      s.rows = s.rows - 1;
    }

    if (s.filter) {
      filterLength = s.filter.minLength || 0;
    }

    hasRemoteData = s.data && s.data.url;

    if (hasRemoteData) {
      inst.refresh();
    } else {
      if (hasData) {
        dataArray = s.data;
      }

      prepareData();
      getOption($elm.val());
    } // ---


    return {
      layout: layout,
      headerText: false,
      anchor: $input,
      compClass: 'mbsc-sc mbsc-sel' + (tapSelect ? ' mbsc-sel-multi' : ''),
      setOnTap: hasGroupWheel ? [false, true] : true,
      formatValue: formatValue,
      tapSelect: tapSelect,
      parseValue: function parseValue(val) {
        getOption(val === undefined ? $elm.val() : val);
        return hasGroupWheel ? [group, option] : [option];
      },
      validate: function validate(data) {
        var index = data.index,
            disabled = [];
        disabled[optionWheelIdx] = s.invalid;

        if (groupSep && !prevent && index === undefined) {
          changeWheel();
        }

        prevent = false;
        return {
          disabled: disabled
        };
      },
      onRead: onFill,
      onFill: onFill,
      onMarkupReady: function onMarkupReady(event, inst) {
        if (s.filter) {
          var $filterInput,
              debounce,
              filterInput,
              $cont = $$1('.mbsc-fr-w', event.target),
              $filterClear = $$1('<span class="mbsc-sel-filter-clear mbsc-ic mbsc-ic-' + s.filterClearIcon + '"></span>');

          if (s.display == 'inline') {
            $filterInput = $input;
            $input.parent().find('.mbsc-sel-filter-clear').remove();
          } else {
            $cont.find('.mbsc-fr-c').before('<div class="mbsc-input mbsc-sel-filter-cont mbsc-control-w mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + '"><span class="mbsc-input-wrap"><input tabindex="0" type="text" class="mbsc-sel-filter-input mbsc-control"/></span></div>');
            $filterInput = $cont.find('.mbsc-sel-filter-input');
          }

          filterText = null;
          filterInput = $filterInput[0];
          $filterInput.prop('readonly', false).attr('placeholder', s.filterPlaceholderText).parent().append($filterClear);
          $cont.find('.mbsc-fr-c').prepend($filterEmpty); // Will focus in the input on show

          inst._activeElm = filterInput;
          inst.tap($filterClear, function () {
            filterText = null;
            filterInput.value = '';
            inst.refresh();
            $filterClear.removeClass('mbsc-sel-filter-show-clear');
            triggerOnFilter('');
          });
          $filterInput.on('keydown', function (ev) {
            // Enter and Esc
            if (ev.keyCode == 13 || ev.keyCode == 27) {
              ev.stopPropagation();
              filterInput.blur();
            }
          }).on('input', function () {
            clearTimeout(debounce);

            if (filterInput.value.length) {
              $filterClear.addClass('mbsc-sel-filter-show-clear');
            } else {
              $filterClear.removeClass('mbsc-sel-filter-show-clear');
            }

            debounce = setTimeout(function () {
              if (filterText === filterInput.value || triggerOnFilter(filterInput.value) === false) {
                return;
              }

              filterText = filterInput.value;

              if (filterText.length >= filterLength || !filterText.length) {
                if (hasRemoteData && s.data.remoteFilter) {
                  getJson(s.data.url + encodeURIComponent(filterText), function (data) {
                    inst.refresh(getData(data));
                  }, s.data.dataType);
                } else {
                  inst.refresh(undefined, filterText);
                }
              }
            }, 500);
          });
        }
      },
      onBeforeShow: function onBeforeShow() {
        if (multiple && s.counter) {
          s.headerText = function () {
            var length = 0;
            $$1.each(inst._tempSelected[optionWheelIdx], function () {
              length++;
            });
            return (length > 1 ? s.selectedPluralText || s.selectedText : s.selectedText).replace(/{count}/, length);
          };
        }

        getOption($elm.val());

        if (tapSelect && hasGroupWheel) {
          inst._selected[groupWheelIdx] = arrayToObject([group]);
        }

        if (s.filter) {
          prepareData(undefined);
        }

        inst.settings.wheels = genWheels();
        prevent = true;
      },
      onWheelGestureStart: function onWheelGestureStart(ev) {
        if (ev.index == groupWheelIdx) {
          s.readonly = [false, true];
        }
      },
      onWheelAnimationEnd: function onWheelAnimationEnd(ev) {
        var values = inst.getArrayVal(true);

        if (ev.index == groupWheelIdx) {
          s.readonly = origReadOnly;

          if (!tapSelect) {
            loadGroupOptions(values);
          }
        } else if (ev.index == optionWheelIdx && values[optionWheelIdx] != option) {
          option = values[optionWheelIdx];

          if (hasGroupWheel && options[option] && options[option].group != group) {
            group = options[option].group;
            values[groupWheelIdx] = group;
            inst._tempSelected[groupWheelIdx] = arrayToObject([group]);
            inst.setArrayVal(values, false, false, true, animTime);
          }
        }
      },
      onItemTap: function onItemTap(ev) {
        var values;

        if (ev.index == optionWheelIdx) {
          selectedTexts[ev.value] = options[ev.value].text;

          if (tapSelect && !multiple && ev.selected) {
            inst._prevItemTap = true;
            return false;
          }
        }

        if (ev.index == groupWheelIdx && tapSelect) {
          if (ev.selected) {
            inst._prevItemTap = true;
            return false;
          }

          values = inst.getArrayVal(true);
          values[groupWheelIdx] = ev.value;
          loadGroupOptions(values);
        }
      },
      onClose: function onClose() {
        if (hasRemoteData && s.data.remoteFilter && filterText) {
          inst.refresh();
        }
      },
      onDestroy: function onDestroy() {
        // Remove dummy input
        if (inst._$input) {
          inst._$input.remove();
        } // Revert select attributes and classes


        $elm.removeClass('mbsc-sel-hdn').removeAttr('tabindex');
      }
    };
  };

  var MbscSelect = (function (_super) {
      __extends(MbscSelect, _super);
      function MbscSelect(initialElement, zone, control, inputService, optionService, view) {
          var _this = _super.call(this, initialElement, zone, control, inputService, view) || this;
          _this.optionService = optionService;
          _this.placeholder = '';
          _this.onFilter = new core.EventEmitter();
          _this.options = {};
          _this.onChangeEmitter = new core.EventEmitter();
          return _this;
      }
      Object.defineProperty(MbscSelect.prototype, "value", {
          set: function (v) {
              if (!this.control) {
                  this.setNewValueProxy(v);
              }
          },
          enumerable: true,
          configurable: true
      });
      MbscSelect.prototype.refreshData = function (newData) {
          this.instance.refresh(newData);
      };
      MbscSelect.prototype.initControl = function () {
          var target = this.target;
          if (target) {
              if (typeof target !== 'string' && target._elementRef && target._elementRef.nativeElement) {
                  target = target._elementRef.nativeElement;
                  var inputUnder = $$1('input', target);
                  if (inputUnder.length) {
                      target = inputUnder;
                  }
              }
          }
          else {
              var contentInput = $$1('input', this.initialElem.nativeElement).length;
              if (contentInput) {
                  target = this.element;
              }
              if (!target && this.initialElem.nativeElement.nodeName === 'ION-INPUT') {
                  target = this.initialElem.nativeElement;
              }
          }
          var options = extend$1({ preset: 'select', input: target }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
          this.instance = new Select$1(this.element, options);
          if (this.initialValue !== undefined) {
              this.instance.setVal(this.initialValue, true, false);
          }
      };
      MbscSelect.prototype.setElement = function () {
          this.element = this.initialElem.nativeElement;
          var contentSelect = $$1('select', this.initialElem.nativeElement);
          if (contentSelect.length) {
              this.element = contentSelect[0];
          }
          else {
              _super.prototype.setElement.call(this);
          }
      };
      MbscSelect.prototype.ngOnInit = function () {
          this.isMulti = this.options && this.options.select && this.options.select !== 'single';
          this.cloneDictionary.data = [];
          _super.prototype.ngOnInit.call(this);
      };
      MbscSelect.prototype.setNewValue = function (v) {
          if (this.instance) {
              var changed = void 0;
              if (this.isMulti) {
                  changed = !deepEqualsArray(v, this.instance.getVal());
              }
              else {
                  var innerValue = this.instance.getVal();
                  changed = innerValue !== v;
              }
              if (changed) {
                  this.instance.setVal(v, true, false);
                  if (this._inputService && this._inputService.input) {
                      this._inputService.input.innerValue = this.instance._value;
                  }
              }
          }
      };
      MbscSelect.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mbsc-select]',
                      exportAs: 'mobiscroll'
                  },] },
      ];
      MbscSelect.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: core.ViewContainerRef, },
      ]; };
      MbscSelect.propDecorators = {
          'counter': [{ type: core.Input },],
          'data': [{ type: core.Input, args: ['mbsc-data',] },],
          'dataText': [{ type: core.Input },],
          'dataGroup': [{ type: core.Input },],
          'dataValue': [{ type: core.Input },],
          'filter': [{ type: core.Input },],
          'filterPlaceholderText': [{ type: core.Input },],
          'filterEmptyText': [{ type: core.Input },],
          'group': [{ type: core.Input },],
          'groupLabel': [{ type: core.Input },],
          'inputClass': [{ type: core.Input },],
          'invalid': [{ type: core.Input },],
          'label': [{ type: core.Input },],
          'placeholder': [{ type: core.Input },],
          'select': [{ type: core.Input },],
          'showInput': [{ type: core.Input },],
          'onFilter': [{ type: core.Output },],
          'options': [{ type: core.Input, args: ['mbsc-options',] },],
          'target': [{ type: core.Input, args: ['mbsc-target',] },],
          'value': [{ type: core.Input, args: ['mbsc-select',] },],
          'onChangeEmitter': [{ type: core.Output, args: ['mbsc-selectChange',] },],
      };
      return MbscSelect;
  }(MbscScrollerBase));
  var MbscSelectComponent = (function (_super) {
      __extends(MbscSelectComponent, _super);
      function MbscSelectComponent(initialElem, zone, control, inputService, optionService) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
          _this.errorMessage = '';
          _this.dropdown = true;
          _this.placeholder = '';
          return _this;
      }
      MbscSelectComponent.prototype.ngAfterViewInit = function () {
          _super.prototype.ngAfterViewInit.call(this);
          this.setThemeClasses();
      };
      MbscSelectComponent.prototype.ngOnInit = function () {
          _super.prototype.ngOnInit.call(this);
          if (this.inline) {
              var showInput = this.showInput || (this.options && this.options.showInput);
              var filter = this.filter || (this.options && this.options.filter);
              if (showInput === undefined) {
                  this.inlineOptionsObj.showInput = this.showInput = !!filter;
              }
          }
      };
      MbscSelectComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-select',
                      exportAs: 'mobiscroll',
                      template: INPUT_TEMPLATE
                  },] },
      ];
      MbscSelectComponent.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscSelectComponent.propDecorators = {
          'inputIcon': [{ type: core.Input, args: ['icon',] },],
          'iconAlign': [{ type: core.Input, args: ['icon-align',] },],
          'name': [{ type: core.Input },],
          'error': [{ type: core.Input },],
          'errorMessage': [{ type: core.Input },],
          'options': [{ type: core.Input },],
          'data': [{ type: core.Input },],
          'dropdown': [{ type: core.Input },],
          'placeholder': [{ type: core.Input },],
      };
      return MbscSelectComponent;
  }(MbscSelect));
  var MbscSelectModule = (function () {
      function MbscSelectModule() {
      }
      MbscSelectModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule, MbscScrollerBaseModule, MbscInputModule],
                      declarations: [MbscSelect, MbscSelectComponent],
                      exports: [MbscSelect, MbscSelectComponent]
                  },] },
      ];
      MbscSelectModule.ctorParameters = function () { return []; };
      return MbscSelectModule;
  }());

  var Timer = Scroller;
  var defaults$e = {
    autostart: false,
    step: 1,
    // in seconds
    useShortLabels: false,
    // Localization
    labels: ['Years', 'Months', 'Days', 'Hours', 'Minutes', 'Seconds', ''],
    labelsShort: ['Yrs', 'Mths', 'Days', 'Hrs', 'Mins', 'Secs', ''],
    startText: 'Start',
    stopText: 'Stop',
    resetText: 'Reset',
    lapText: 'Lap',
    hideText: 'Hide',
    mode: 'countdown'
  };

  presets.timer = function (inst) {
    /**
     * Converts a date to UTC
     * @param   d   (Date)  Date to convert
     * @return      (Date)  Date converted to UTC
     */
    function toUtc(d) {
      return new Date(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(), d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds());
    }
    /**
     * Calculates the parts of the time differnce
     * @param   time    (Integer)   Time in milliseconds
     * @return          (Object)    Time splitted to the required parts (years, months, days, hours, minutes, seconds)
     */


    function getParts(time) {
      var ret = {};

      if (dateMode && obj[max].index > obj.days.index) {
        var i,
            v,
            o,
            prev,
            now = new Date(),
            d2 = up ? now : origTime,
            d1 = up ? origTime : now;
        d1 = toUtc(d1);
        d2 = toUtc(d2);
        ret.years = d2.getFullYear() - d1.getFullYear();
        ret.months = d2.getMonth() - d1.getMonth();
        ret.days = d2.getDate() - d1.getDate();
        ret.hours = d2.getHours() - d1.getHours();
        ret.minutes = d2.getMinutes() - d1.getMinutes();
        ret.seconds = d2.getSeconds() - d1.getSeconds();
        ret.fract = (d2.getMilliseconds() - d1.getMilliseconds()) / 10;

        for (i = unique.length; i > 0; i--) {
          v = unique[i - 1];
          o = obj[v];
          prev = unique[$$1.inArray(v, unique) - 1];

          if (obj[prev] && ret[v] < 0) {
            ret[prev]--;
            ret[v] += prev == 'months' ? 32 - new Date(d2.getFullYear(), d2.getMonth(), 32).getDate() : o.until + 1;
          }
        }

        if (max == 'months') {
          ret.months += ret.years * 12;
          delete ret.years;
        }
      } else {
        $$1(unique).each(function (i, v) {
          if (obj[v].index <= obj[max].index) {
            ret[v] = Math.floor(time / obj[v].limit);
            time -= ret[v] * obj[v].limit;
          }
        });
      }

      return ret;
    }
    /**
     * Generates a specific wheel
     * @param   v   (String)  Unique identifier
     */


    function genWheel(v) {
      var st = 1,
          o = obj[v],
          wh = o.wheel,
          prefix = o.prefix,
          from = 0,
          until = o.until,
          next = obj[unique[$$1.inArray(v, unique) - 1]];

      if (o.index <= obj[max].index && (!next || next.limit > step)) {
        if (!wheels[v]) {
          w[0].push(wh);
        }

        wheels[v] = 1;
        wh.data = [];
        wh.label = o.label || '';
        wh.cssClass = 'mbsc-timer-whl-' + v;

        if (step >= o.limit) {
          // Calculate steps on last wheel
          st = Math.max(Math.round(step / o.limit), 1);
          tstep = st * o.limit; // Timer is calculated with rounded step
        }

        if (v == max) {
          wh.min = 0;

          wh.data = function (i) {
            return {
              value: i,
              display: genValue(i, prefix, o.label)
            };
          };

          wh.getIndex = function (v) {
            return v;
          };
        } else {
          for (i = from; i <= until; i += st) {
            wh.data.push({
              value: i,
              display: genValue(i, prefix, o.label)
            });
          }
        }
      }
    }

    function genValue(i, prefix, lbl) {
      return (prefix || '') + (i < 10 ? '0' : '') + i + '<span class="mbsc-timer-lbl">' + lbl + '</span>';
    }
    /**
     * Converts the time into array containing the parts
     * @param   time    (Integer)   Time in milliseconds
     * @return          (Array)     Time splitted to the required parts (years, months, days, hours, minutes, seconds)
     */


    function getArray(time) {
      var arr = [],
          st,
          p = getParts(time);
      $$1(unique).each(function (i, v) {
        if (wheels[v]) {
          st = Math.max(Math.round(step / obj[v].limit), 1);
          arr.push(Math.round(p[v] / st) * st);
        }
      });
      return arr;
    }
    /**
     * Calculates the time
     * @param   reset   (Boolean)   Reset the timer or not
     */


    function calcTime(reset) {
      if (dateMode) {
        time = origTime - new Date();

        if (time < 0) {
          time *= -1;
          up = true;
        } else {
          up = false;
        }

        timer = 0;
        infinit = true;
      } else if (origTime !== undefined) {
        infinit = false;
        time = origTime * 1000;
        up = s.mode != 'countdown';

        if (reset) {
          timer = 0;
        }
      } else {
        time = 0;
        up = s.mode != 'countdown';
        infinit = up;

        if (reset) {
          timer = 0;
        }
      }
    }

    function updateUI() {
      if (running) {
        $$1('.mbsc-fr-w', ctx).addClass('mbsc-timer-running mbsc-timer-locked');
        $$1('.mbsc-timer-btn-toggle-c > div', ctx).text(s.stopText);

        if (inst.buttons.start.icon) {
          $$1('.mbsc-timer-btn-toggle-c > div', ctx).removeClass('mbsc-ic-' + inst.buttons.start.icon);
        }

        if (inst.buttons.stop.icon) {
          $$1('.mbsc-timer-btn-toggle-c > div', ctx).addClass('mbsc-ic-' + inst.buttons.stop.icon);
        }

        if (s.mode == 'stopwatch') {
          $$1('.mbsc-timer-btn-resetlap-c > div', ctx).text(s.lapText);

          if (inst.buttons.reset.icon) {
            $$1('.mbsc-timer-btn-resetlap-c > div', ctx).removeClass('mbsc-ic-' + inst.buttons.reset.icon);
          }

          if (inst.buttons.lap.icon) {
            $$1('.mbsc-timer-btn-resetlap-c > div', ctx).addClass('mbsc-ic-' + inst.buttons.lap.icon);
          }
        }
      } else {
        $$1('.mbsc-fr-w', ctx).removeClass('mbsc-timer-running');
        $$1('.mbsc-timer-btn-toggle-c > div', ctx).text(s.startText);

        if (inst.buttons.start.icon) {
          $$1('.mbsc-timer-btn-toggle-c > div', ctx).addClass('mbsc-ic-' + inst.buttons.start.icon);
        }

        if (inst.buttons.stop.icon) {
          $$1('.mbsc-timer-btn-toggle-c > div', ctx).removeClass('mbsc-ic-' + inst.buttons.stop.icon);
        }

        if (s.mode == 'stopwatch') {
          $$1('.mbsc-timer-btn-resetlap-c > div', ctx).text(s.resetText);

          if (inst.buttons.reset.icon) {
            $$1('.mbsc-timer-btn-resetlap-c > div', ctx).addClass('mbsc-ic-' + inst.buttons.reset.icon);
          }

          if (inst.buttons.lap.icon) {
            $$1('.mbsc-timer-btn-resetlap-c > div', ctx).removeClass('mbsc-ic-' + inst.buttons.lap.icon);
          }
        }
      }
    }

    var i,
        interval,
        tstep,
        startTime,
        started,
        ellapsed,
        time,
        timer,
        up,
        ctx,
        lap,
        orig = extend$1({}, inst.settings),
        s = extend$1(inst.settings, defaults$e, orig),
        lbls = s.useShortLabels ? s.labelsShort : s.labels,
        animTime = 1000,
        buttons = ['resetlap', 'toggle'],
        unique = ['years', 'months', 'days', 'hours', 'minutes', 'seconds', 'fract'],
        obj = {
      'years': {
        index: 6,
        until: 10,
        limit: 1000 * 60 * 60 * 24 * 365,
        label: lbls[0],
        wheel: {}
      },
      'months': {
        index: 5,
        until: 11,
        limit: 1000 * 60 * 60 * 24 * 30,
        label: lbls[1],
        wheel: {}
      },
      'days': {
        index: 4,
        until: 31,
        limit: 1000 * 60 * 60 * 24,
        label: lbls[2],
        wheel: {}
      },
      'hours': {
        index: 3,
        until: 23,
        limit: 1000 * 60 * 60,
        label: lbls[3],
        wheel: {}
      },
      'minutes': {
        index: 2,
        until: 59,
        limit: 1000 * 60,
        label: lbls[4],
        wheel: {}
      },
      'seconds': {
        index: 1,
        until: 59,
        limit: 1000,
        label: lbls[5],
        wheel: {}
      },
      'fract': {
        index: 0,
        until: 99,
        limit: 10,
        label: lbls[6],
        prefix: '.',
        wheel: {}
      }
    },
        wheels = {},
        laps = [],
        lastLap = 0,
        running = false,
        stopped = true,
        infinit = false,
        step = Math.max(10, s.step * 1000),
        max = s.maxWheel,
        locked = s.mode == 'stopwatch' || dateMode,
        origTime = s.targetTime,
        dateMode = origTime && origTime.getTime !== undefined,
        w = [[]]; // Extended methods
    // ---
    // Start the counter

    inst.start = function () {
      if (stopped) {
        inst.reset();
      }

      if (!running) {
        calcTime();

        if (!infinit && timer >= time) {
          return;
        }

        running = true;
        stopped = false;
        started = new Date();
        startTime = timer;
        s.readonly = true;
        inst.setVal(getArray(up ? timer : time - timer), true, true, false, 100);
        interval = setInterval(function () {
          timer = new Date() - started + startTime;
          inst.setVal(getArray(up ? timer : time - timer), true, true, false, Math.min(100, tstep - 10));

          if (!infinit && timer + tstep >= time) {
            clearInterval(interval);
            setTimeout(function () {
              // Do last tick with precision
              inst.stop();
              timer = time;
              inst.setVal(getArray(up ? timer : 0), true, true, false, 100);
              inst.trigger('onFinish', {
                time: time
              });
              stopped = true;
            }, time - timer);
          }
        }, tstep);
        updateUI();
        inst.trigger('onStart');
      }
    }; // Stop the counter


    inst.stop = function () {
      if (running) {
        running = false;
        clearInterval(interval); // Time correction

        timer = new Date() - started + startTime;
        updateUI();
        inst.trigger('onStop', {
          ellapsed: timer
        });
      }
    };

    inst.toggle = function () {
      if (running) {
        inst.stop();
      } else {
        inst.start();
      }
    }; // Reset the counter


    inst.reset = function () {
      inst.stop();
      timer = 0;
      laps = [];
      lastLap = 0;
      inst.setVal(getArray(up ? 0 : time), true, true, false, animTime);
      inst.settings.readonly = locked;
      stopped = true;

      if (!locked) {
        $$1('.mbsc-fr-w', ctx).removeClass('mbsc-timer-locked');
      }

      inst.trigger('onReset');
    }; // Lap


    inst.lap = function () {
      if (running) {
        ellapsed = new Date() - started + startTime;
        lap = ellapsed - lastLap;
        lastLap = ellapsed;
        laps.push(ellapsed);
        inst.trigger('onLap', {
          ellapsed: ellapsed,
          lap: lap,
          laps: laps
        });
      }
    };

    inst.resetlap = function () {
      if (running && s.mode == 'stopwatch') {
        inst.lap();
      } else {
        inst.reset();
      }
    };

    inst.getTime = function () {
      return time;
    };

    inst.setTime = function (t) {
      origTime = t / 1000;
      time = t;
    };

    inst.getEllapsedTime = function () {
      return stopped ? 0 : running ? new Date() - started + startTime : timer;
    };

    inst.setEllapsedTime = function (t, change) {
      if (!stopped) {
        startTime = timer = t;
        started = new Date();
        inst.setVal(getArray(up ? timer : time - timer), true, change, false, animTime);
      }
    }; // ---
    // Constructor


    calcTime(true);

    if (!max && !time) {
      max = 'minutes';
    }

    if (s.display !== 'inline') {
      buttons.unshift('hide');
    } // Determine maximum wheel


    if (!max) {
      $$1(unique).each(function (i, v) {
        if (!max && time >= obj[v].limit) {
          max = v;
          return false;
        }
      });
    } // Generate wheels


    $$1(unique).each(function (i, v) {
      genWheel(v);
    });
    tstep = Math.max(97, tstep); // timer step cannot be less then 100 ms

    if (s.autostart) {
      setTimeout(function () {
        inst.start();
      }, 0);
    }

    inst.handlers.toggle = inst.toggle;
    inst.handlers.start = inst.start;
    inst.handlers.stop = inst.stop;
    inst.handlers.resetlap = inst.resetlap;
    inst.handlers.reset = inst.reset;
    inst.handlers.lap = inst.lap;
    inst.buttons.toggle = {
      parentClass: 'mbsc-timer-btn-toggle-c',
      text: s.startText,
      icon: s.startIcon,
      handler: 'toggle'
    };
    inst.buttons.start = {
      text: s.startText,
      icon: s.startIcon,
      handler: 'start'
    };
    inst.buttons.stop = {
      text: s.stopText,
      icon: s.stopIcon,
      handler: 'stop'
    };
    inst.buttons.reset = {
      text: s.resetText,
      icon: s.resetIcon,
      handler: 'reset'
    };
    inst.buttons.lap = {
      text: s.lapText,
      icon: s.lapIcon,
      handler: 'lap'
    };
    inst.buttons.resetlap = {
      parentClass: 'mbsc-timer-btn-resetlap-c',
      text: s.resetText,
      icon: s.resetIcon,
      handler: 'resetlap'
    };
    inst.buttons.hide = {
      parentClass: 'mbsc-timer-btn-hide-c',
      text: s.hideText,
      icon: s.closeIcon,
      handler: 'cancel'
    }; // Return settings

    return {
      minWidth: 100,
      wheels: w,
      headerText: false,
      readonly: locked,
      buttons: buttons,
      compClass: 'mbsc-timer mbsc-sc',
      parseValue: function parseValue() {
        return getArray(up ? 0 : time);
      },
      formatValue: function formatValue(d) {
        var ret = '',
            j = 0;
        $$1(unique).each(function (i, v) {
          if (v == 'fract') {
            return;
          }

          if (wheels[v]) {
            ret += d[j] + (v == 'seconds' && wheels.fract ? '.' + d[j + 1] : '') + ' ' + lbls[i] + ' ';
            j++;
          }
        });
        return ret;
      },
      validate: function validate(data) {
        var values = data.values,
            i = data.index,
            j = 0;

        if (stopped && i !== undefined) {
          origTime = 0;
          $$1(unique).each(function (i, v) {
            if (wheels[v]) {
              origTime += obj[v].limit * values[j];
              j++;
            }
          });
          origTime /= 1000;
          calcTime(true);
        }
      },
      onBeforeShow: function onBeforeShow() {
        s.showLabel = true;
      },
      onMarkupReady: function onMarkupReady(ev) {
        ctx = $$1(ev.target);
        updateUI();

        if (locked) {
          $$1('.mbsc-fr-w', ctx).addClass('mbsc-timer-locked');
        }
      },
      onPosition: function onPosition(ev) {
        // Force width to fit buttons
        $$1('.mbsc-fr-w', ev.target).css('min-width', 0).css('min-width', $$1('.mbsc-fr-btn-cont', ev.target)[0].offsetWidth);
      },
      onDestroy: function onDestroy() {
        clearInterval(interval);
      }
    };
  };

  var MbscTimer = (function (_super) {
      __extends(MbscTimer, _super);
      function MbscTimer(initialElement, zone, control, inputService, optionService, view) {
          var _this = _super.call(this, initialElement, zone, control, inputService, view) || this;
          _this.optionService = optionService;
          _this.onLap = new core.EventEmitter();
          _this.onFinish = new core.EventEmitter();
          _this.onReset = new core.EventEmitter();
          _this.onStart = new core.EventEmitter();
          _this.onStop = new core.EventEmitter();
          _this.options = {};
          _this.onChangeEmitter = new core.EventEmitter();
          return _this;
      }
      Object.defineProperty(MbscTimer.prototype, "value", {
          set: function (v) {
              this.setNewValueProxy(v);
          },
          enumerable: true,
          configurable: true
      });
      MbscTimer.prototype.setNewValue = function (v) {
          if (this.instance) {
              if (!this.instance._timer || Math.abs(this.instance._timer - v) > 10) {
                  this.instance.setEllapsedTime(v, false);
                  if (this._inputService && this._inputService.input) {
                      this._inputService.input.innerValue = this.instance._value;
                  }
              }
          }
      };
      MbscTimer.prototype.handleChange = function () {
          var that = this;
          $$1(this.element).on('change', function () {
              that.zone.run(function () {
                  that.instance._timer = that.instance.getEllapsedTime();
                  if (that.control) {
                      that.control.control.patchValue(that.instance._timer);
                  }
                  else {
                      that.onChangeEmitter.emit(that.instance._timer);
                  }
              });
          });
      };
      MbscTimer.prototype.initControl = function () {
          var options = extend$1({ preset: 'timer' }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
          this.instance = new Timer(this.element, options);
          if (this.initialValue !== undefined) {
              this.instance.setVal(this.initialValue, true, false);
          }
      };
      MbscTimer.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mbsc-timer]',
                      exportAs: 'mobiscroll'
                  },] },
      ];
      MbscTimer.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: core.ViewContainerRef, },
      ]; };
      MbscTimer.propDecorators = {
          'autostart': [{ type: core.Input },],
          'maxWheel': [{ type: core.Input },],
          'mode': [{ type: core.Input },],
          'step': [{ type: core.Input },],
          'targetTime': [{ type: core.Input },],
          'useShortLabels': [{ type: core.Input },],
          'hideText': [{ type: core.Input },],
          'labels': [{ type: core.Input },],
          'labelsShort': [{ type: core.Input },],
          'lapText': [{ type: core.Input },],
          'resetText': [{ type: core.Input },],
          'startText': [{ type: core.Input },],
          'stopText': [{ type: core.Input },],
          'onLap': [{ type: core.Output },],
          'onFinish': [{ type: core.Output },],
          'onReset': [{ type: core.Output },],
          'onStart': [{ type: core.Output },],
          'onStop': [{ type: core.Output },],
          'options': [{ type: core.Input, args: ['mbsc-options',] },],
          'value': [{ type: core.Input, args: ['mbsc-timer',] },],
          'onChangeEmitter': [{ type: core.Output, args: ['mbsc-timerChange',] },],
      };
      return MbscTimer;
  }(MbscScrollerBase));
  var MbscTimerComponent = (function (_super) {
      __extends(MbscTimerComponent, _super);
      function MbscTimerComponent(initialElem, zone, control, inputService, optionService) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
          _this.errorMessage = '';
          _this.placeholder = '';
          return _this;
      }
      MbscTimerComponent.prototype.ngAfterViewInit = function () {
          _super.prototype.ngAfterViewInit.call(this);
          this.setThemeClasses();
      };
      MbscTimerComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-timer',
                      exportAs: 'mobiscroll',
                      template: INPUT_TEMPLATE
                  },] },
      ];
      MbscTimerComponent.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscTimerComponent.propDecorators = {
          'inputIcon': [{ type: core.Input, args: ['icon',] },],
          'iconAlign': [{ type: core.Input, args: ['icon-align',] },],
          'name': [{ type: core.Input },],
          'error': [{ type: core.Input },],
          'errorMessage': [{ type: core.Input },],
          'options': [{ type: core.Input },],
          'placeholder': [{ type: core.Input },],
      };
      return MbscTimerComponent;
  }(MbscTimer));
  var MbscTimerModule = (function () {
      function MbscTimerModule() {
      }
      MbscTimerModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule, MbscScrollerBaseModule, MbscInputModule],
                      declarations: [MbscTimer, MbscTimerComponent],
                      exports: [MbscTimer, MbscTimerComponent]
                  },] },
      ];
      MbscTimerModule.ctorParameters = function () { return []; };
      return MbscTimerModule;
  }());

  var Timespan = Scroller;
  var defaults$f = {
    wheelOrder: 'hhiiss',
    useShortLabels: false,
    min: 0,
    max: Infinity,
    // Localization
    labels: ['Years', 'Months', 'Days', 'Hours', 'Minutes', 'Seconds'],
    //, ''],
    labelsShort: ['Yrs', 'Mths', 'Days', 'Hrs', 'Mins', 'Secs'] //, '']

  };

  presets.timespan = function (inst) {
    /**
     * Calculates the parts of the time differnce.
     * @param {Integer} time - Time in milliseconds.
     * @return {Object} - Time splitted to the required parts (years, months, days, hours, minutes, seconds).
     */
    function getParts(time) {
      var ret = {};
      $$1(unique).each(function (i, v) {
        ret[v] = wheels[v] ? Math.floor(time / obj[v].limit) : 0;
        time -= ret[v] * obj[v].limit;
      });
      return ret;
    }
    /**
     * Generates a specific wheel.
     * @param {String} v - Unique identifier.
     */


    function genWheel(v) {
      var leading = false,
          st = steps[wheels[v] - 1] || 1,
          o = obj[v],
          lbl = o.label,
          w = o.wheel;
      w.data = [];
      w.label = o.label;

      if (ord.match(new RegExp(o.re + o.re, 'i'))) {
        leading = true;
      }

      if (v == max) {
        w.min = minParts[v];
        w.max = maxParts[v];

        w.data = function (i) {
          return {
            value: i * st,
            display: genValue(i * st, leading, lbl)
          };
        };

        w.getIndex = function (v) {
          return Math.round(v / st);
        };
      } else {
        for (i = 0; i <= o.until; i += st) {
          w.data.push({
            value: i,
            display: genValue(i, leading, lbl)
          });
        }
      }
    }

    function genValue(i, leading, lbl) {
      return (i < 10 && leading ? '0' : '') + i + '<span class="mbsc-ts-lbl">' + lbl + '</span>';
    }

    function calcTime(arr) {
      var j = 0,
          time = 0;
      $$1.each(o, function (i, v) {
        if (!isNaN(+arr[j])) {
          time += obj[v.v].limit * arr[i];
        }
      });
      return time;
    }

    function step(v, st) {
      return Math.floor(v / st) * st;
    }

    var i,
        j,
        p,
        minParts,
        maxParts,
        orig = extend$1({}, inst.settings),
        s = extend$1(inst.settings, defaults$f, orig),
        ord = s.wheelOrder,
        lbls = s.useShortLabels ? s.labelsShort : s.labels,
        unique = ['years', 'months', 'days', 'hours', 'minutes', 'seconds'],
        //, 'fract'],
    obj = {
      'years': {
        ord: 0,
        index: 6,
        until: 10,
        limit: 1000 * 60 * 60 * 24 * 365,
        label: lbls[0],
        re: 'y',
        wheel: {}
      },
      'months': {
        ord: 1,
        index: 5,
        until: 11,
        limit: 1000 * 60 * 60 * 24 * 30,
        label: lbls[1],
        re: 'm',
        wheel: {}
      },
      'days': {
        ord: 2,
        index: 4,
        until: 31,
        limit: 1000 * 60 * 60 * 24,
        label: lbls[2],
        re: 'd',
        wheel: {}
      },
      'hours': {
        ord: 3,
        index: 3,
        until: 23,
        limit: 1000 * 60 * 60,
        label: lbls[3],
        re: 'h',
        wheel: {}
      },
      'minutes': {
        ord: 4,
        index: 2,
        until: 59,
        limit: 1000 * 60,
        label: lbls[4],
        re: 'i',
        wheel: {}
      },
      'seconds': {
        ord: 5,
        index: 1,
        until: 59,
        limit: 1000,
        label: lbls[5],
        re: 's',
        wheel: {}
      } //,
      //'fract': { index: 0, until: 99, limit: 10, label: lbls[6], prefix: '.', short: 'u' }

    },
        o = [],
        steps = s.steps || [],
        wheels = {},
        max = 'seconds',
        defaultVal = s.defaultValue || Math.max(s.min, Math.min(0, s.max)),
        w = [[]]; // Constructor
    // Generate wheels

    $$1(unique).each(function (i, v) {
      j = ord.search(new RegExp(obj[v].re, 'i'));

      if (j > -1) {
        o.push({
          o: j,
          v: v
        });

        if (obj[v].index > obj[max].index) {
          max = v;
        }
      }
    });
    o.sort(function (a, b) {
      return a.o > b.o ? 1 : -1;
    });
    $$1.each(o, function (i, v) {
      wheels[v.v] = i + 1;
      w[0].push(obj[v.v].wheel);
    });
    minParts = getParts(s.min);
    maxParts = getParts(s.max);
    $$1.each(o, function (i, v) {
      genWheel(v.v);
    }); // Extended methods
    // ---

    inst.getVal = function (temp, formatted) {
      return formatted ? inst._getVal(temp) : inst._hasValue || temp ? calcTime(inst.getArrayVal(temp)) : null;
    }; // ---
    // Return settings


    return {
      minWidth: 100,
      showLabel: true,
      wheels: w,
      compClass: 'mbsc-ts mbsc-sc',
      parseValue: function parseValue(val) {
        var ret = [],
            m;

        if (isNumeric(val) || !val) {
          p = getParts(val || defaultVal);
          $$1.each(o, function (i, v) {
            ret.push(p[v.v]);
          });
        } else {
          $$1.each(o, function (i, v) {
            m = new RegExp('(\\d+)\\s?(' + s.labels[obj[v.v].ord] + '|' + s.labelsShort[obj[v.v].ord] + ')', 'gi').exec(val);
            ret.push(m ? m[1] : 0);
          });
        }

        $$1(ret).each(function (i, v) {
          // Steps
          ret[i] = step(v, steps[i] || 1);
        });
        return ret;
      },
      formatValue: function formatValue(d) {
        var ret = '';
        $$1.each(o, function (i, v) {
          ret += +d[i] ? d[i] + ' ' + obj[v.v].label + ' ' : '';
        });
        return ret ? ret.replace(/\s+$/g, '') : 0;
      },
      validate: function validate(data) {
        var p,
            i,
            index,
            dis,
            values = data.values,
            dir = data.direction,
            disabled = [],
            maxprop = true,
            minprop = true;
        $$1(unique).each(function (x, v) {
          if (wheels[v] !== undefined) {
            index = wheels[v] - 1;
            disabled[index] = [];
            dis = {};

            if (v != max) {
              if (maxprop) {
                for (i = maxParts[v] + 1; i <= obj[v].until; i++) {
                  dis[i] = true;
                }
              }

              if (minprop) {
                for (i = 0; i < minParts[v]; i++) {
                  dis[i] = true;
                }
              }
            }

            values[index] = inst.getValidValue(index, values[index], dir, dis);
            p = getParts(calcTime(values));
            maxprop = maxprop && p[v] == maxParts[v];
            minprop = minprop && p[v] == minParts[v];
            $$1.each(dis, function (i) {
              disabled[index].push(i);
            });
          }
        });
        return {
          disabled: disabled
        };
      }
    };
  };

  var MbscTimespan = (function (_super) {
      __extends(MbscTimespan, _super);
      function MbscTimespan(initialElement, zone, control, inputService, optionService, view) {
          var _this = _super.call(this, initialElement, zone, control, inputService, view) || this;
          _this.optionService = optionService;
          _this.options = {};
          _this.onChangeEmitter = new core.EventEmitter();
          return _this;
      }
      Object.defineProperty(MbscTimespan.prototype, "value", {
          set: function (v) {
              this.setNewValueProxy(v);
          },
          enumerable: true,
          configurable: true
      });
      MbscTimespan.prototype.setNewValue = function (v) {
          if (this.instance) {
              var innerValue = this.instance.getVal();
              if (innerValue !== v) {
                  this.instance.setVal(v, true, false);
                  if (this._inputService && this._inputService.input) {
                      this._inputService.input.innerValue = this.instance._value;
                  }
              }
          }
      };
      MbscTimespan.prototype.initControl = function () {
          var options = extend$1({ preset: 'timespan' }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
          this.instance = new Timespan(this.element, options);
          if (this.initialValue !== undefined) {
              this.instance.setVal(this.initialValue, true, false);
          }
      };
      MbscTimespan.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mbsc-timespan]',
                      exportAs: 'mobiscroll'
                  },] },
      ];
      MbscTimespan.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: core.ViewContainerRef, },
      ]; };
      MbscTimespan.propDecorators = {
          'defaultValue': [{ type: core.Input },],
          'max': [{ type: core.Input },],
          'min': [{ type: core.Input },],
          'steps': [{ type: core.Input },],
          'useShortLabels': [{ type: core.Input },],
          'wheelOrder': [{ type: core.Input },],
          'labels': [{ type: core.Input },],
          'labelsShort': [{ type: core.Input },],
          'options': [{ type: core.Input, args: ['mbsc-options',] },],
          'value': [{ type: core.Input, args: ['mbsc-timespan',] },],
          'onChangeEmitter': [{ type: core.Output, args: ['mbsc-timespanChange',] },],
      };
      return MbscTimespan;
  }(MbscScrollerBase));
  var MbscTimespanComponent = (function (_super) {
      __extends(MbscTimespanComponent, _super);
      function MbscTimespanComponent(initialElem, zone, control, inputService, optionService) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
          _this.errorMessage = '';
          _this.placeholder = '';
          return _this;
      }
      MbscTimespanComponent.prototype.ngAfterViewInit = function () {
          _super.prototype.ngAfterViewInit.call(this);
          this.setThemeClasses();
      };
      MbscTimespanComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-timespan',
                      exportAs: 'mobiscroll',
                      template: INPUT_TEMPLATE
                  },] },
      ];
      MbscTimespanComponent.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscTimespanComponent.propDecorators = {
          'inputIcon': [{ type: core.Input, args: ['icon',] },],
          'iconAlign': [{ type: core.Input, args: ['icon-align',] },],
          'name': [{ type: core.Input },],
          'error': [{ type: core.Input },],
          'errorMessage': [{ type: core.Input },],
          'options': [{ type: core.Input },],
          'placeholder': [{ type: core.Input },],
      };
      return MbscTimespanComponent;
  }(MbscTimespan));
  var MbscTimespanModule = (function () {
      function MbscTimespanModule() {
      }
      MbscTimespanModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule, MbscScrollerBaseModule, MbscInputModule],
                      declarations: [MbscTimespan, MbscTimespanComponent],
                      exports: [MbscTimespan, MbscTimespanComponent]
                  },] },
      ];
      MbscTimespanModule.ctorParameters = function () { return []; };
      return MbscTimespanModule;
  }());

  var Treelist = Scroller;
  presets.treelist = List;

  var MbscTreelist = (function (_super) {
      __extends(MbscTreelist, _super);
      function MbscTreelist(initialElement, zone, control, inputService, optionService, view) {
          var _this = _super.call(this, initialElement, zone, control, inputService, view) || this;
          _this.optionService = optionService;
          _this.placeholder = '';
          _this.options = {};
          _this.onChangeEmitter = new core.EventEmitter();
          return _this;
      }
      Object.defineProperty(MbscTreelist.prototype, "value", {
          set: function (v) {
              this.setNewValueProxy(v);
          },
          enumerable: true,
          configurable: true
      });
      MbscTreelist.prototype.initControl = function () {
          var _this = this;
          var target = this.target;
          if (target) {
              if (typeof target !== 'string' && target._elementRef && target._elementRef.nativeElement) {
                  target = target._elementRef.nativeElement;
              }
              else if (target.getInputElement) {
                  target.getInputElement().then(function (inp) {
                      _this.updateOptions({ input: inp }, true, false, false);
                  });
              }
          }
          var options = extend$1({ preset: 'treelist', input: target }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
          this.instance = new Treelist(this.element, options);
          if (this.initialValue !== undefined) {
              this.instance.setVal(this.initialValue, true, false);
          }
      };
      MbscTreelist.prototype.setNewValue = function (v) {
          if (this.instance && this.instance.getVal() !== v) {
              this.instance.setVal(v, true, false);
              if (this._inputService && this._inputService.input) {
                  this._inputService.input.innerValue = this.instance._value;
              }
          }
      };
      MbscTreelist.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mbsc-treelist]',
                      exportAs: 'mobiscroll'
                  },] },
      ];
      MbscTreelist.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
          { type: core.ViewContainerRef, },
      ]; };
      MbscTreelist.propDecorators = {
          'defaultValue': [{ type: core.Input },],
          'inputClass': [{ type: core.Input },],
          'invalid': [{ type: core.Input },],
          'labels': [{ type: core.Input },],
          'placeholder': [{ type: core.Input },],
          'showInput': [{ type: core.Input },],
          'wheelArray': [{ type: core.Input, args: ['mbsc-data',] },],
          'options': [{ type: core.Input, args: ['mbsc-options',] },],
          'target': [{ type: core.Input, args: ['mbsc-target',] },],
          'value': [{ type: core.Input, args: ['mbsc-treelist',] },],
          'onChangeEmitter': [{ type: core.Output, args: ['mbsc-treelistChange',] },],
      };
      return MbscTreelist;
  }(MbscScrollerBase));
  var MbscTreelistComponent = (function (_super) {
      __extends(MbscTreelistComponent, _super);
      function MbscTreelistComponent(initialElem, zone, control, inputService, optionService) {
          var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
          _this.errorMessage = '';
          _this.placeholder = '';
          _this.showInput = false;
          _this.inlineOptionsObj = {
              showInput: false
          };
          return _this;
      }
      MbscTreelistComponent.prototype.ngAfterViewInit = function () {
          _super.prototype.ngAfterViewInit.call(this);
          this.setThemeClasses();
      };
      MbscTreelistComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'mbsc-treelist',
                      exportAs: 'mobiscroll',
                      template: INPUT_TEMPLATE
                  },] },
      ];
      MbscTreelistComponent.ctorParameters = function () { return [
          { type: core.ElementRef, },
          { type: core.NgZone, },
          { type: forms.NgControl, decorators: [{ type: core.Optional },] },
          { type: MbscInputService, decorators: [{ type: core.Optional },] },
          { type: MbscOptionsService, decorators: [{ type: core.Optional },] },
      ]; };
      MbscTreelistComponent.propDecorators = {
          'inputIcon': [{ type: core.Input, args: ['icon',] },],
          'iconAlign': [{ type: core.Input, args: ['icon-align',] },],
          'name': [{ type: core.Input },],
          'error': [{ type: core.Input },],
          'errorMessage': [{ type: core.Input },],
          'options': [{ type: core.Input },],
          'wheelArray': [{ type: core.Input, args: ['data',] },],
          'placeholder': [{ type: core.Input },],
      };
      return MbscTreelistComponent;
  }(MbscTreelist));
  var MbscTreelistModule = (function () {
      function MbscTreelistModule() {
      }
      MbscTreelistModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule, MbscScrollerBaseModule, MbscInputModule],
                      declarations: [MbscTreelist, MbscTreelistComponent],
                      exports: [MbscTreelist, MbscTreelistComponent]
                  },] },
      ];
      MbscTreelistModule.ctorParameters = function () { return []; };
      return MbscTreelistModule;
  }());

  var directives = [
      MbscInput,
      MbscCalendar, MbscCalendarComponent,
      MbscCard, MbscCardComponent, MbscCardContent, MbscCardFooter, MbscCardHeader, MbscCardSubtitle, MbscCardTitle,
      MbscColor, MbscColorComponent,
      MbscDate, MbscTime, MbscDatetime, MbscDateComponent, MbscTimeComponent, MbscDatetimeComponent,
      MbscEventcalendar, MbscEventcalendarComponent,
      MbscForm, MbscRating, MbscDropdown, MbscTextarea, MbscButton, MbscCheckbox, MbscSwitch, MbscStepper, MbscProgress, MbscSlider, MbscRadio, MbscRadioGroup, MbscSegmentedGroup, MbscSegmented, MbscFormGroup, MbscFormGroupTitle, MbscFormGroupContent, MbscAccordion,
      MbscImage, MbscImageComponent, MbscImageItem,
      MbscListview, MbscListviewSublist, MbscListviewItem, MbscListviewHeader,
      MbscMeasurement, MbscDistance, MbscForce, MbscMass, MbscSpeed, MbscTemperature, MbscMeasurementComponent, MbscTemperatureComponent, MbscForceComponent, MbscSpeedComponent, MbscMassComponent, MbscDistanceComponent,
      MbscNav, MbscBottomNav, MbscHamburgerNav, MbscTabNav, MbscNavItem,
      MbscNumber, MbscNumberComponent,
      MbscNumpad, MbscNumpadDecimal, MbscNumpadDate, MbscNumpadTime, MbscNumpadTimespan, MbscNumpadComponent, MbscNumpadDateComponent, MbscNumpadDecimalComponent, MbscNumpadTimeComponent, MbscNumpadTimespanComponent,
      MbscOptionlist, MbscOptionItem,
      MbscPage, MbscNote, MbscAvatar,
      MbscPopup, MbscWidget,
      MbscRange, MbscRangeComponent, MbscRangeStartComponent, MbscRangeEndComponent,
      MbscScroller, MbscScrollerComponent,
      MbscScrollView, MbscScrollViewItem, MbscScrollViewComponent, MbscScrollViewItemComponent,
      MbscSelect, MbscSelectComponent,
      MbscTimer, MbscTimerComponent,
      MbscTimespan, MbscTimespanComponent,
      MbscTreelist, MbscTreelistComponent,
  ];
  var modules = [
      MbscInputModule,
      MbscCalendarModule,
      MbscCardModule,
      MbscColorModule,
      MbscDatetimeModule,
      MbscEventcalendarModule,
      MbscFormsModule,
      MbscImageModule,
      MbscListviewModule,
      MbscMeasurementModule,
      MbscNavigationModule,
      MbscNumberModule,
      MbscNumpadModule,
      MbscOptionlistModule,
      MbscPageModule,
      MbscPopupModule,
      MbscRangeModule,
      MbscScrollerModule,
      MbscScrollViewModule,
      MbscSelectModule,
      MbscTimerModule,
      MbscTimespanModule,
      MbscTreelistModule
  ];
  var MbscModule = (function () {
      function MbscModule() {
      }
      MbscModule.forRoot = function (config) {
          return {
              ngModule: MbscModule,
              providers: [{
                      provide: MbscRouterToken,
                      useExisting: config.angularRouter
                  }]
          };
      };
      MbscModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [forms.FormsModule, common.CommonModule, modules],
                      exports: [directives, modules]
                  },] },
      ];
      MbscModule.ctorParameters = function () { return []; };
      return MbscModule;
  }());

  // Arabic

  function intPart(floatNum) {
    if (floatNum < -0.0000001) {
      return Math.ceil(floatNum - 0.0000001);
    }

    return Math.floor(floatNum + 0.0000001);
  }

  function hijriToGregorian(hY, hM, hD) {
    hY = parseInt(hY);
    hM = parseInt(hM);
    hD = parseInt(hD);
    var jd,
        l,
        j,
        n,
        i,
        k,
        gregDate = new Array(3);
    jd = intPart((11 * hY + 3) / 30) + 354 * hY + 30 * hM - intPart((hM - 1) / 2) + hD + 1948440 - 385;

    if (jd > 2299160) {
      l = jd + 68569;
      n = intPart(4 * l / 146097);
      l = l - intPart((146097 * n + 3) / 4);
      i = intPart(4000 * (l + 1) / 1461001);
      l = l - intPart(1461 * i / 4) + 31;
      j = intPart(80 * l / 2447);
      hD = l - intPart(2447 * j / 80);
      l = intPart(j / 11);
      hM = j + 2 - 12 * l;
      hY = 100 * (n - 49) + i + l;
    } else {
      j = jd + 1402;
      k = intPart((j - 1) / 1461);
      l = j - 1461 * k;
      n = intPart((l - 1) / 365) - intPart(l / 1461);
      i = l - 365 * n + 30;
      j = intPart(80 * i / 2447);
      hD = i - intPart(2447 * j / 80);
      i = intPart(j / 11);
      hM = j + 2 - 12 * i;
      hY = 4 * k + n + i - 4716;
    }

    gregDate[2] = hD;
    gregDate[1] = hM;
    gregDate[0] = hY;
    return gregDate;
  }

  function gregorianToHijri(gY, gM, gD) {
    gY = parseInt(gY);
    gM = parseInt(gM);
    gD = parseInt(gD);
    var jd,
        l,
        j,
        n,
        hijriDate = new Array(0, 0, 0);

    if (gY > 1582 || gY == 1582 && gM > 10 || gY == 1582 && gM == 10 && gD > 14) {
      jd = intPart(1461 * (gY + 4800 + intPart((gM - 14) / 12)) / 4) + intPart(367 * (gM - 2 - 12 * intPart((gM - 14) / 12)) / 12) - intPart(3 * intPart((gY + 4900 + intPart((gM - 14) / 12)) / 100) / 4) + gD - 32075;
    } else {
      jd = 367 * gY - intPart(7 * (gY + 5001 + intPart((gM - 9) / 7)) / 4) + intPart(275 * gM / 9) + gD + 1729777;
    }

    l = jd - 1948440 + 10632;
    n = intPart((l - 1) / 10631);
    l = l - 10631 * n + 354;
    j = intPart((10985 - l) / 5316) * intPart(50 * l / 17719) + intPart(l / 5670) * intPart(43 * l / 15238);
    l = l - intPart((30 - j) / 15) * intPart(17719 * j / 50) - intPart(j / 16) * intPart(15238 * j / 43) + 29;
    gM = intPart(24 * l / 709);
    gD = l - intPart(709 * gM / 24);
    gY = 30 * n + j - 30;
    hijriDate[2] = gD;
    hijriDate[1] = gM;
    hijriDate[0] = gY;
    return hijriDate;
  }

  calendars.hijri = {
    getYear: function getYear(date) {
      return gregorianToHijri(date.getFullYear(), date.getMonth() + 1, date.getDate())[0];
    },
    getMonth: function getMonth(date) {
      return --gregorianToHijri(date.getFullYear(), date.getMonth() + 1, date.getDate())[1];
    },
    getDay: function getDay(date) {
      return gregorianToHijri(date.getFullYear(), date.getMonth() + 1, date.getDate())[2];
    },
    getDate: function getDate(y, m, d, h, i, s, u) {
      if (m < 0) {
        y += Math.floor(m / 12);
        m = m % 12 ? 12 + m % 12 : 0;
      }

      if (m > 11) {
        y += Math.floor(m / 12);
        m = m % 12;
      }

      var gregorianDate = hijriToGregorian(y, +m + 1, d);
      return new Date(gregorianDate[0], gregorianDate[1] - 1, gregorianDate[2], h || 0, i || 0, s || 0, u || 0);
    },
    getMaxDayOfMonth: function getMaxDayOfMonth(hY, hM) {
      if (hM < 0) {
        hY += Math.floor(hM / 12);
        hM = hM % 12 ? 12 + hM % 12 : 0;
      }

      if (hM > 11) {
        hY += Math.floor(hM / 12);
        hM = hM % 12;
      }

      var daysPerMonth = [30, 29, 30, 29, 30, 29, 30, 29, 30, 29, 30, 29],
          leapYear = (hY * 11 + 14) % 30 < 11;
      return daysPerMonth[hM] + (hM === 11 && leapYear ? 1 : 0);
    }
  };

  // Arabic
  mobiscroll.i18n.ar = {
    // Core
    rtl: true,
    // Right to left mode
    setText: 'تعيين',
    cancelText: 'إلغاء',
    clearText: 'مسح',
    selectedText: '{count} المحدد',
    // Datetime component
    dateFormat: 'dd/mm/yy',
    dayNames: ['الأحد', 'الاثنين', 'الثلاثاء', 'الأربعاء', 'الخميس', 'الجمعة', 'السبت'],
    dayNamesShort: ['أحد', 'اثنين', 'ثلاثاء', 'أربعاء', 'خميس', 'جمعة', 'سبت'],
    dayNamesMin: ['ح', 'ن', 'ث', 'ر', 'خ', 'ج', 'س'],
    dayText: 'يوم',
    hourText: 'ساعات',
    minuteText: 'الدقائق',
    monthNames: ['يناير', 'فبراير', 'مارس', 'ابريل', 'مايو', 'يونيو', 'يوليو', 'أغسطس', 'سبتمبر', 'أكتوبر', 'نوفمبر', 'ديسمبر'],
    monthNamesShort: ['يناير', 'فبراير', 'مارس', 'ابريل', 'مايو', 'يونيو', 'يوليو', 'أغسطس', 'سبتمبر', 'أكتوبر', 'نوفمبر', 'ديسمبر'],
    monthText: 'شهر',
    secText: 'ثواني',
    amText: 'ص',
    pmText: 'م',
    timeFormat: 'hh:ii A',
    yearText: 'عام',
    nowText: 'الآن',
    // Calendar component
    firstDay: 0,
    dateText: 'تاريخ',
    timeText: 'وقت',
    closeText: 'إغلاق',
    todayText: 'اليوم',
    prevMonthText: 'الشهر السابق',
    nextMonthText: 'الشهر القادم',
    prevYearText: 'السنه السابقة',
    nextYearText: 'العام القادم',
    allDayText: 'اليوم كله',
    noEventsText: 'لا توجد احداث',
    // Event calendar
    eventText: 'الحدث',
    eventsText: 'أحداث',
    moreEventsText: 'واحد آخر',
    moreEventsPluralText: 'اثنان آخران {count}',
    // Daterange component
    fromText: 'يبدا',
    toText: 'ينتهي',
    // Measurement components
    wholeText: 'كامل',
    fractionText: 'جزء',
    unitText: 'وحدة',
    // Numpad date
    delimiter: '/',
    // Numpad decimal
    decimalSeparator: '.',
    thousandsSeparator: ',',
    // Timer / Timespan component
    labels: ['سنوات', 'أشهر', 'أيام', 'ساعة', 'دقائق', 'ثواني', ''],
    labelsShort: ['سنوات', 'أشهر', 'أيام', 'ساعة', 'دقائق', 'ثواني', ''],
    // Timer component
    startText: 'بدء',
    stopText: 'إيقاف',
    resetText: 'إعادة ضبط',
    lapText: 'الدورة',
    hideText: 'إخفاء',
    // Forms
    offText: 'إيقاف',
    onText: 'تشغيل',
    // Listview
    backText: 'رجوع',
    undoText: 'تراجع'
  };

  // Bulgarian
  mobiscroll.i18n.bg = {
    // Core
    setText: 'Задаване',
    cancelText: 'Отмяна',
    clearText: 'Изчистване',
    selectedText: '{count} подбран',
    // Datetime component
    dateFormat: 'dd.mm.yy',
    dayNames: ['Неделя', 'Понеделник', 'Вторник', 'Сряда', 'Четвъртък', 'Петък', 'Събота'],
    dayNamesShort: ['Нед', 'Пон', 'Вто', 'Сря', 'Чет', 'Пет', 'Съб'],
    dayNamesMin: ['Не', 'По', 'Вт', 'Ср', 'Че', 'Пе', 'Съ'],
    dayText: 'ден',
    delimiter: '.',
    hourText: 'час',
    minuteText: 'минута',
    monthNames: ['Януари', 'Февруари', 'Март', 'Април', 'Май', 'Юни', 'Юли', 'Август', 'Септември', 'Октомври', 'Ноември', 'Декември'],
    monthNamesShort: ['Яну', 'Фев', 'Мар', 'Апр', 'Май', 'Юни', 'Юли', 'Авг', 'Сеп', 'Окт', 'Нов', 'Дек'],
    monthText: 'месец',
    secText: 'секунди',
    timeFormat: 'H:ii',
    yearText: 'година',
    nowText: 'Сега',
    pmText: 'pm',
    amText: 'am',
    // Calendar component
    firstDay: 1,
    dateText: 'Дата',
    timeText: 'път',
    todayText: 'днес',
    prevMonthText: 'Предишния месец',
    nextMonthText: 'Следващият месец',
    prevYearText: 'Предходната година',
    nextYearText: 'Следващата година',
    closeText: 'затвори',
    eventText: 'Събитие',
    eventsText: 'Събития',
    allDayText: 'Цял ден',
    noEventsText: 'Няма събития',
    moreEventsText: 'Още {count}',
    // Daterange component
    fromText: 'ОТ',
    toText: 'ДО',
    // Measurement components
    wholeText: 'цяло',
    fractionText: 'фракция',
    unitText: 'единица',
    // Time / Timespan component
    labels: ['Години', 'месеца', 'дни', 'часа', 'минути', 'секунди', ''],
    labelsShort: ['Години', 'месеца', 'дни', 'часа', 'минути', 'секунди', ''],
    // Timer component
    startText: 'Старт',
    stopText: 'Стоп',
    resetText: 'Нулиране',
    lapText: 'Обиколка',
    hideText: 'крия',
    // Listview
    backText: 'връщане',
    undoText: 'ОТМЯНА',
    // Form
    offText: 'ИЗКЛ',
    onText: 'ВКЛ',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Català
  mobiscroll.i18n.ca = {
    // Core
    setText: 'Acceptar',
    cancelText: 'Cancel·lar',
    clearText: 'Esborrar',
    selectedText: '{count} seleccionat',
    selectedPluralText: '{count} seleccionats',
    // Datetime component
    dateFormat: 'dd/mm/yy',
    dayNames: ['Diumenge', 'Dilluns', 'Dimarts', 'Dimecres', 'Dijous', 'Divendres', 'Dissabte'],
    dayNamesShort: ['Dg', 'Dl', 'Dt', 'Dc', 'Dj', 'Dv', 'Ds'],
    dayNamesMin: ['Dg', 'Dl', 'Dt', 'Dc', 'Dj', 'Dv', 'Ds'],
    dayText: 'Dia',
    hourText: 'Hores',
    minuteText: 'Minuts',
    monthNames: ['Gener', 'Febrer', 'Març', 'Abril', 'Maig', 'Juny', 'Juliol', 'Agost', 'Setembre', 'Octubre', 'Novembre', 'Desembre'],
    monthNamesShort: ['Gen', 'Feb', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Oct', 'Nov', 'Des'],
    monthText: 'Mes',
    secText: 'Segons',
    timeFormat: 'HH:ii',
    yearText: 'Any',
    nowText: 'Ara',
    pmText: 'pm',
    amText: 'am',
    todayText: 'Avui',
    // Calendar component
    firstDay: 1,
    dateText: 'Data',
    timeText: 'Temps',
    closeText: 'Tancar',
    allDayText: 'Tot el dia',
    noEventsText: 'Cap esdeveniment',
    eventText: 'Esdeveniments',
    eventsText: 'Esdeveniments',
    moreEventsText: '{count} més',
    // Daterange component
    fromText: 'Iniciar',
    toText: 'Final',
    // Measurement components
    wholeText: 'Sencer',
    fractionText: 'Fracció',
    unitText: 'Unitat',
    // Time / Timespan component
    labels: ['Anys', 'Mesos', 'Dies', 'Hores', 'Minuts', 'Segons', ''],
    labelsShort: ['Anys', 'Mesos', 'Dies', 'Hrs', 'Mins', 'Secs', ''],
    // Timer component
    startText: 'Iniciar',
    stopText: 'Aturar',
    resetText: 'Reiniciar',
    lapText: 'Volta',
    hideText: 'Amagar',
    // Listview
    backText: 'Enrere',
    undoText: 'Desfés',
    // Form
    offText: 'No',
    onText: 'Si'
  };

  // Cestina
  mobiscroll.i18n.cs = {
    // Core
    setText: 'Zadej',
    cancelText: 'Storno',
    clearText: 'Vymazat',
    selectedText: 'Označený: {count}',
    // Datetime component
    dateFormat: 'dd.mm.yy',
    dayNames: ['Neděle', 'Pondělí', 'Úterý', 'Středa', 'Čtvrtek', 'Pátek', 'Sobota'],
    dayNamesShort: ['Ne', 'Po', 'Út', 'St', 'Čt', 'Pá', 'So'],
    dayNamesMin: ['N', 'P', 'Ú', 'S', 'Č', 'P', 'S'],
    dayText: 'Den',
    hourText: 'Hodiny',
    minuteText: 'Minuty',
    monthNames: ['Leden', 'Únor', 'Březen', 'Duben', 'Květen', 'Červen', 'Červenec', 'Srpen', 'Září', 'Říjen', 'Listopad', 'Prosinec'],
    monthNamesShort: ['Led', 'Úno', 'Bře', 'Dub', 'Kvě', 'Čer', 'Čvc', 'Spr', 'Zář', 'Říj', 'Lis', 'Pro'],
    monthText: 'Měsíc',
    secText: 'Sekundy',
    timeFormat: 'HH:ii',
    yearText: 'Rok',
    nowText: 'Teď',
    amText: 'am',
    pmText: 'pm',
    todayText: 'Dnes',
    // Calendar component
    firstDay: 1,
    dateText: 'Datum',
    timeText: 'Čas',
    closeText: 'Zavřít',
    allDayText: 'Celý den',
    noEventsText: 'Žádné události',
    eventText: 'Událostí',
    eventsText: 'Události',
    moreEventsText: '{count} další',
    // Daterange component
    fromText: 'Začátek',
    toText: 'Konec',
    // Measurement components
    wholeText: 'Celý',
    fractionText: 'Část',
    unitText: 'Jednotka',
    // Time / Timespan component
    labels: ['Roky', 'Měsíce', 'Dny', 'Hodiny', 'Minuty', 'Sekundy', ''],
    labelsShort: ['Rok', 'Měs', 'Dny', 'Hod', 'Min', 'Sec', ''],
    // Timer component
    startText: 'Start',
    stopText: 'Stop',
    resetText: 'Resetovat',
    lapText: 'Etapa',
    hideText: 'Schovat',
    // Listview
    backText: 'Zpět',
    undoText: 'Zpět',
    // Form
    offText: 'O',
    onText: 'I',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Dansk
  mobiscroll.i18n.da = {
    // Core
    setText: 'Sæt',
    cancelText: 'Annuller',
    clearText: 'Ryd',
    selectedText: '{count} valgt',
    selectedPluralText: '{count} valgt',
    // Datetime component
    dateFormat: 'dd/mm/yy',
    dayNames: ['Søndag', 'Mandag', 'Tirsdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lørdag'],
    dayNamesShort: ['Søn', 'Man', 'Tir', 'Ons', 'Tor', 'Fre', 'Lør'],
    dayNamesMin: ['S', 'M', 'T', 'O', 'T', 'F', 'L'],
    dayText: 'Dag',
    hourText: 'Timer',
    minuteText: 'Minutter',
    monthNames: ['Januar', 'Februar', 'Marts', 'April', 'Maj', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'December'],
    monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Maj', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dec'],
    monthText: 'Måned',
    secText: 'Sekunder',
    amText: 'am',
    pmText: 'pm',
    timeFormat: 'HH.ii',
    yearText: 'År',
    nowText: 'Nu',
    todayText: 'I dag',
    // Calendar component
    firstDay: 1,
    dateText: 'Dato',
    timeText: 'Tid',
    closeText: 'Luk',
    allDayText: 'Hele dagen',
    noEventsText: 'Ingen begivenheder',
    eventText: 'Begivenheder',
    eventsText: 'Begivenheder',
    moreEventsText: '{count} mere',
    // Daterange component
    fromText: 'Start',
    toText: 'Slut',
    // Measurement components
    wholeText: 'Hele',
    fractionText: 'Dele',
    unitText: 'Enhed',
    // Time / Timespan component
    labels: ['År', 'Måneder', 'Dage', 'Timer', 'Minutter', 'Sekunder', ''],
    labelsShort: ['År', 'Mdr', 'Dg', 'Timer', 'Min', 'Sek', ''],
    // Timer component
    startText: 'Start',
    stopText: 'Stop',
    resetText: 'Nulstil',
    lapText: 'Omgang',
    hideText: 'Skjul',
    // Forms
    offText: 'Fra',
    onText: 'Til',
    // Listview
    backText: 'Tilbage',
    undoText: 'Fortryd'
  };

  // Deutsch
  mobiscroll.i18n.de = {
    // Core
    setText: 'OK',
    cancelText: 'Abbrechen',
    clearText: 'Löschen',
    selectedText: '{count} ausgewählt',
    // Datetime component
    dateFormat: 'dd.mm.yy',
    dayNames: ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'],
    dayNamesShort: ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
    dayNamesMin: ['S', 'M', 'D', 'M', 'D', 'F', 'S'],
    dayText: 'Tag',
    delimiter: '.',
    hourText: 'Stunde',
    minuteText: 'Minuten',
    monthNames: ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
    monthNamesShort: ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'],
    monthText: 'Monat',
    secText: 'Sekunden',
    timeFormat: 'HH:ii',
    yearText: 'Jahr',
    nowText: 'Jetzt',
    pmText: 'pm',
    amText: 'am',
    todayText: 'Heute',
    // Calendar component
    firstDay: 1,
    dateText: 'Datum',
    timeText: 'Zeit',
    closeText: 'Schließen',
    allDayText: 'Ganztägig',
    noEventsText: 'Keine Ereignisse',
    eventText: 'Ereignis',
    eventsText: 'Ereignisse',
    moreEventsText: '{count} weiteres Element',
    moreEventsPluralText: '{count} weitere Elemente',
    // Daterange component
    fromText: 'Von',
    toText: 'Bis',
    // Measurement components
    wholeText: 'Ganze Zahl',
    fractionText: 'Bruchzahl',
    unitText: 'Maßeinheit',
    // Time / Timespan component
    labels: ['Jahre', 'Monate', 'Tage', 'Stunden', 'Minuten', 'Sekunden', ''],
    labelsShort: ['Jahr.', 'Mon.', 'Tag.', 'Std.', 'Min.', 'Sek.', ''],
    // Timer component
    startText: 'Starten',
    stopText: 'Stoppen',
    resetText: 'Zurücksetzen',
    lapText: 'Lap',
    hideText: 'Ausblenden',
    // Listview
    backText: 'Zurück',
    undoText: 'Rückgängig machen',
    // Form
    offText: 'Aus',
    onText: 'Ein',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Greek
  mobiscroll.i18n.el = {
    // Core
    setText: 'Ορισμος',
    cancelText: 'Ακυρωση',
    clearText: 'Διαγραφη',
    selectedText: '{count} επιλεγμένα',
    // Datetime component
    dateFormat: 'dd/mm/yy',
    dayNames: ['Κυριακή', 'Δευτέρα', 'Τρίτη', 'Τετάρτη', 'Πέμπτη', 'Παρασκευή', 'Σάββατο'],
    dayNamesShort: ['Κυρ', 'Δευ', 'Τρι', 'Τετ', 'Πεμ', 'Παρ', 'Σαβ'],
    dayNamesMin: ['Κυ', 'Δε', 'Τρ', 'Τε', 'Πε', 'Πα', 'Σα'],
    dayText: 'ημέρα',
    delimiter: '/',
    hourText: 'ώρα',
    minuteText: 'λεπτό',
    monthNames: ['Ιανουάριος', 'Φεβρουάριος', 'Μάρτιος', 'Απρίλιος', 'Μάιος', 'Ιούνιος', 'Ιούλιος', 'Αύγουστος', 'Σεπτέμβριος', 'Οκτώβριος', 'Νοέμβριος', 'Δεκέμβριος'],
    monthNamesShort: ['Ιαν', 'Φεβ', 'Μαρ', 'Απρ', 'Μαι', 'Ιουν', 'Ιουλ', 'Αυγ', 'Σεπ', 'Οκτ', 'Νοε', 'Δεκ'],
    monthText: 'Μήνας',
    secText: 'δευτερόλεπτα',
    timeFormat: 'H:ii',
    yearText: 'έτος',
    nowText: 'τώρα',
    pmText: 'μμ',
    amText: 'πμ',
    // Calendar component
    firstDay: 1,
    dateText: 'Ημερομηνία',
    timeText: 'φορά',
    todayText: 'Σήμερα',
    prevMonthText: 'Προηγούμενο μήνα',
    nextMonthText: 'Επόμενο μήνα',
    prevYearText: 'Προηγούμενο έτος',
    nextYearText: 'Επόμενο έτος',
    closeText: 'Κλείσιμο',
    eventText: 'Γεγονότα',
    eventsText: 'Γεγονότα',
    allDayText: 'Ολοήμερο',
    noEventsText: 'Δεν υπάρχουν γεγονότα',
    moreEventsText: '{count} ακόμη',
    // Daterange component
    fromText: 'Αρχή',
    toText: 'Τέλος',
    // Measurement components
    wholeText: 'Ολόκληρος',
    fractionText: 'κλάσμα',
    unitText: 'Μονάδα',
    // Time / Timespan component
    labels: ['Χρόνια', 'Μήνες', 'Ημέρες', 'Ωρες', 'Λεπτά', 'δευτερόλεπτα', ''],
    labelsShort: ['Χρόνια', 'Μήνες', 'Ημέρες', 'Ωρες', 'Λεπτά', 'δευτ', ''],
    // Timer component
    startText: '΄Εναρξη',
    stopText: 'Διακοπή',
    resetText: 'Επαναφορά',
    lapText: 'Γύρος',
    hideText: 'κρύβω',
    // Listview
    backText: 'Πίσω',
    undoText: 'Αναιρεση',
    // Form
    offText: 'Ανενεργό',
    onText: 'Ενεργό',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // English (UK)
  mobiscroll.i18n['en-GB'] = mobiscroll.i18n['en-UK'] = {
    dateFormat: 'dd/mm/yy',
    timeFormat: 'HH:ii'
  };

  // Español
  mobiscroll.i18n.es = {
    // Core
    setText: 'Aceptar',
    cancelText: 'Cancelar',
    clearText: 'Borrar',
    selectedText: '{count} seleccionado',
    selectedPluralText: '{count} seleccionados',
    // Datetime component
    dateFormat: 'dd/mm/yy',
    dayNames: ['Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado'],
    dayNamesShort: ['Do', 'Lu', 'Ma', 'Mi', 'Ju', 'Vi', 'Sá'],
    dayNamesMin: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
    dayText: 'Día',
    hourText: 'Horas',
    minuteText: 'Minutos',
    monthNames: ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'],
    monthNamesShort: ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'],
    monthText: 'Mes',
    secText: 'Segundos',
    timeFormat: 'HH:ii',
    yearText: 'A&ntilde;o',
    nowText: 'Ahora',
    pmText: 'pm',
    amText: 'am',
    todayText: 'Hoy',
    // Calendar component
    firstDay: 1,
    dateText: 'Fecha',
    timeText: 'Tiempo',
    closeText: 'Cerrar',
    allDayText: 'Todo el día',
    noEventsText: 'No hay eventos',
    eventText: 'Evento',
    eventsText: 'Eventos',
    moreEventsText: '{count} más',
    // Daterange component
    fromText: 'Iniciar',
    toText: 'Final',
    // Measurement components
    wholeText: 'Entero',
    fractionText: 'Fracción',
    unitText: 'Unidad',
    // Time / Timespan component
    labels: ['Años', 'Meses', 'Días', 'Horas', 'Minutos', 'Segundos', ''],
    labelsShort: ['Año', 'Mes', 'Día', 'Hora', 'Min', 'Seg', ''],
    // Timer component
    startText: 'Iniciar',
    stopText: 'Deténgase',
    resetText: 'Reinicializar',
    lapText: 'Lap',
    hideText: 'Esconder',
    // Listview
    backText: 'Atrás',
    undoText: 'Deshacer',
    // Form
    offText: 'No',
    onText: 'Sí',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // فارسی
  var gDaysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
      jDaysInMonth = [31, 31, 31, 31, 31, 31, 30, 30, 30, 30, 30, 29];

  function jalaliToGregorian(jY, jM, jD) {
    jY = parseInt(jY);
    jM = parseInt(jM);
    jD = parseInt(jD);
    var i;
    var jy = jY - 979;
    var jm = jM - 1;
    var jd = jD - 1;
    var jDayNo = 365 * jy + parseInt(jy / 33) * 8 + parseInt((jy % 33 + 3) / 4);

    for (i = 0; i < jm; ++i) {
      jDayNo += jDaysInMonth[i];
    }

    jDayNo += jd;
    var gDayNo = jDayNo + 79;
    var gy = 1600 + 400 * parseInt(gDayNo / 146097);
    gDayNo = gDayNo % 146097;
    var leap = true;

    if (gDayNo >= 36525) {
      gDayNo--;
      gy += 100 * parseInt(gDayNo / 36524);
      gDayNo = gDayNo % 36524;

      if (gDayNo >= 365) {
        gDayNo++;
      } else {
        leap = false;
      }
    }

    gy += 4 * parseInt(gDayNo / 1461);
    gDayNo %= 1461;

    if (gDayNo >= 366) {
      leap = false;
      gDayNo--;
      gy += parseInt(gDayNo / 365);
      gDayNo = gDayNo % 365;
    }

    for (i = 0; gDayNo >= gDaysInMonth[i] + (i == 1 && leap); i++) {
      gDayNo -= gDaysInMonth[i] + (i == 1 && leap);
    }

    var gm = i + 1;
    var gd = gDayNo + 1;
    return [gy, gm, gd];
  }

  function checkDate(jY, jM, jD) {
    return !(jY < 0 || jY > 32767 || jM < 1 || jM > 12 || jD < 1 || jD > jDaysInMonth[jM - 1] + (jM == 12 && (jY - 979) % 33 % 4 === 0));
  }

  function gregorianToJalali(gY, gM, gD) {
    gY = parseInt(gY);
    gM = parseInt(gM);
    gD = parseInt(gD);
    var i;
    var gy = gY - 1600;
    var gm = gM - 1;
    var gd = gD - 1;
    var gDayNo = 365 * gy + parseInt((gy + 3) / 4) - parseInt((gy + 99) / 100) + parseInt((gy + 399) / 400);

    for (i = 0; i < gm; ++i) {
      gDayNo += gDaysInMonth[i];
    }

    if (gm > 1 && (gy % 4 === 0 && gy % 100 !== 0 || gy % 400 === 0)) {
      ++gDayNo;
    }

    gDayNo += gd;
    var jDayNo = gDayNo - 79;
    var jNp = parseInt(jDayNo / 12053);
    jDayNo %= 12053;
    var jy = 979 + 33 * jNp + 4 * parseInt(jDayNo / 1461);
    jDayNo %= 1461;

    if (jDayNo >= 366) {
      jy += parseInt((jDayNo - 1) / 365);
      jDayNo = (jDayNo - 1) % 365;
    }

    for (i = 0; i < 11 && jDayNo >= jDaysInMonth[i]; ++i) {
      jDayNo -= jDaysInMonth[i];
    }

    var jm = i + 1;
    var jd = jDayNo + 1;
    return [jy, jm, jd];
  }

  calendars.jalali = {
    getYear: function getYear(date) {
      return gregorianToJalali(date.getFullYear(), date.getMonth() + 1, date.getDate())[0];
    },
    getMonth: function getMonth(date) {
      return --gregorianToJalali(date.getFullYear(), date.getMonth() + 1, date.getDate())[1];
    },
    getDay: function getDay(date) {
      return gregorianToJalali(date.getFullYear(), date.getMonth() + 1, date.getDate())[2];
    },
    getDate: function getDate(y, m, d, h, i, s, u) {
      if (m < 0) {
        y += Math.floor(m / 12);
        m = m % 12 ? 12 + m % 12 : 0;
      }

      if (m > 11) {
        y += Math.floor(m / 12);
        m = m % 12;
      }

      var gregorianDate = jalaliToGregorian(y, +m + 1, d);
      return new Date(gregorianDate[0], gregorianDate[1] - 1, gregorianDate[2], h || 0, i || 0, s || 0, u || 0);
    },
    getMaxDayOfMonth: function getMaxDayOfMonth(y, m) {
      var maxdays = 31;

      if (m < 0) {
        y += Math.floor(m / 12);
        m = m % 12 ? 12 + m % 12 : 0;
      }

      if (m > 11) {
        y += Math.floor(m / 12);
        m = m % 12;
      }

      while (checkDate(y, m + 1, maxdays) === false) {
        maxdays--;
      }

      return maxdays;
    }
  };

  // فارسی
  mobiscroll.i18n.fa = {
    // Core
    setText: 'تاييد',
    cancelText: 'انصراف',
    clearText: 'واضح ',
    selectedText: '{count} منتخب',
    // Datetime component
    calendarSystem: 'jalali',
    dateFormat: 'yy/mm/dd',
    dayNames: ['يکشنبه', 'دوشنبه', 'سه‌شنبه', 'چهارشنبه', 'پنج‌شنبه', 'جمعه', 'شنبه'],
    dayNamesShort: ['ی', 'د', 'س', 'چ', 'پ', 'ج', 'ش'],
    dayNamesMin: ['ی', 'د', 'س', 'چ', 'پ', 'ج', 'ش'],
    dayText: 'روز',
    hourText: 'ساعت',
    minuteText: 'دقيقه',
    monthNames: ['فروردين', 'ارديبهشت', 'خرداد', 'تير', 'مرداد', 'شهريور', 'مهر', 'آبان', 'آذر', 'دی', 'بهمن', 'اسفند'],
    monthNamesShort: ['فروردين', 'ارديبهشت', 'خرداد', 'تير', 'مرداد', 'شهريور', 'مهر', 'آبان', 'آذر', 'دی', 'بهمن', 'اسفند'],
    monthText: 'ماه',
    secText: 'ثانيه',
    timeFormat: 'HH:ii',
    timeWheels: 'iiHH',
    // Need this for correct RTL display
    yearText: 'سال',
    nowText: 'اکنون',
    amText: 'ب',
    pmText: 'ص',
    todayText: 'امروز',
    //getNumber: function (n) {
    //    var i,
    //        nums = ["۰", "۱", "۲", "۳", "۴", "۵", "۶", "۷", "۸", "۹"],
    //        res = '';
    //    n = n + '';
    //    for (i = 0; i < n.length; i++) {
    //        res += nums[+n[i]];
    //    }
    //    return res;
    //},
    // Calendar component
    firstDay: 6,
    rtl: true,
    dateText: 'تاریخ ',
    timeText: 'زمان ',
    closeText: 'نزدیک',
    allDayText: 'تمام روز',
    noEventsText: 'هیچ رویداد',
    eventText: 'رویداد',
    eventsText: 'رویدادها',
    moreEventsText: '{count} مورد دیگر',
    // Daterange component
    fromText: 'شروع ',
    toText: 'پایان',
    // Measurement components
    wholeText: 'تمام',
    fractionText: 'کسر',
    unitText: 'واحد',
    // Time / Timespan component
    labels: ['سال', 'ماه', 'روز', 'ساعت', 'دقیقه', 'ثانیه', ''],
    labelsShort: ['سال', 'ماه', 'روز', 'ساعت', 'دقیقه', 'ثانیه', ''],
    // Timer component
    startText: 'شروع',
    stopText: 'پايان',
    resetText: 'تنظیم مجدد',
    lapText: 'Lap',
    hideText: 'پنهان کردن',
    // Listview
    backText: 'پشت',
    undoText: 'واچیدن'
  };

  // Suomi
  mobiscroll.i18n.fi = {
    // Core
    setText: 'Aseta',
    cancelText: 'Peruuta',
    clearText: 'Tyhjennä',
    selectedText: '{count} valita',
    // Datetime component
    dateFormat: 'd. MM yy',
    dayNames: ['Sunnuntai', 'Maanantai', 'Tiistai', 'Keskiviiko', 'Torstai', 'Perjantai', 'Lauantai'],
    dayNamesShort: ['Su', 'Ma', 'Ti', 'Ke', 'To', 'Pe', 'La'],
    dayNamesMin: ['S', 'M', 'T', 'K', 'T', 'P', 'L'],
    dayText: 'Päivä',
    delimiter: '.',
    hourText: 'Tuntia',
    minuteText: 'Minuutti',
    monthNames: ['Tammikuu', 'Helmikuu', 'Maaliskuu', 'Huhtikuu', 'Toukokuu', 'Kesäkuu', 'Heinäkuu', 'Elokuu', 'Syyskuu', 'Lokakuu', 'Marraskuu', 'Joulukuu'],
    monthNamesShort: ['Tam', 'Hel', 'Maa', 'Huh', 'Tou', 'Kes', 'Hei', 'Elo', 'Syy', 'Lok', 'Mar', 'Jou'],
    monthText: 'Kuukausi',
    secText: 'Sekunda',
    timeFormat: 'H:ii',
    yearText: 'Vuosi',
    nowText: 'Nyt',
    pmText: 'pm',
    amText: 'am',
    // Calendar component
    firstDay: 1,
    dateText: 'Päiväys',
    timeText: 'Aika',
    todayText: 'Tänään',
    prevMonthText: 'Edellinen kuukausi',
    nextMonthText: 'Ensi kuussa',
    prevYearText: 'Edellinen vuosi',
    nextYearText: 'Ensi vuosi',
    closeText: 'Sulje',
    eventText: 'Tapahtumia',
    eventsText: 'Tapahtumia',
    allDayText: 'Koko päivä',
    noEventsText: 'Ei tapahtumia',
    moreEventsText: '{count} muu',
    moreEventsPluralText: '{count} muuta',
    // Daterange component
    fromText: 'Alkaa',
    toText: 'Päättyy',
    // Measurement components
    wholeText: 'Kokonainen',
    fractionText: 'Murtoluku',
    unitText: 'Yksikkö',
    // Time / Timespan component
    labels: ['Vuosi', 'Kuukausi', 'Päivä', 'Tunnin', 'Minuutti', 'sekuntia', ''],
    labelsShort: ['Vuo', 'Kuu', 'Päi', 'Tun', 'Min', 'Sek', ''],
    // Timer component
    startText: 'Käynnistys',
    stopText: 'Seis',
    resetText: 'Aseta uudelleen',
    lapText: 'Kierros',
    hideText: 'Vuota',
    // Listview
    backText: 'Edellinen',
    undoText: 'Kumoa',
    // Form
    offText: 'Pois',
    onText: 'Päällä',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Français
  mobiscroll.i18n.fr = {
    // Core
    setText: 'Terminer',
    cancelText: 'Annuler',
    clearText: 'Effacer',
    selectedText: '{count} sélectionné',
    selectedPluralText: '{count} sélectionnés',
    // Datetime component
    dateFormat: 'dd/mm/yy',
    dayNames: ['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'],
    dayNamesShort: ['Dim.', 'Lun.', 'Mar.', 'Mer.', 'Jeu.', 'Ven.', 'Sam.'],
    dayNamesMin: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
    dayText: 'Jour',
    monthText: 'Mois',
    monthNames: ['Janvier', 'Février', 'Mars', 'Avril', 'Mai', 'Juin', 'Juillet', 'Août', 'Septembre', 'Octobre', 'Novembre', 'Décembre'],
    monthNamesShort: ['Janv.', 'Févr.', 'Mars', 'Avril', 'Mai', 'Juin', 'Juil.', 'Août', 'Sept.', 'Oct.', 'Nov.', 'Déc.'],
    hourText: 'Heures',
    minuteText: 'Minutes',
    secText: 'Secondes',
    timeFormat: 'HH:ii',
    yearText: 'Année',
    nowText: 'Maintenant',
    pmText: 'pm',
    amText: 'am',
    todayText: "Aujourd'hui",
    // Calendar component
    firstDay: 1,
    dateText: 'Date',
    timeText: 'Heure',
    closeText: 'Fermer',
    allDayText: 'Toute la journée',
    noEventsText: 'Aucun événement',
    eventText: 'Événement',
    eventsText: 'Événements',
    moreEventsText: '{count} autre',
    moreEventsPluralText: '{count} autres',
    // Daterange component
    fromText: 'Démarrer',
    toText: 'Fin',
    // Measurement components
    wholeText: 'Entier',
    fractionText: 'Fraction',
    unitText: 'Unité',
    // Time / Timespan component
    labels: ['Ans', 'Mois', 'Jours', 'Heures', 'Minutes', 'Secondes', ''],
    labelsShort: ['Ans', 'Mois', 'Jours', 'Hrs', 'Min', 'Sec', ''],
    // Timer component
    startText: 'Démarrer',
    stopText: 'Arrêter',
    resetText: 'Réinitialiser',
    lapText: 'Lap',
    hideText: 'Cachez',
    // Listview
    backText: 'Retour',
    undoText: 'Annuler',
    // Form
    offText: 'Non',
    onText: 'Oui',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Hebrew
  mobiscroll.i18n.he = {
    // Core
    rtl: true,
    // Right to left mode
    setText: 'שמירה',
    cancelText: 'ביטול',
    clearText: 'נקה',
    selectedText: '{count} נבחר',
    selectedPluralText: '{count} נבחרו',
    // Datetime component
    dateFormat: 'dd/mm/yy',
    dayNames: ['ראשון', 'שני', 'שלישי', 'רביעי', 'חמישי', 'שישי', 'שבת'],
    dayNamesShort: ["א'", "ב'", "ג'", "ד'", "ה'", "ו'", "ש'"],
    dayNamesMin: ['א', 'ב', 'ג', 'ד', 'ה', 'ו', 'ש'],
    dayText: 'יום',
    hourText: 'שעות',
    minuteText: 'דקות',
    monthNames: ['ינואר', 'פברואר', 'מרץ', 'אפריל', 'מאי', 'יוני', 'יולי', 'אוגוסט', 'ספטמבר', 'אוקטובר', 'נובמבר', 'דצמבר'],
    monthNamesShort: ["ינו", "פבר", "מרץ", "אפר", "מאי", "יונ", "יול", "אוג", "ספט", "אוק", "נוב", "דצמ"],
    monthText: 'חודש',
    secText: 'שניות',
    amText: 'am',
    pmText: 'pm',
    timeFormat: 'HH:ii',
    timeWheels: 'iiHH',
    // Need this for correct RTL display
    yearText: 'שנה',
    nowText: 'עכשיו',
    // Calendar component
    firstDay: 0,
    dateText: 'תאריך',
    timeText: 'זמן',
    closeText: 'סגירה',
    todayText: 'היום',
    allDayText: 'כל היום',
    noEventsText: 'אין אירועים',
    // Event calendar
    eventText: 'מִקרֶה',
    eventsText: 'מִקרֶה',
    moreEventsText: 'אירוע אחד נוסף',
    moreEventsPluralText: '{count} אירועים נוספים',
    // Daterange component
    fromText: 'התחלה',
    toText: 'סיום',
    // Measurement components
    wholeText: 'כֹּל',
    fractionText: 'שבריר',
    unitText: 'יחידה',
    // Time / Timespan component
    labels: ['שנים', 'חודשים', 'ימים', 'שעות', 'דקות', 'שניים', ''],
    labelsShort: ['שנים', 'חודשים', 'ימים', 'שעות', 'דקות', 'שניים', ''],
    // Timer component
    startText: 'התחל',
    stopText: 'עצור',
    resetText: 'אתחול',
    lapText: 'הקפה',
    hideText: 'הסתר',
    // Forms
    offText: 'כיבוי',
    onText: 'הפעלה',
    // Listview
    backText: 'חזור',
    undoText: 'ביטול פעולה'
  };

  // Hindi
  mobiscroll.i18n.hi = {
    // Core
    setText: 'सैट करें',
    cancelText: 'रद्द करें',
    clearText: 'साफ़ को',
    selectedText: '{count} चयनित',
    // Datetime component
    dateFormat: 'dd/mm/yy',
    dayNames: ['रविवार', 'सोमवार', 'मंगलवार', 'बुधवार', 'गुरुवार', 'शुक्रवार', 'शनिवार'],
    dayNamesShort: ['रवि', 'सोम', 'मंगल', 'बुध', 'गुरु', 'शुक्र', 'शनि'],
    dayNamesMin: ['रवि', 'सोम', 'मंगल', 'बुध', 'गुरु', 'शुक्र', 'शनि'],
    dayText: 'दिन',
    delimiter: '.',
    hourText: 'घंटा',
    minuteText: 'मिनट',
    monthNames: ['जनवरी ', 'फरवरी', 'मार्च', 'अप्रेल', 'मई', 'जून', 'जूलाई', 'अगस्त ', 'सितम्बर', 'अक्टूबर', 'नवम्बर', 'दिसम्बर'],
    monthNamesShort: ['जन', 'फर', 'मार्च', 'अप्रेल', 'मई', 'जून', 'जूलाई', 'अग', 'सित', 'अक्ट', 'नव', 'दि'],
    monthText: 'महीना',
    secText: 'सेकंड',
    timeFormat: 'H:ii',
    yearText: 'साल',
    nowText: 'अब',
    pmText: 'अपराह्न',
    amText: 'पूर्वाह्न',
    // Calendar component
    firstDay: 1,
    dateText: 'तिथि',
    timeText: 'समय',
    todayText: 'आज',
    prevMonthText: 'पिछ्ला महिना',
    nextMonthText: 'अगले महीने',
    prevYearText: 'पिछला साल',
    nextYearText: 'अगले वर्ष',
    closeText: 'बंद',
    eventText: 'इवेट३',
    eventsText: 'इवेट३',
    allDayText: 'पूरे दिन',
    noEventsText: 'Ei tapahtumia',
    moreEventsText: '{count} और',
    // Daterange component
    fromText: 'से',
    toText: 'तक',
    // Measurement components
    wholeText: 'समूचा',
    fractionText: 'अंश',
    unitText: 'इकाई',
    // Time / Timespan component
    labels: ['साल', 'महीने', 'दिन', 'घंटे', 'मिनट', 'सेकंड', ''],
    labelsShort: ['साल', 'महीने', 'दिन', 'घंटे', 'मिनट', 'सेकंड', ''],
    // Timer component
    startText: 'प्रारंभ',
    stopText: 'रोकें',
    resetText: 'रीसेट करें',
    lapText: 'लैप',
    hideText: 'छिपाना',
    // Listview
    backText: 'वापस',
    // check
    undoText: 'वापस लाएं',
    // Form
    offText: 'बंद',
    onText: 'चालू',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Croatian
  mobiscroll.i18n.hr = {
    // Core
    setText: 'Postavi',
    cancelText: 'Izlaz',
    clearText: 'Izbriši',
    selectedText: '{count} odabran',
    // Datetime component
    dateFormat: 'dd.mm.yy',
    dayNames: ['Nedjelja', 'Ponedjeljak', 'Utorak', 'Srijeda', 'Četvrtak', 'Petak', 'Subota'],
    dayNamesShort: ['Ned', 'Pon', 'Uto', 'Sri', 'Čet', 'Pet', 'Sub'],
    dayNamesMin: ['Ne', 'Po', 'Ut', 'Sr', 'Če', 'Pe', 'Su'],
    dayText: 'Dan',
    delimiter: '.',
    hourText: 'Sat',
    minuteText: 'Minuta',
    monthNames: ['Siječanj', 'Veljača', 'Ožujak', 'Travanj', 'Svibanj', 'Lipanj', 'Srpanj', 'Kolovoz', 'Rujan', 'Listopad', 'Studeni', 'Prosinac'],
    monthNamesShort: ['Sij', 'Velj', 'Ožu', 'Tra', 'Svi', 'Lip', 'Srp', 'Kol', 'Ruj', 'Lis', 'Stu', 'Pro'],
    monthText: 'Mjesec',
    secText: 'Sekunda',
    timeFormat: 'H:ii',
    yearText: 'Godina',
    nowText: 'Sada',
    pmText: 'pm',
    amText: 'am',
    // Calendar component
    firstDay: 1,
    dateText: 'Datum',
    timeText: 'Vrijeme',
    todayText: 'Danas',
    prevMonthText: 'Prethodni mjesec',
    nextMonthText: 'Sljedeći mjesec',
    prevYearText: 'Prethodni godina',
    nextYearText: 'Slijedeće godine',
    closeText: 'Zatvori',
    eventText: 'Događaj',
    eventsText: 'događaja',
    allDayText: 'Cijeli dan',
    noEventsText: 'Bez događaja',
    moreEventsText: 'Još {count}',
    // Daterange component
    fromText: 'Počinje',
    toText: 'Završava',
    // Measurement components
    wholeText: 'Cjelina',
    fractionText: 'Frakcija',
    unitText: 'Jedinica',
    // Time / Timespan component
    labels: ['godina', 'mjesec', 'dan', 'sat', 'minuta', 'sekunda', ''],
    labelsShort: ['god', 'mje', 'dan', 'sat', 'min', 'sec', ''],
    // Timer component
    startText: 'Početak',
    stopText: 'Prekid',
    resetText: 'Resetiraj',
    lapText: 'Ciklus',
    hideText: 'Sakriti',
    // Listview
    backText: 'Natrag',
    undoText: 'Poništavanje',
    // Form
    offText: 'Uklj.',
    onText: 'Isklj.',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Magyar
  mobiscroll.i18n.hu = {
    // Core
    setText: 'OK',
    cancelText: 'Mégse',
    clearText: 'Törlés',
    selectedText: '{count} kiválasztva',
    // Datetime component
    dateFormat: 'yy.mm.dd.',
    dayNames: ['Vasárnap', 'Hétfő', 'Kedd', 'Szerda', 'Csütörtök', 'Péntek', 'Szombat'],
    dayNamesShort: ['Va', 'Hé', 'Ke', 'Sze', 'Csü', 'Pé', 'Szo'],
    dayNamesMin: ['V', 'H', 'K', 'Sz', 'Cs', 'P', 'Sz'],
    dayText: 'Nap',
    delimiter: '.',
    hourText: 'Óra',
    minuteText: 'Perc',
    monthNames: ['Január', 'Február', 'Március', 'Április', 'Május', 'Június', 'Július', 'Augusztus', 'Szeptember', 'Október', 'November', 'December'],
    monthNamesShort: ['Jan', 'Feb', 'Már', 'Ápr', 'Máj', 'Jún', 'Júl', 'Aug', 'Szep', 'Okt', 'Nov', 'Dec'],
    monthText: 'Hónap',
    secText: 'Másodperc',
    timeFormat: 'H:ii',
    yearText: 'Év',
    nowText: 'Most',
    pmText: 'pm',
    amText: 'am',
    // Calendar component
    firstDay: 1,
    dateText: 'Dátum',
    timeText: 'Idő',
    todayText: 'Ma',
    prevMonthText: 'Előző hónap',
    nextMonthText: 'Következő hónap',
    prevYearText: 'Előző év',
    nextYearText: 'Következő év',
    closeText: 'Bezár',
    eventText: 'esemény',
    eventsText: 'esemény',
    allDayText: 'Egész nap',
    noEventsText: 'Nincs esemény',
    moreEventsText: '{count} további',
    // Daterange component
    fromText: 'Eleje',
    toText: 'Vége',
    // Measurement components
    wholeText: 'Egész',
    fractionText: 'Tört',
    unitText: 'Egység',
    // Time / Timespan component
    labels: ['Év', 'Hónap', 'Nap', 'Óra', 'Perc', 'Másodperc', ''],
    labelsShort: ['Év', 'Hó.', 'Nap', 'Óra', 'Perc', 'Mp.', ''],
    // Timer component
    startText: 'Indít',
    stopText: 'Megállít',
    resetText: 'Visszaállít',
    lapText: 'Lap',
    hideText: 'Elrejt',
    // Listview
    backText: 'Vissza',
    undoText: 'Visszavon',
    // Form
    offText: 'Ki',
    onText: 'Be',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Italiano 
  mobiscroll.i18n.it = {
    // Core
    setText: 'OK',
    cancelText: 'Annulla',
    clearText: 'Chiarire',
    selectedText: '{count} selezionato',
    selectedPluralText: '{count} selezionati',
    // Datetime component
    dateFormat: 'dd/mm/yy',
    dayNames: ['Domenica', 'Lunedì', 'Martedì', 'Mercoledì', 'Giovedì', 'Venerdì', 'Sabato'],
    dayNamesShort: ['Do', 'Lu', 'Ma', 'Me', 'Gi', 'Ve', 'Sa'],
    dayNamesMin: ['D', 'L', 'M', 'M', 'G', 'V', 'S'],
    dayText: 'Giorno',
    hourText: 'Ore',
    minuteText: 'Minuti',
    monthNames: ['Gennaio', 'Febbraio', 'Marzo', 'Aprile', 'Maggio', 'Giugno', 'Luglio', 'Agosto', 'Settembre', 'Ottobre', 'Novembre', 'Dicembre'],
    monthNamesShort: ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'],
    monthText: 'Mese',
    secText: 'Secondi',
    timeFormat: 'HH:ii',
    yearText: 'Anno',
    nowText: 'Ora',
    pmText: 'pm',
    amText: 'am',
    todayText: 'Oggi',
    // Calendar component
    firstDay: 1,
    dateText: 'Data',
    timeText: 'Volta',
    closeText: 'Chiudere',
    allDayText: 'Tutto il giorno',
    noEventsText: 'Nessun evento',
    eventText: 'Evento',
    eventsText: 'Eventi',
    moreEventsText: '{count} altro',
    moreEventsPluralText: 'altri {count}',
    // Daterange component
    fromText: 'Inizio',
    toText: 'Fine',
    // Measurement components
    wholeText: 'Intero',
    fractionText: 'Frazione',
    unitText: 'Unità',
    // Time / Timespan component
    labels: ['Anni', 'Mesi', 'Giorni', 'Ore', 'Minuti', 'Secondi', ''],
    labelsShort: ['Anni', 'Mesi', 'Gio', 'Ore', 'Min', 'Sec', ''],
    // Timer component
    startText: 'Inizio',
    stopText: 'Arresto',
    resetText: 'Ripristina',
    lapText: 'Lap',
    hideText: 'Nascondi',
    // Listview
    backText: 'Indietro',
    undoText: 'Annulla',
    // Form
    offText: 'Via',
    onText: 'Su',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // 日本語 - Japanese
  mobiscroll.i18n.ja = {
    // Core
    setText: 'セット',
    cancelText: 'キャンセル',
    clearText: 'クリア',
    selectedText: '{count} 選択',
    // Datetime component
    dateFormat: 'yy年mm月dd日',
    dayNames: ['日', '月', '火', '水', '木', '金', '土'],
    dayNamesShort: ['日', '月', '火', '水', '木', '金', '土'],
    dayNamesMin: ['日', '月', '火', '水', '木', '金', '土'],
    dayText: '日',
    hourText: '時',
    minuteText: '分',
    monthNames: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'],
    monthNamesShort: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'],
    monthText: '月',
    secText: '秒',
    timeFormat: 'HH:ii',
    yearText: '年',
    nowText: '今',
    pmText: '午後',
    amText: '午前',
    yearSuffix: '年',
    monthSuffix: '月',
    daySuffix: '日',
    todayText: '今日',
    // Calendar component
    dateText: '日付',
    timeText: '時間',
    closeText: 'クローズ',
    allDayText: '終日',
    noEventsText: 'イベントはありません',
    eventText: 'イベント',
    eventsText: 'イベント',
    moreEventsText: '他 {count} 件',
    // Daterange component
    fromText: '開始',
    toText: '終わり',
    // Measurement components
    wholeText: '全数',
    fractionText: '分数',
    unitText: '単位',
    // Time / Timespan component
    labels: ['年間', '月間', '日間', '時間', '分', '秒', ''],
    labelsShort: ['年間', '月間', '日間', '時間', '分', '秒', ''],
    // Timer component
    startText: '開始',
    stopText: '停止',
    resetText: 'リセット',
    lapText: 'ラップ',
    hideText: '隠す',
    // Listview
    backText: 'バック',
    undoText: 'アンドゥ'
  };

  // Korean
  mobiscroll.i18n.ko = {
    // Core
    setText: '설정',
    cancelText: '취소',
    clearText: '삭제',
    selectedText: '{count} 선택된',
    // Datetime component
    dateFormat: 'yy년mm월dd일',
    dayNames: ['일요일', '월요일', '화요일', '수요일', '목요일', '금요일', '토요일'],
    dayNamesShort: ['일', '월', '화', '수', '목', '금', '토'],
    dayNamesMin: ['일', '월', '화', '수', '목', '금', '토'],
    dayText: '일',
    delimiter: '-',
    hourText: '시간',
    minuteText: '분',
    monthNames: ['1월', '2월', '3월', '4월', '5월', '6월', '7월', '8월', '9월', '10월', '11월', '12월'],
    monthNamesShort: ['1월', '2월', '3월', '4월', '5월', '6월', '7월', '8월', '9월', '10월', '11월', '12월'],
    monthText: '달',
    secText: '초',
    timeFormat: 'H:ii',
    yearText: '년',
    nowText: '지금',
    pmText: '오후',
    amText: '오전',
    yearSuffix: '년',
    monthSuffix: '월',
    daySuffix: '일',
    // Calendar component
    firstDay: 0,
    dateText: '날짜',
    timeText: '시간',
    todayText: '오늘',
    prevMonthText: '이전 달',
    nextMonthText: '다음 달',
    prevYearText: '이전 년',
    nextYearText: '다음 년',
    closeText: '닫기',
    eventText: '이벤트',
    eventsText: '이벤트',
    allDayText: '종일',
    noEventsText: '이벤트 없음',
    moreEventsText: '{count}개 더보기',
    // Daterange component
    fromText: '시작',
    toText: '종료',
    // Measurement components
    wholeText: '정수',
    fractionText: '분수',
    unitText: '단위',
    // Time / Timespan component
    labels: ['년', '달', '일', '시간', '분', '초', ''],
    labelsShort: ['년', '달', '일', '시간', '분', '초', ''],
    // Timer component
    startText: '시작',
    stopText: '중지 ',
    resetText: '초기화',
    lapText: '기록',
    hideText: '숨는 장소',
    // Listview
    backText: '뒤로',
    undoText: '실행취소',
    // Form
    offText: '끔',
    onText: '켬',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Lietuvių
  mobiscroll.i18n.lt = {
    // Core
    setText: 'OK',
    cancelText: 'Atšaukti',
    clearText: 'Išvalyti',
    selectedText: 'Pasirinktas {count}',
    selectedPluralText: 'Pasirinkti {count}',
    // Datetime component
    dateFormat: 'yy-mm-dd',
    dayNames: ['Sekmadienis', 'Pirmadienis', 'Antradienis', 'Trečiadienis', 'Ketvirtadienis', 'Penktadienis', 'Šeštadienis'],
    dayNamesShort: ['S', 'Pr', 'A', 'T', 'K', 'Pn', 'Š'],
    dayNamesMin: ['S', 'Pr', 'A', 'T', 'K', 'Pn', 'Š'],
    dayText: 'Diena',
    hourText: 'Valanda',
    minuteText: 'Minutes',
    monthNames: ['Sausis', 'Vasaris', 'Kovas', 'Balandis', 'Gegužė', 'Birželis', 'Liepa', 'Rugpjūtis', 'Rugsėjis', 'Spalis', 'Lapkritis', 'Gruodis'],
    monthNamesShort: ['Sau', 'Vas', 'Kov', 'Bal', 'Geg', 'Bir', 'Lie', 'Rugp', 'Rugs', 'Spa', 'Lap', 'Gruo'],
    monthText: 'Mėnuo',
    secText: 'Sekundes',
    amText: 'am',
    pmText: 'pm',
    timeFormat: 'HH:ii',
    yearText: 'Metai',
    nowText: 'Dabar',
    todayText: 'Šiandien',
    // Calendar component
    firstDay: 1,
    dateText: 'Data',
    timeText: 'Laikas',
    closeText: 'Uždaryti',
    allDayText: 'Visą dieną',
    noEventsText: 'Nėra įvykių',
    eventText: 'Įvykių',
    eventsText: 'Įvykiai',
    moreEventsText: 'Dar {count}',
    // Daterange component
    fromText: 'Nuo',
    toText: 'Iki',
    // Measurement components
    wholeText: 'Visas',
    fractionText: 'Frakcija',
    unitText: 'Vienetas',
    // Time / Timespan component
    labels: ['Metai', 'Mėnesiai', 'Dienos', 'Valandos', 'Minutes', 'Sekundes', ''],
    labelsShort: ['m', 'mėn.', 'd', 'h', 'min', 's', ''],
    // Timer component
    startText: 'Pradėti',
    stopText: 'Sustabdyti',
    resetText: 'Išnaujo',
    lapText: 'Ratas',
    hideText: 'Slėpti',
    // Listview
    backText: 'Atgal',
    undoText: 'Anuliuoti',
    // Form
    offText: 'Išj.',
    onText: 'Įj.',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Nederlands
  mobiscroll.i18n.nl = {
    // Core
    setText: 'Instellen',
    cancelText: 'Annuleren',
    clearText: 'Leegmaken',
    selectedText: '{count} gekozen',
    // Datetime component
    dateFormat: 'dd-mm-yy',
    dayNames: ['Zondag', 'Maandag', 'Dinsdag', 'Woensdag', 'Donderdag', 'Vrijdag', 'Zaterdag'],
    dayNamesShort: ['zo', 'ma', 'di', 'wo', 'do', 'vr', 'za'],
    dayNamesMin: ['z', 'm', 'd', 'w', 'd', 'v', 'z'],
    dayText: 'Dag',
    hourText: 'Uur',
    minuteText: 'Minuten',
    monthNames: ['januari', 'februari', 'maart', 'april', 'mei', 'juni', 'juli', 'augustus', 'september', 'oktober', 'november', 'december'],
    monthNamesShort: ['jan', 'feb', 'mrt', 'apr', 'mei', 'jun', 'jul', 'aug', 'sep', 'okt', 'nov', 'dec'],
    monthText: 'Maand',
    secText: 'Seconden',
    timeFormat: 'HH:ii',
    yearText: 'Jaar',
    nowText: 'Nu',
    pmText: 'pm',
    amText: 'am',
    todayText: 'Vandaag',
    // Calendar component
    firstDay: 1,
    dateText: 'Datum',
    timeText: 'Tijd',
    closeText: 'Sluiten',
    allDayText: 'Hele dag',
    noEventsText: 'Geen activiteiten',
    eventText: 'Activiteit',
    eventsText: 'Activiteiten',
    moreEventsText: 'nog {count}',
    // Daterange component
    fromText: 'Start',
    toText: 'Einde',
    // Measurement components
    wholeText: 'geheel',
    fractionText: 'fractie',
    unitText: 'eenheid',
    // Time / Timespan component
    labels: ['Jaren', 'Maanden', 'Dagen', 'Uren', 'Minuten', 'Seconden', ''],
    labelsShort: ['j', 'm', 'd', 'u', 'min', 'sec', ''],
    // Timer component
    startText: 'Start',
    stopText: 'Stop',
    resetText: 'Reset',
    lapText: 'Ronde',
    hideText: 'Verbergen',
    // Listview
    backText: 'Terug',
    undoText: 'Onged. maken',
    // Form
    offText: 'Uit',
    onText: 'Aan',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Norsk
  mobiscroll.i18n.no = {
    // Core
    setText: 'OK',
    cancelText: 'Avbryt',
    clearText: 'Tømme',
    selectedText: '{count} valgt',
    // Datetime component
    dateFormat: 'dd.mm.yy',
    dayNames: ['Søndag', 'Mandag', 'Tirsdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lørdag'],
    dayNamesShort: ['Sø', 'Ma', 'Ti', 'On', 'To', 'Fr', 'Lø'],
    dayNamesMin: ['S', 'M', 'T', 'O', 'T', 'F', 'L'],
    dayText: 'Dag',
    delimiter: '.',
    hourText: 'Time',
    minuteText: 'Minutt',
    monthNames: ['Januar', 'Februar', 'Mars', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Desember'],
    monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Des'],
    monthText: 'Måned',
    secText: 'Sekund',
    timeFormat: 'HH:ii',
    yearText: 'År',
    nowText: 'Nå',
    pmText: 'pm',
    amText: 'am',
    todayText: 'I dag',
    // Calendar component
    firstDay: 1,
    dateText: 'Dato',
    timeText: 'Tid',
    closeText: 'Lukk',
    allDayText: 'Hele dagen',
    noEventsText: 'Ingen hendelser',
    eventText: 'Hendelse',
    eventsText: 'Hendelser',
    moreEventsText: '{count} mere',
    // Daterange component
    fromText: 'Start',
    toText: 'End',
    // Measurement components
    wholeText: 'Hele',
    fractionText: 'Fraksjon',
    unitText: 'Enhet',
    // Time / Timespan component
    labels: ['År', 'Måneder', 'Dager', 'Timer', 'Minutter', 'Sekunder', ''],
    labelsShort: ['År', 'Mån', 'Dag', 'Time', 'Min', 'Sek', ''],
    // Timer component
    startText: 'Start',
    stopText: 'Stopp',
    resetText: 'Tilbakestille',
    lapText: 'Runde',
    hideText: 'Skjul',
    // Listview
    backText: 'Tilbake',
    undoText: 'Angre',
    // Form
    offText: 'Av',
    onText: 'På',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Polski
  mobiscroll.i18n.pl = {
    // Core
    setText: 'Zestaw',
    cancelText: 'Anuluj',
    clearText: 'Oczyścić',
    selectedText: 'Wybór: {count}',
    // Datetime component
    dateFormat: 'yy-mm-dd',
    dayNames: ['Niedziela', 'Poniedziałek', 'Wtorek', 'Środa', 'Czwartek', 'Piątek', 'Sobota'],
    dayNamesShort: ['Niedz.', 'Pon.', 'Wt.', 'Śr.', 'Czw.', 'Pt.', 'Sob.'],
    dayNamesMin: ['N', 'P', 'W', 'Ś', 'C', 'P', 'S'],
    dayText: 'Dzień',
    hourText: 'Godziny',
    minuteText: 'Minuty',
    monthNames: ['Styczeń', 'Luty', 'Marzec', 'Kwiecień', 'Maj', 'Czerwiec', 'Lipiec', 'Sierpień', 'Wrzesień', 'Październik', 'Listopad', 'Grudzień'],
    monthNamesShort: ['Sty', 'Lut', 'Mar', 'Kwi', 'Maj', 'Cze', 'Lip', 'Sie', 'Wrz', 'Paź', 'Lis', 'Gru'],
    monthText: 'Miesiąc',
    secText: 'Sekundy',
    timeFormat: 'HH:ii',
    yearText: 'Rok',
    nowText: 'Teraz',
    amText: 'am',
    pmText: 'pm',
    todayText: 'Dzisiaj',
    // Calendar component
    firstDay: 1,
    dateText: 'Data',
    timeText: 'Czas',
    closeText: 'Zakończenie',
    allDayText: 'Cały dzień',
    noEventsText: 'Brak wydarzeń',
    eventText: 'Wydarzeń',
    eventsText: 'Wydarzenia',
    moreEventsText: 'Jeszcze {count}',
    // Daterange component
    fromText: 'Rozpoczęcie',
    toText: 'Koniec',
    // Measurement components
    wholeText: 'Cały',
    fractionText: 'Ułamek',
    unitText: 'Jednostka',
    // Time / Timespan component
    labels: ['Lata', 'Miesiąc', 'Dni', 'Godziny', 'Minuty', 'Sekundy', ''],
    labelsShort: ['R', 'M', 'Dz', 'Godz', 'Min', 'Sek', ''],
    // Timer component
    startText: 'Rozpoczęcie',
    stopText: 'Zatrzymać',
    resetText: 'Zresetować',
    lapText: 'Zakładka',
    hideText: 'Ukryć',
    // Listview
    backText: 'Wróć',
    undoText: 'Cofnij',
    // Form
    offText: 'Wył',
    onText: 'Wł',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Português Brasileiro
  mobiscroll.i18n['pt-BR'] = {
    // Core
    setText: 'Selecionar',
    cancelText: 'Cancelar',
    clearText: 'Claro',
    selectedText: '{count} selecionado',
    selectedPluralText: '{count} selecionados',
    // Datetime component
    dateFormat: 'dd/mm/yy',
    dayNames: ['Domingo', 'Segunda-feira', 'Terça-feira', 'Quarta-feira', 'Quinta-feira', 'Sexta-feira', 'Sábado'],
    dayNamesShort: ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sáb'],
    dayNamesMin: ['D', 'S', 'T', 'Q', 'Q', 'S', 'S'],
    dayText: 'Dia',
    hourText: 'Hora',
    minuteText: 'Minutos',
    monthNames: ['Janeiro', 'Fevereiro', 'Março', 'Abril', 'Maio', 'Junho', 'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'],
    monthNamesShort: ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'],
    monthText: 'Mês',
    secText: 'Segundo',
    timeFormat: 'HH:ii',
    yearText: 'Ano',
    nowText: 'Agora',
    pmText: 'pm',
    amText: 'am',
    todayText: 'Hoje',
    // Calendar component
    dateText: 'Data',
    timeText: 'Tempo',
    closeText: 'Fechar',
    allDayText: 'Dia inteiro',
    noEventsText: 'Nenhum evento',
    eventText: 'Evento',
    eventsText: 'Eventos',
    moreEventsText: 'Mais {count}',
    // Daterange component
    fromText: 'In&iacute;cio',
    toText: 'Fim',
    // Measurement components
    wholeText: 'Inteiro',
    fractionText: 'Fração',
    unitText: 'Unidade',
    // Time / Timespan component
    labels: ['Anos', 'Meses', 'Dias', 'Horas', 'Minutos', 'Segundos', ''],
    labelsShort: ['Ano', 'M&ecirc;s', 'Dia', 'Hora', 'Min', 'Seg', ''],
    // Timer component
    startText: 'Começar',
    stopText: 'Pare',
    resetText: 'Reinicializar',
    lapText: 'Lap',
    hideText: 'Esconder',
    // Listview
    backText: 'Anterior',
    undoText: 'Desfazer',
    // Form
    offText: 'Desl',
    onText: 'Lig',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Português Europeu
  mobiscroll.i18n['pt-PT'] = {
    // Core
    setText: 'Seleccionar',
    cancelText: 'Cancelar',
    clearText: 'Claro',
    selectedText: '{count} selecionado',
    selectedPluralText: '{count} selecionados',
    // Datetime component
    dateFormat: 'dd-mm-yy',
    dayNames: ['Domingo', 'Segunda-feira', 'Terça-feira', 'Quarta-feira', 'Quinta-feira', 'Sexta-feira', 'Sábado'],
    dayNamesShort: ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sáb'],
    dayNamesMin: ['D', 'S', 'T', 'Q', 'Q', 'S', 'S'],
    dayText: 'Dia',
    hourText: 'Horas',
    minuteText: 'Minutos',
    monthNames: ['Janeiro', 'Fevereiro', 'Março', 'Abril', 'Maio', 'Junho', 'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'],
    monthNamesShort: ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'],
    monthText: 'Mês',
    secText: 'Segundo',
    timeFormat: 'HH:ii',
    yearText: 'Ano',
    nowText: 'Actualizar',
    pmText: 'pm',
    amText: 'am',
    todayText: 'Hoy',
    // Calendar component
    firstDay: 1,
    dateText: 'Data',
    timeText: 'Tempo',
    closeText: 'Fechar',
    allDayText: 'Todo o dia',
    noEventsText: 'Nenhum evento',
    eventText: 'Evento',
    eventsText: 'Eventos',
    moreEventsText: 'mais {count}',
    // Daterange component
    fromText: 'Início',
    toText: 'Fim',
    // Measurement components
    wholeText: 'Inteiro',
    fractionText: 'Fracção',
    unitText: 'Unidade',
    // Time / Timespan component
    labels: ['Anos', 'Meses', 'Dias', 'Horas', 'Minutos', 'Segundos', ''],
    labelsShort: ['Ano', 'Mês', 'Dia', 'Hora', 'Min', 'Seg', ''],
    // Timer component
    startText: 'Começar',
    stopText: 'Parar',
    resetText: 'Reinicializar',
    lapText: 'Lap',
    hideText: 'Esconder',
    // Listview
    backText: 'Anterior',
    undoText: 'Anular',
    // Form
    offText: 'Desl',
    onText: 'Lig',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Română
  mobiscroll.i18n.ro = {
    // Core
    setText: 'Setare',
    cancelText: 'Anulare',
    clearText: 'Ştergere',
    selectedText: '{count} selectat',
    selectedPluralText: '{count} selectate',
    // Datetime component
    dateFormat: 'dd.mm.yy',
    dayNames: ['Duminică', 'Luni', 'Marți', 'Miercuri', 'Joi', 'Vineri', 'Sâmbătă'],
    dayNamesShort: ['Du', 'Lu', 'Ma', 'Mi', 'Jo', 'Vi', 'Sâ'],
    dayNamesMin: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
    dayText: ' Ziua',
    delimiter: '.',
    hourText: ' Ore ',
    minuteText: 'Minute',
    monthNames: ['Ianuarie', 'Februarie', 'Martie', 'Aprilie', 'Mai', 'Iunie', 'Iulie', 'August', 'Septembrie', 'Octombrie', 'Noiembrie', 'Decembrie'],
    monthNamesShort: ['Ian.', 'Feb.', 'Mar.', 'Apr.', 'Mai', 'Iun.', 'Iul.', 'Aug.', 'Sept.', 'Oct.', 'Nov.', 'Dec.'],
    monthText: 'Luna',
    secText: 'Secunde',
    timeFormat: 'HH:ii',
    yearText: 'Anul',
    nowText: 'Acum',
    amText: 'am',
    pmText: 'pm',
    todayText: 'Astăzi',
    prevMonthText: 'Luna anterioară',
    nextMonthText: 'Luna următoare',
    prevYearText: 'Anul anterior',
    nextYearText: 'Anul următor',
    eventText: 'Eveniment',
    eventsText: 'Evenimente',
    allDayText: 'Toată ziua',
    noEventsText: 'Niciun eveniment',
    moreEventsText: 'Încă unul',
    moreEventsPluralText: 'Încă {count}',
    // Calendar component
    firstDay: 1,
    dateText: 'Data',
    timeText: 'Ora',
    closeText: 'Închidere',
    // Daterange component
    fromText: 'Start',
    toText: 'Final',
    // Measurement components
    wholeText: 'Complet',
    fractionText: 'Parţial',
    unitText: 'Unitate',
    // Time / Timespan component
    labels: ['Ani', 'Luni', 'Zile', 'Ore', 'Minute', 'Secunde', ''],
    labelsShort: ['Ani', 'Luni', 'Zile', 'Ore', 'Min.', 'Sec.', ''],
    // Timer component
    startText: 'Start',
    stopText: 'Stop',
    resetText: 'Resetare',
    lapText: 'Tură',
    hideText: 'Ascundere',
    // Listview
    backText: 'Înapoi',
    undoText: 'Anulează',
    // Form
    offText: 'Nu',
    onText: 'Da',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Русский (UA)
  mobiscroll.i18n['ru-UA'] = {
    // Core
    setText: 'Установить',
    cancelText: 'Отменить',
    clearText: 'Очиститьr',
    selectedText: '{count} Вібрать',
    // Datetime component
    dateFormat: 'dd.mm.yy',
    dayNames: ['воскресенье', 'понедельник', 'вторник', 'среда', 'четверг', 'пятница', 'суббота'],
    dayNamesShort: ['вс', 'пн', 'вт', 'ср', 'чт', 'пт', 'сб'],
    dayNamesMin: ['в', 'п', 'в', 'с', 'ч', 'п', 'с'],
    dayText: 'День',
    delimiter: '.',
    hourText: 'Часы',
    minuteText: 'Минуты',
    monthNames: ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'],
    monthNamesShort: ['Янв.', 'Февр.', 'Март', 'Апр.', 'Май', 'Июнь', 'Июль', 'Авг.', 'Сент.', 'Окт.', 'Нояб.', 'Дек.'],
    monthText: 'Месяцы',
    secText: 'Сикунды',
    timeFormat: 'HH:ii',
    yearText: 'Год',
    nowText: 'Сейчас',
    amText: 'am',
    pmText: 'pm',
    todayText: 'Cегодня',
    // Calendar component
    firstDay: 1,
    dateText: 'Дата',
    timeText: 'Время',
    closeText: 'Закрыть',
    allDayText: 'Весь день',
    noEventsText: 'Нет событий',
    eventText: 'Мероприятия',
    eventsText: 'Мероприятия',
    moreEventsText: 'Ещё {count}',
    // Daterange component
    fromText: 'Начало',
    toText: 'Конец',
    // Measurement components
    wholeText: 'Весь',
    fractionText: 'Часть',
    unitText: 'Единица',
    // Time / Timespan component
    labels: ['Годы', ' Месяцы ', ' Дни ', ' Часы ', ' Минуты ', ' Секунды', ''],
    labelsShort: ['Год', 'Мес.', 'Дн.', 'Ч.', 'Мин.', 'Сек.', ''],
    // Timer component
    startText: 'Старт',
    stopText: 'Стоп',
    resetText: ' Сброс ',
    lapText: ' Этап ',
    hideText: ' Скрыть ',
    // Listview
    backText: 'назад',
    undoText: 'ОтменитЬ',
    // Form
    offText: 'O',
    onText: 'I',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Русский
  mobiscroll.i18n['ru-RU'] = mobiscroll.i18n.ru = {
    // Core
    setText: 'Установить',
    cancelText: 'Отмена',
    clearText: 'Очистить',
    selectedText: '{count} Выбрать',
    // Datetime component
    dateFormat: 'dd.mm.yy',
    dayNames: ['воскресенье', 'понедельник', 'вторник', 'среда', 'четверг', 'пятница', 'суббота'],
    dayNamesShort: ['вс', 'пн', 'вт', 'ср', 'чт', 'пт', 'сб'],
    dayNamesMin: ['в', 'п', 'в', 'с', 'ч', 'п', 'с'],
    dayText: 'День',
    delimiter: '.',
    hourText: 'Час',
    minuteText: 'Минут',
    monthNames: ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'],
    monthNamesShort: ['Янв', 'Фев', 'Мар', 'Апр', 'Май', 'Июн', 'Июл', 'Авг', 'Сен', 'Окт', 'Ноя', 'Дек'],
    monthText: 'Месяц',
    secText: 'Секунд',
    timeFormat: 'HH:ii',
    yearText: 'Год',
    nowText: 'Сейчас',
    amText: 'am',
    pmText: 'pm',
    todayText: 'Cегодня',
    // Calendar component
    firstDay: 1,
    dateText: 'Дата',
    timeText: 'Время',
    closeText: 'Закрыть',
    allDayText: 'Весь день',
    noEventsText: 'Нет событий',
    eventText: 'Мероприятия',
    eventsText: 'Мероприятия',
    moreEventsText: 'Ещё {count}',
    // Daterange component
    fromText: 'Начало',
    toText: 'Конец',
    // Measurement components
    wholeText: 'Целое',
    fractionText: 'Дробное',
    unitText: 'Единица',
    // Time / Timespan component
    labels: ['Лет', 'Месяцев', 'Дней', 'Часов', 'Минут', 'Секунд', ''],
    labelsShort: ['Лет', 'Мес', 'Дн', 'Час', 'Мин', 'Сек', ''],
    // Timer component
    startText: 'Старт',
    stopText: 'Стоп',
    resetText: 'Сбросить',
    lapText: 'Круг',
    hideText: 'Скрыть',
    // Listview
    backText: 'назад',
    undoText: 'ОтменитЬ',
    // Form
    offText: 'O',
    onText: 'I',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Slovencina
  mobiscroll.i18n.sk = {
    // Core
    setText: 'Zadaj',
    cancelText: 'Zrušiť',
    clearText: 'Vymazať',
    selectedText: 'Označený: {count}',
    // Datetime component
    dateFormat: 'd.m.yy',
    dayNames: ['Nedeľa', 'Pondelok', 'Utorok', 'Streda', 'Štvrtok', 'Piatok', 'Sobota'],
    dayNamesShort: ['Ne', 'Po', 'Ut', 'St', 'Št', 'Pi', 'So'],
    dayNamesMin: ['N', 'P', 'U', 'S', 'Š', 'P', 'S'],
    dayText: 'Ďeň',
    hourText: 'Hodiny',
    minuteText: 'Minúty',
    monthNames: ['Január', 'Február', 'Marec', 'Apríl', 'Máj', 'Jún', 'Júl', 'August', 'September', 'Október', 'November', 'December'],
    monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Máj', 'Jún', 'Júl', 'Aug', 'Sep', 'Okt', 'Nov', 'Dec'],
    monthText: 'Mesiac',
    secText: 'Sekundy',
    timeFormat: 'H:ii',
    yearText: 'Rok',
    nowText: 'Teraz',
    amText: 'am',
    pmText: 'pm',
    todayText: 'Dnes',
    // Calendar component
    firstDay: 1,
    dateText: 'Datum',
    timeText: 'Čas',
    closeText: 'Zavrieť',
    allDayText: 'Celý deň',
    noEventsText: 'Žiadne udalosti',
    eventText: 'Udalostí',
    eventsText: 'Udalosti',
    moreEventsText: '{count} ďalšia',
    moreEventsPluralText: '{count} ďalšie',
    // Daterange component
    fromText: 'Začiatok',
    toText: 'Koniec',
    // Measurement components
    wholeText: 'Celý',
    fractionText: 'Časť',
    unitText: 'Jednotka',
    // Time / Timespan component
    labels: ['Roky', 'Mesiace', 'Dni', 'Hodiny', 'Minúty', 'Sekundy', ''],
    labelsShort: ['Rok', 'Mes', 'Dni', 'Hod', 'Min', 'Sec', ''],
    // Timer component
    startText: 'Start',
    stopText: 'Stop',
    resetText: 'Resetovať',
    lapText: 'Etapa',
    hideText: 'Schovať',
    // Listview
    backText: 'Späť',
    undoText: 'Späť',
    // Form
    offText: 'O',
    onText: 'I',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Serbian
  mobiscroll.i18n.sr = {
    // Core
    setText: 'Постави',
    cancelText: 'Откажи',
    clearText: 'Обриши',
    selectedText: '{count} изабрана',
    // Datetime component
    dateFormat: 'dd.mm.yy',
    dayNames: ['Недеља', 'Понедељак', 'Уторак', 'Среда', 'Четвртак', 'Петак', 'Субота'],
    dayNamesShort: ['Нед', 'Пон', 'Уто', 'Сре', 'Чет', 'Пет', 'Суб'],
    dayNamesMin: ['Не', 'По', 'Ут', 'Ср', 'Че', 'Пе', 'Су'],
    dayText: 'Дан',
    delimiter: '.',
    hourText: 'Час',
    minuteText: 'Минут',
    monthNames: ['Јануар', 'Фебруар', 'Март', 'Април', 'Мај', 'Јун', 'Јул', 'Август', 'Септембар', 'Октобар', 'Новембар', 'Децембар'],
    monthNamesShort: ['Јан', 'Феб', 'Мар', 'Апр', 'Мај', 'Јун', 'Јул', 'Авг', 'Сеп', 'Окт', 'Нов', 'Дец'],
    monthText: 'месец',
    secText: 'Секунд',
    timeFormat: 'H:ii',
    yearText: 'година',
    nowText: 'сада',
    pmText: 'pm',
    amText: 'am',
    // Calendar component
    firstDay: 1,
    dateText: 'Датум',
    timeText: 'време',
    todayText: 'Данас',
    prevMonthText: 'Претходни мјесец',
    nextMonthText: 'Следећег месеца',
    prevYearText: 'Претходна године',
    nextYearText: 'Следеће године',
    closeText: 'Затвори',
    eventText: 'Догађај',
    eventsText: 'Догађаји',
    allDayText: 'Цео дан',
    noEventsText: 'Нема догађаја',
    moreEventsText: 'Још {count}',
    // Daterange component
    fromText: 'Од',
    toText: 'До',
    // Measurement components
    wholeText: 'цео',
    fractionText: 'Фракција',
    unitText: 'единица',
    // Time / Timespan component
    labels: ['Године', 'Месеци', 'Дана', 'Сати', 'Минута', 'Секунди', ''],
    labelsShort: ['Год', 'Мес', 'Дана', 'Сати', 'Мину', 'Секу', ''],
    // Timer component
    startText: 'Започни',
    stopText: 'Стоп',
    resetText: 'Ресетуј',
    lapText: 'Круг',
    hideText: 'Сакрити',
    // Listview
    backText: 'Повратак',
    undoText: 'Опозови',
    // Form
    offText: 'нe',
    onText: 'да',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Svenska
  mobiscroll.i18n.sv = {
    // Core
    setText: 'OK',
    cancelText: 'Avbryt',
    clearText: 'Klara',
    selectedText: '{count} vald',
    // Datetime component
    dateFormat: 'yy-mm-dd',
    dayNames: ['Söndag', 'Måndag', 'Tisdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lördag'],
    dayNamesShort: ['Sö', 'Må', 'Ti', 'On', 'To', 'Fr', 'Lö'],
    dayNamesMin: ['S', 'M', 'T', 'O', 'T', 'F', 'L'],
    dayText: 'Dag',
    hourText: 'Timme',
    minuteText: 'Minut',
    monthNames: ['Januari', 'Februari', 'Mars', 'April', 'Maj', 'Juni', 'Juli', 'Augusti', 'September', 'Oktober', 'November', 'December'],
    monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Maj', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dec'],
    monthText: 'Månad',
    secText: 'Sekund',
    timeFormat: 'HH:ii',
    yearText: 'År',
    nowText: 'Nu',
    pmText: 'pm',
    amText: 'am',
    todayText: 'I dag',
    // Calendar component
    firstDay: 1,
    dateText: 'Datum',
    timeText: 'Tid',
    closeText: 'Stäng',
    allDayText: 'Heldag',
    noEventsText: 'Inga aktiviteter',
    eventText: 'Händelse',
    eventsText: 'Händelser',
    moreEventsText: '{count} till',
    // Daterange component
    fromText: 'Start',
    toText: 'Slut',
    // Measurement components
    wholeText: 'Hela',
    fractionText: 'Bråk',
    unitText: 'Enhet',
    // Time / Timespan component
    labels: ['År', 'Månader', 'Dagar', 'Timmar', 'Minuter', 'Sekunder', ''],
    labelsShort: ['År', 'Mån', 'Dag', 'Tim', 'Min', 'Sek', ''],
    // Timer component
    startText: 'Start',
    stopText: 'Stopp',
    resetText: 'Återställ',
    lapText: 'Varv',
    hideText: 'Dölj',
    // Listview
    backText: 'Tillbaka',
    undoText: 'Ångra',
    // Form
    offText: 'Av',
    onText: 'På'
  };

  // Thai
  mobiscroll.i18n.th = {
    // Core
    setText: 'ตั้งค่า',
    cancelText: 'ยกเลิก',
    clearText: 'ล้าง',
    selectedText: '{count} เลือก',
    // Datetime component
    dateFormat: "dd/mm/yy",
    dayNames: ["อาทิตย์", "จันทร์", "อังคาร", "พุธ", "พฤหัสบดี", "ศุกร์", "เสาร์"],
    dayNamesShort: ["อา.", "จ.", "อ.", "พ.", "พฤ.", "ศ.", "ส."],
    dayNamesMin: ["อา.", "จ.", "อ.", "พ.", "พฤ.", "ศ.", "ส."],
    dayText: 'วัน',
    delimiter: '.',
    hourText: 'ชั่วโมง',
    minuteText: 'นาที',
    monthNames: ["มกราคม", "กุมภาพันธ์", "มีนาคม", "เมษายน", "พฤษภาคม", "มิถุนายน", "กรกฎาคม", "สิงหาคม", "กันยายน", "ตุลาคม", "พฤศจิกายน", "ธันวาคม"],
    monthNamesShort: ["ม.ค.", "ก.พ.", "มี.ค.", "เม.ย.", "พ.ค.", "มิ.ย.", "ก.ค.", "ส.ค.", "ก.ย.", "ต.ค.", "พ.ย.", "ธ.ค."],
    monthText: 'เดือน',
    secText: 'วินาที',
    timeFormat: 'HH:ii',
    yearText: 'ปี',
    nowText: 'ตอนนี้',
    pmText: 'pm',
    amText: 'am',
    // Calendar component
    firstDay: 0,
    dateText: 'วัน',
    timeText: 'เวลา',
    today: "วันนี้",
    prevMonthText: 'เดือนก่อนหน้า',
    nextMonthText: 'เดือนถัดไป',
    prevYearText: 'ปีก่อนหน้า',
    nextYearText: 'ปีถัดไป',
    closeText: "ปิด",
    eventText: 'เหตุการณ์',
    eventsText: 'เหตุการณ์',
    allDayText: 'ตลอดวัน',
    noEventsText: 'ไม่มีกิจกรรม',
    moreEventsText: 'อีก {count} กิจกรรม',
    // Daterange component
    fromText: 'จาก',
    toText: 'ถึง',
    // Measurement components
    wholeText: 'ทั้งหมด',
    fractionText: 'เศษส่วน',
    unitText: 'หน่วย',
    // Time / Timespan component
    labels: ['ปี', 'เดือน', 'วัน', 'ชั่วโมง', 'นาที', 'วินาที', ''],
    labelsShort: ['ปี', 'เดือน', 'วัน', 'ชั่วโมง', 'นาที', 'วินาที', ''],
    // Timer component
    startText: 'เริ่ม',
    stopText: 'หยุด',
    resetText: 'รีเซ็ต',
    lapText: 'รอบ',
    hideText: 'ซ่อน',
    // Listview
    backText: 'ย้อนกลับ',
    undoText: 'เลิกทา',
    // Form
    offText: 'ปิด',
    onText: 'เปิด',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Türkçe
  mobiscroll.i18n.tr = {
    // Core
    setText: 'Seç',
    cancelText: 'İptal',
    clearText: 'Temizleyin',
    selectedText: '{count} seçilmiş',
    // Datetime component
    dateFormat: 'dd.mm.yy',
    dayNames: ['Pazar', 'Pazartesi', 'Salı', 'Çarşamba', 'Perşembe', 'Cuma', 'Cumartesi'],
    dayNamesShort: ['Paz', 'Pzt', 'Sal', 'Çar', 'Per', 'Cum', 'Cmt'],
    dayNamesMin: ['P', 'P', 'S', 'Ç', 'P', 'C', 'C'],
    dayText: 'Gün',
    delimiter: '.',
    hourText: 'Saat',
    minuteText: 'Dakika',
    monthNames: ['Ocak', 'Şubat', 'Mart', 'Nisan', 'Mayıs', 'Haziran', 'Temmuz', 'Ağustos', 'Eylül', 'Ekim', 'Kasım', 'Aralık'],
    monthNamesShort: ['Oca', 'Şub', 'Mar', 'Nis', 'May', 'Haz', 'Tem', 'Ağu', 'Eyl', 'Eki', 'Kas', 'Ara'],
    monthText: 'Ay',
    secText: 'Saniye',
    timeFormat: 'HH:ii',
    yearText: 'Yıl',
    nowText: 'Şimdi',
    pmText: 'pm',
    amText: 'am',
    todayText: 'Bugün',
    // Calendar component
    firstDay: 1,
    dateText: 'Tarih',
    timeText: 'Zaman',
    closeText: 'Kapatmak',
    allDayText: 'Tüm gün',
    noEventsText: 'Etkinlik Yok',
    eventText: 'Etkinlik',
    eventsText: 'Etkinlikler',
    moreEventsText: '{count} tane daha',
    // Daterange component
    fromText: 'Başla',
    toText: 'Son',
    // Measurement components
    wholeText: 'Tam',
    fractionText: 'Kesir',
    unitText: 'Birim',
    // Time / Timespan component
    labels: ['Yıl', 'Ay', 'Gün', 'Saat', 'Dakika', 'Saniye', ''],
    labelsShort: ['Yıl', 'Ay', 'Gün', 'Sa', 'Dak', 'Sn', ''],
    // Timer component
    startText: 'Başla',
    stopText: 'Durdur',
    resetText: 'Sıfırla',
    lapText: 'Tur',
    hideText: 'Gizle',
    // Listview
    backText: 'Geri',
    undoText: 'Geri Al',
    // Form
    offText: 'O',
    onText: 'I',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: '.'
  };

  // Ukrainian
  mobiscroll.i18n.ua = {
    // Core
    setText: 'встановити',
    cancelText: 'відміна',
    clearText: 'очистити',
    selectedText: '{count} вибрані',
    // Datetime component
    dateFormat: "dd.mm.yy",
    dayNames: ["неділя", "понеділок", "вівторок", "середа", "четвер", "п’ятниця", "субота"],
    dayNamesShort: ["нед", "пнд", "вів", "срд", "чтв", "птн", "сбт"],
    dayNamesMin: ["Нд", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"],
    dayText: 'День',
    delimiter: '.',
    hourText: 'година',
    minuteText: 'хвилина',
    monthNames: ["Січень", "Лютий", "Березень", "Квітень", "Травень", "Червень", "Липень", "Серпень", "Вересень", "Жовтень", "Листопад", "Грудень"],
    monthNamesShort: ["Січ", "Лют", "Бер", "Кві", "Тра", "Чер", "Лип", "Сер", "Вер", "Жов", "Лис", "Гру"],
    monthText: 'Місяць',
    secText: 'Секунд',
    timeFormat: 'H:ii',
    yearText: 'Рік',
    nowText: 'Зараз',
    pmText: 'pm',
    amText: 'am',
    // Calendar component
    firstDay: 1,
    dateText: 'дата',
    timeText: 'Час',
    todayText: 'Сьогодні',
    prevMonthText: 'Попередній місяць',
    nextMonthText: 'Наступного місяця',
    prevYearText: 'Попередній рік',
    nextYearText: 'Наступного року',
    closeText: "Закрити",
    eventText: 'подія',
    eventsText: 'події',
    allDayText: 'Увесь день',
    noEventsText: 'Жодної події',
    moreEventsText: 'та ще {count}',
    // Daterange component
    fromText: 'від',
    toText: 'кінець',
    // Measurement components
    wholeText: 'всі',
    fractionText: 'фракція',
    unitText: 'одиниця',
    // Time / Timespan component
    labels: ['Рік', 'Місяць', 'День', 'година', 'хвилина', 'Секунд', ''],
    labelsShort: ['Рік', 'Місяць', 'День', 'година', 'хвилина', 'Секунд', ''],
    // Timer component
    startText: 'Початок',
    stopText: 'СТОП',
    resetText: 'скинути',
    lapText: 'коло',
    hideText: 'сховати',
    // Listview
    backText: 'назад',
    undoText: 'відмінити',
    // Form
    offText: 'Вимикати',
    onText: 'Увімкнути',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Vietnamese 
  mobiscroll.i18n.vi = {
    // Core
    setText: 'Đặt',
    cancelText: 'Hủy bò',
    clearText: 'Xóa',
    selectedText: '{count} chọn',
    // Datetime component
    dateFormat: 'dd/mm/yy',
    dayNames: ['Chủ Nhật', 'Thứ Hai', 'Thứ Ba', 'Thứ Tư', 'Thứ Năm', 'Thứ Sáu', 'Thứ Bảy'],
    dayNamesShort: ['CN', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7'],
    dayNamesMin: ['CN', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7'],
    dayText: '',
    delimiter: '/',
    hourText: 'Giờ',
    minuteText: 'Phút',
    monthNames: ['Tháng Một', 'Tháng Hai', 'Tháng Ba', 'Tháng Tư', 'Tháng Năm', 'Tháng Sáu', 'Tháng Bảy', 'Tháng Tám', 'Tháng Chín', 'Tháng Mười', 'Tháng Mười Một', 'Tháng Mười Hai'],
    monthNamesShort: ['Tháng 1', 'Tháng 2', 'Tháng 3', 'Tháng 4', 'Tháng 5', 'Tháng 6', 'Tháng 7', 'Tháng 8', 'Tháng 9', 'Tháng 10', 'Tháng 11', 'Tháng 12'],
    monthText: 'Tháng',
    secText: 'Giây',
    timeFormat: 'H:ii',
    yearText: 'Năm',
    nowText: 'Bây giờ',
    pmText: 'pm',
    amText: 'am',
    // Calendar component
    firstDay: 0,
    dateText: 'Ngày',
    timeText: 'Hồi',
    todayText: 'Hôm nay',
    prevMonthText: 'Tháng trước',
    nextMonthText: 'Tháng tới',
    prevYearText: 'Măm trước',
    nextYearText: 'Năm tới',
    closeText: 'Đóng',
    eventText: 'Sự kiện',
    eventsText: 'Sự kiện',
    allDayText: 'Cả ngày',
    noEventsText: 'Không có sự kiện',
    moreEventsText: '{count} thẻ khác',
    // Daterange component
    fromText: 'Từ',
    toText: 'Tới',
    // Measurement components
    wholeText: 'Toàn thể',
    fractionText: 'Phân số',
    unitText: 'đơn vị',
    // Time / Timespan component
    labels: ['Năm', 'Tháng', 'Ngày', 'Giờ', 'Phút', 'Giây', ''],
    labelsShort: ['Năm', 'Tháng', 'Ngày', 'Giờ', 'Phút', 'Giây', ''],
    // Timer component
    startText: 'Bắt đầu',
    stopText: 'Dừng',
    resetText: 'Đặt lại',
    lapText: 'Vòng',
    hideText: 'Giấu',
    // Listview
    backText: 'Quay lại',
    undoText: 'Hoàn tác',
    // Form
    offText: 'Tất',
    onText: 'Bật',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Chinese
  mobiscroll.i18n.zh = {
    // Core
    setText: '确定',
    cancelText: '取消',
    clearText: '明确',
    selectedText: '{count} 选',
    // Datetime component
    dateFormat: 'yy年mm月d日',
    dayNames: ['周日', '周一', '周二', '周三', '周四', '周五', '周六'],
    dayNamesShort: ['日', '一', '二', '三', '四', '五', '六'],
    dayNamesMin: ['日', '一', '二', '三', '四', '五', '六'],
    dayText: '日',
    hourText: '时',
    minuteText: '分',
    monthNames: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'],
    monthNamesShort: ['一', '二', '三', '四', '五', '六', '七', '八', '九', '十', '十一', '十二'],
    monthText: '月',
    secText: '秒',
    timeFormat: 'HH:ii',
    yearText: '年',
    nowText: '当前',
    pmText: '下午',
    amText: '上午',
    yearSuffix: '年',
    monthSuffix: '月',
    daySuffix: '日',
    todayText: '今天',
    // Calendar component
    dateText: '日',
    timeText: '时间',
    closeText: '关闭',
    allDayText: '全天',
    noEventsText: '无事件',
    eventText: '活动',
    eventsText: '活动',
    moreEventsText: '他 {count} 件',
    // Daterange component
    fromText: '开始时间',
    toText: '结束时间',
    // Measurement components
    wholeText: '合计',
    fractionText: '分数',
    unitText: '单位',
    // Time / Timespan component
    labels: ['年', '月', '日', '小时', '分钟', '秒', ''],
    labelsShort: ['年', '月', '日', '点', '分', '秒', ''],
    // Timer component
    startText: '开始',
    stopText: '停止',
    resetText: '重置',
    lapText: '圈',
    hideText: '隐藏',
    // Listview
    backText: '返回',
    undoText: '复原',
    // Form
    offText: '关闭',
    onText: '开启',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  var themes$1 = mobiscroll.themes;
  themes$1.frame.bootstrap = {
    disabledClass: 'disabled',
    selectedClass: 'btn-primary',
    selectedTabClass: 'active',
    tabLink: true,
    todayClass: 'text-primary mbsc-cal-today',
    onMarkupInserted: function onMarkupInserted(ev) {
      var dw = $$1(ev.target),
          calTabs = $$1('.mbsc-cal-tabs', dw);
      $$1('.mbsc-fr-popup', dw).addClass('popover');
      $$1('.mbsc-fr-w', dw).addClass('popover-content');
      $$1('.mbsc-fr-hdr', dw).addClass('popover-title popover-header');
      $$1('.mbsc-fr-arr-i', dw).addClass('popover');
      $$1('.mbsc-fr-arr', dw).addClass('arrow');
      $$1('.mbsc-fr-btn', dw).addClass('btn btn-default btn-secondary');
      $$1('.mbsc-fr-btn-s .mbsc-fr-btn', dw).removeClass('btn-default btn-secondary').addClass('btn btn-primary'); // Calendar tabs

      calTabs.addClass('nav nav-tabs');
      calTabs.find('.mbsc-cal-tab').addClass('nav-item'); // 4.x

      calTabs.find('a').addClass('nav-link'); // 4.x

      calTabs.find('.mbsc-cal-tab.active .nav-link').addClass('active'); // 4.x
      // Calendar year/month selector

      $$1('.mbsc-cal-picker', dw).addClass('popover'); // Rangepicker start/end buttons

      $$1('.mbsc-range-btn', dw).addClass('btn btn-sm btn-small btn-default'); // Numpad 

      $$1('.mbsc-np-btn', dw).addClass('btn btn-default'); // Select filter

      $$1('.mbsc-sel-filter-cont', dw).removeClass('mbsc-input');
      $$1('.mbsc-sel-filter-input', dw).addClass('form-control');
    },
    onTabChange: function onTabChange(ev, inst) {
      $$1('.mbsc-cal-tabs .nav-link', inst._markup).removeClass('active');
      $$1('.mbsc-cal-tab.active .nav-link', inst._markup).addClass('active');
    },
    onPosition: function onPosition(ev) {
      setTimeout(function () {
        $$1('.mbsc-fr-bubble-top, .mbsc-fr-bubble-top .mbsc-fr-arr-i', ev.target).removeClass('bottom bs-popover-bottom').addClass('top bs-popover-top');
        $$1('.mbsc-fr-bubble-bottom, .mbsc-fr-bubble-bottom .mbsc-fr-arr-i', ev.target).removeClass('top bs-popover-top').addClass('bottom  bs-popover-bottom');
      }, 10);
    }
  };
  themes$1.scroller.bootstrap = extend$1({}, themes$1.frame.bootstrap, {
    dateDisplay: 'Mddyy',
    btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left5',
    // calendar
    btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right5',
    // calendar
    btnPlusClass: 'mbsc-ic mbsc-ic-arrow-down5 btn-light',
    // scroller
    btnMinusClass: 'mbsc-ic mbsc-ic-arrow-up5 btn-light',
    // scroller
    selectedLineHeight: true,
    onEventBubbleShow: function onEventBubbleShow(ev) {
      var evc = $$1(ev.eventList);
      $$1('.mbsc-cal-event-list', evc).addClass('list-group');
      $$1('.mbsc-cal-event', evc).addClass('list-group-item');
    }
  });
  themes$1.navigation.bootstrap = {
    wrapperClass: 'popover panel panel-default',
    groupClass: 'btn-group',
    activeClass: 'btn-primary',
    disabledClass: 'disabled',
    itemClass: 'btn btn-default'
  };
  themes$1.form.bootstrap = {};

  var themes$2 = mobiscroll.themes;
  themes$2.frame.ios = {
    display: 'bottom',
    // frame
    headerText: false,
    // frame
    btnWidth: false,
    // frame
    deleteIcon: 'ios-backspace',
    // numpad
    scroll3d: os != 'wp' && (os != 'android' || majorVersion > 7)
  };
  themes$2.scroller.ios = extend$1({}, themes$2.frame.ios, {
    rows: 5,
    // scroller
    height: 34,
    // scroller
    minWidth: 55,
    // scroller
    selectedLineHeight: true,
    // scroller
    selectedLineBorder: 1,
    // scroller
    showLabel: false,
    // scroller
    useShortLabels: true,
    // timespan/timer
    btnPlusClass: 'mbsc-ic mbsc-ic-arrow-down5',
    // scroller
    btnMinusClass: 'mbsc-ic mbsc-ic-arrow-up5',
    // scroller
    checkIcon: 'ion-ios7-checkmark-empty',
    // select
    filterClearIcon: 'ion-close-circled',
    // select
    dateDisplay: 'MMdyy',
    // date
    btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left5',
    // calendar
    btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right5' // calendar

  });
  themes$2.listview.ios = {
    leftArrowClass: 'mbsc-ic-ion-ios7-arrow-back',
    rightArrowClass: 'mbsc-ic-ion-ios7-arrow-forward'
  };
  themes$2.form.ios = {};

  function _addRipple($control, ev) {
    var x = getCoord(ev, 'X', true),
        y = getCoord(ev, 'Y', true),
        control = $control[0],
        rect = $control.offset(),
        left = x - rect.left,
        top = y - rect.top,
        width = Math.max(left, control.offsetWidth - left),
        height = Math.max(top, control.offsetHeight - top),
        size = 2 * Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));

    _removeRipple($ripple);

    $ripple = $$1('<span class="mbsc-ripple"></span>').css({
      backgroundColor: getComputedStyle(control).color,
      width: size,
      height: size,
      top: y - rect.top - size / 2,
      left: x - rect.left - size / 2
    }).appendTo($control);
    setTimeout(function () {
      $ripple.addClass('mbsc-ripple-scaled mbsc-ripple-visible');
    }, 10);
  }

  function _removeRipple($r) {
    setTimeout(function () {
      if ($r) {
        $r.removeClass('mbsc-ripple-visible');
        setTimeout(function () {
          $r.remove();
        }, 2000);
      }
    }, 100);
  }

  function initRipple($markup, selector, disabled, nohl) {
    var startX,
        startY,
        markup = $markup[0];

    function onStart(ev) {
      var target = closest(markup, ev.target, selector);

      if (target && testTouch(ev, target)) {
        startX = getCoord(ev, 'X');
        startY = getCoord(ev, 'Y');
        $active$1 = $$1(target);

        if (!$active$1.hasClass(disabled) && !$active$1.hasClass(nohl)) {
          _addRipple($active$1, ev);
        } else {
          $active$1 = null;
        }
      }
    }

    function onMove(ev) {
      if ($active$1 && Math.abs(getCoord(ev, 'X') - startX) > 9 || Math.abs(getCoord(ev, 'Y') - startY) > 9) {
        _removeRipple($ripple);

        $active$1 = null;
      }
    }

    function onEnd() {
      if ($active$1) {
        setTimeout(function () {
          _removeRipple($ripple);
        }, 100);
        $active$1 = null;
      }
    }

    if (markup) {
      if (markup.__mbscRippleOff) {
        markup.__mbscRippleOff();
      }

      listen(markup, 'touchstart', onStart, {
        passive: true
      });
      listen(markup, 'mousedown', onStart);
      listen(markup, 'touchmove', onMove, {
        passive: true
      });
      listen(markup, 'mousemove', onMove);
      listen(markup, 'touchend', onEnd);
      listen(markup, 'touchcancel', onEnd);
      listen(markup, 'mouseleave', onEnd);
      listen(markup, 'mouseup', onEnd);

      markup.__mbscRippleOff = function () {
        unlisten(markup, 'touchstart', onStart, {
          passive: true
        });
        unlisten(markup, 'mousedown', onStart);
        unlisten(markup, 'touchmove', onMove, {
          passive: true
        });
        unlisten(markup, 'mousemove', onMove);
        unlisten(markup, 'touchend', onEnd);
        unlisten(markup, 'touchcancel', onEnd);
        unlisten(markup, 'mouseleave', onEnd);
        unlisten(markup, 'mouseup', onEnd);
        delete markup.__mbscRippleOff;
      };
    }
  }

  var $active$1,
      $ripple,
      themes$3 = mobiscroll.themes;
  themes$3.frame.material = {
    headerText: false,
    btnWidth: false,
    deleteIcon: 'material-backspace',
    onMarkupReady: function onMarkupReady(ev) {
      initRipple($$1(ev.target), '.mbsc-fr-btn-e', 'mbsc-disabled', 'mbsc-fr-btn-nhl');
    }
  };
  themes$3.scroller.material = extend$1({}, themes$3.frame.material, {
    showLabel: false,
    selectedLineBorder: 2,
    weekDays: 'min',
    icon: {
      filled: 'material-star',
      empty: 'material-star-outline'
    },
    checkIcon: 'material-check',
    btnPlusClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-down',
    btnMinusClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-up',
    btnCalPrevClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-left',
    btnCalNextClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-right'
  });
  themes$3.listview.material = {
    leftArrowClass: 'mbsc-ic-material-keyboard-arrow-left',
    rightArrowClass: 'mbsc-ic-material-keyboard-arrow-right',
    onItemActivate: function onItemActivate(ev) {
      _addRipple($$1(ev.target), ev.domEvent);
    },
    onItemDeactivate: function onItemDeactivate() {
      _removeRipple($ripple);
    },
    onSlideStart: function onSlideStart(ev) {
      $$1('.mbsc-ripple', ev.target).remove();
    },
    onSortStart: function onSortStart(ev) {
      $$1('.mbsc-ripple', ev.target).remove();
    }
  };
  themes$3.navigation.material = {
    onInit: function onInit() {
      initRipple($$1(this), '.mbsc-ms-item.mbsc-btn-e', 'mbsc-disabled', 'mbsc-btn-nhl');
    },
    onMarkupInit: function onMarkupInit() {
      $$1('.mbsc-ripple', this).remove();
    },
    onDestroy: function onDestroy() {
      if (this.__mbscRippleOff) {
        this.__mbscRippleOff();
      }
    }
  };
  themes$3.form.material = {
    addRipple: function addRipple(elm, ev) {
      _addRipple(elm, ev);
    },
    removeRipple: function removeRipple() {
      _removeRipple($ripple);
    }
  };

  var themes$4 = mobiscroll.themes;
  themes$4.frame.windows = {
    headerText: false,
    deleteIcon: 'backspace4',
    //setIcon: 'material-check',
    //cancelIcon: 'material-close',
    //closeIcon: 'material-close',
    //clearIcon: 'material-close',
    //okIcon: 'material-check',
    //nowIcon: 'loop2',
    //startIcon: 'play3',
    //stopIcon: 'pause2',
    //resetIcon: 'stop2',
    //lapIcon: 'loop2',
    //btnWidth: false,
    btnReverse: true
  };
  themes$4.scroller.windows = extend$1({}, themes$4.frame.windows, {
    rows: 6,
    // scroller
    minWidth: 88,
    height: 44,
    btnPlusClass: 'mbsc-ic mbsc-ic-arrow-down5',
    btnMinusClass: 'mbsc-ic mbsc-ic-arrow-up5',
    checkIcon: 'material-check',
    dateDisplay: 'MMdyy',
    // date
    showLabel: false,
    showScrollArrows: true,
    btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left5',
    // calendar
    btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right5',
    // calendar
    dayNamesShort: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
    useShortLabels: true // timespan/timer

  });
  themes$4.form.windows = {};

  mobiscroll.customTheme('ios-dark', 'ios');

  mobiscroll.customTheme('material-dark', 'material');

  mobiscroll.customTheme('mobiscroll-dark', 'mobiscroll');

  mobiscroll.customTheme('windows-dark', 'windows');

  var themes$5 = mobiscroll.themes;
  var theme = 'mobiscroll';

  if (os == 'android') {
    theme = 'material';
  } else if (os == 'ios') {
    theme = 'ios';
  } else if (os == 'wp') {
    theme = 'windows';
  }

  $$1.each(themes$5.frame, function (key, settings) {
    // Stop at the first custom theme with the OS base theme
    if (theme && settings.baseTheme == theme && key != theme + '-dark') {
      mobiscroll.autoTheme = key;
      return false;
    } else if (key == theme) {
      mobiscroll.autoTheme = key;
    }
  });

  mobiscroll.customTheme('ios-gray', 'ios');
  mobiscroll.customTheme('material-indigo', 'material');
  mobiscroll.customTheme('mobiscroll-lime', 'mobiscroll');
  mobiscroll.customTheme('windows-yellow', 'windows');

  mobiscroll.apiKey = '4fba6218';
  mobiscroll.apiUrl = 'https://trial.mobiscroll.com/';
  mobiscroll.fw = 'angular';

  exports.MbscAccordion = MbscAccordion;
  exports.MbscAvatar = MbscAvatar;
  exports.MbscBottomNav = MbscBottomNav;
  exports.MbscButton = MbscButton;
  exports.MbscCalendar = MbscCalendar;
  exports.MbscCalendarComponent = MbscCalendarComponent;
  exports.MbscCalendarModule = MbscCalendarModule;
  exports.MbscCard = MbscCard;
  exports.MbscCardComponent = MbscCardComponent;
  exports.MbscCardContent = MbscCardContent;
  exports.MbscCardFooter = MbscCardFooter;
  exports.MbscCardHeader = MbscCardHeader;
  exports.MbscCardModule = MbscCardModule;
  exports.MbscCardSubtitle = MbscCardSubtitle;
  exports.MbscCardTitle = MbscCardTitle;
  exports.MbscCheckbox = MbscCheckbox;
  exports.MbscColor = MbscColor;
  exports.MbscColorComponent = MbscColorComponent;
  exports.MbscColorModule = MbscColorModule;
  exports.MbscDate = MbscDate;
  exports.MbscDateComponent = MbscDateComponent;
  exports.MbscDatetime = MbscDatetime;
  exports.MbscDatetimeComponent = MbscDatetimeComponent;
  exports.MbscDatetimeModule = MbscDatetimeModule;
  exports.MbscDistance = MbscDistance;
  exports.MbscDistanceComponent = MbscDistanceComponent;
  exports.MbscDropdown = MbscDropdown;
  exports.MbscEventcalendar = MbscEventcalendar;
  exports.MbscEventcalendarComponent = MbscEventcalendarComponent;
  exports.MbscEventcalendarModule = MbscEventcalendarModule;
  exports.MbscForce = MbscForce;
  exports.MbscForceComponent = MbscForceComponent;
  exports.MbscForm = MbscForm;
  exports.MbscFormGroup = MbscFormGroup;
  exports.MbscFormGroupContent = MbscFormGroupContent;
  exports.MbscFormGroupTitle = MbscFormGroupTitle;
  exports.MbscFormsModule = MbscFormsModule;
  exports.MbscHamburgerNav = MbscHamburgerNav;
  exports.MbscImage = MbscImage;
  exports.MbscImageComponent = MbscImageComponent;
  exports.MbscImageItem = MbscImageItem;
  exports.MbscImageModule = MbscImageModule;
  exports.MbscInput = MbscInput;
  exports.MbscInputModule = MbscInputModule;
  exports.MbscListview = MbscListview;
  exports.MbscListviewHeader = MbscListviewHeader;
  exports.MbscListviewItem = MbscListviewItem;
  exports.MbscListviewModule = MbscListviewModule;
  exports.MbscListviewSublist = MbscListviewSublist;
  exports.MbscMass = MbscMass;
  exports.MbscMassComponent = MbscMassComponent;
  exports.MbscMeasurement = MbscMeasurement;
  exports.MbscMeasurementComponent = MbscMeasurementComponent;
  exports.MbscMeasurementModule = MbscMeasurementModule;
  exports.MbscModule = MbscModule;
  exports.MbscNav = MbscNav;
  exports.MbscNavItem = MbscNavItem;
  exports.MbscNavigationModule = MbscNavigationModule;
  exports.MbscNote = MbscNote;
  exports.MbscNumber = MbscNumber;
  exports.MbscNumberComponent = MbscNumberComponent;
  exports.MbscNumberModule = MbscNumberModule;
  exports.MbscNumpad = MbscNumpad;
  exports.MbscNumpadComponent = MbscNumpadComponent;
  exports.MbscNumpadDate = MbscNumpadDate;
  exports.MbscNumpadDateComponent = MbscNumpadDateComponent;
  exports.MbscNumpadDecimal = MbscNumpadDecimal;
  exports.MbscNumpadDecimalComponent = MbscNumpadDecimalComponent;
  exports.MbscNumpadModule = MbscNumpadModule;
  exports.MbscNumpadTime = MbscNumpadTime;
  exports.MbscNumpadTimeComponent = MbscNumpadTimeComponent;
  exports.MbscNumpadTimespan = MbscNumpadTimespan;
  exports.MbscNumpadTimespanComponent = MbscNumpadTimespanComponent;
  exports.MbscOptionItem = MbscOptionItem;
  exports.MbscOptionlist = MbscOptionlist;
  exports.MbscOptionlistModule = MbscOptionlistModule;
  exports.MbscPage = MbscPage;
  exports.MbscPageModule = MbscPageModule;
  exports.MbscPopup = MbscPopup;
  exports.MbscPopupModule = MbscPopupModule;
  exports.MbscProgress = MbscProgress;
  exports.MbscRadio = MbscRadio;
  exports.MbscRadioGroup = MbscRadioGroup;
  exports.MbscRange = MbscRange;
  exports.MbscRangeComponent = MbscRangeComponent;
  exports.MbscRangeEndComponent = MbscRangeEndComponent;
  exports.MbscRangeModule = MbscRangeModule;
  exports.MbscRangeStartComponent = MbscRangeStartComponent;
  exports.MbscRating = MbscRating;
  exports.MbscRouterToken = MbscRouterToken;
  exports.MbscScrollView = MbscScrollView;
  exports.MbscScrollViewComponent = MbscScrollViewComponent;
  exports.MbscScrollViewItem = MbscScrollViewItem;
  exports.MbscScrollViewItemComponent = MbscScrollViewItemComponent;
  exports.MbscScrollViewModule = MbscScrollViewModule;
  exports.MbscScroller = MbscScroller;
  exports.MbscScrollerComponent = MbscScrollerComponent;
  exports.MbscScrollerModule = MbscScrollerModule;
  exports.MbscSegmented = MbscSegmented;
  exports.MbscSegmentedGroup = MbscSegmentedGroup;
  exports.MbscSelect = MbscSelect;
  exports.MbscSelectComponent = MbscSelectComponent;
  exports.MbscSelectModule = MbscSelectModule;
  exports.MbscSlider = MbscSlider;
  exports.MbscSpeed = MbscSpeed;
  exports.MbscSpeedComponent = MbscSpeedComponent;
  exports.MbscStepper = MbscStepper;
  exports.MbscSwitch = MbscSwitch;
  exports.MbscTabNav = MbscTabNav;
  exports.MbscTemperature = MbscTemperature;
  exports.MbscTemperatureComponent = MbscTemperatureComponent;
  exports.MbscTextarea = MbscTextarea;
  exports.MbscTime = MbscTime;
  exports.MbscTimeComponent = MbscTimeComponent;
  exports.MbscTimer = MbscTimer;
  exports.MbscTimerComponent = MbscTimerComponent;
  exports.MbscTimerModule = MbscTimerModule;
  exports.MbscTimespan = MbscTimespan;
  exports.MbscTimespanComponent = MbscTimespanComponent;
  exports.MbscTimespanModule = MbscTimespanModule;
  exports.MbscTreelist = MbscTreelist;
  exports.MbscTreelistComponent = MbscTreelistComponent;
  exports.MbscTreelistModule = MbscTreelistModule;
  exports.MbscWidget = MbscWidget;
  exports.mobiscroll = mobiscroll;
  exports.ɵa = MbscOptionsService;
  exports.ɵb = MbscInputService;
  exports.ɵba = MbscCalBaseModule;
  exports.ɵbb = MbscDatetimeBase;
  exports.ɵbc = MbscDatetimeBaseModule;
  exports.ɵbd = MbscNavItemBase;
  exports.ɵbe = MbscNavigationBase;
  exports.ɵbf = MbscNavigationBaseModule;
  exports.ɵbg = MbscNotifyItemService;
  exports.ɵbh = MbscScrollItemBase;
  exports.ɵbi = MbscScrollViewBase;
  exports.ɵbj = MbscScrollViewBaseModule;
  exports.ɵc = MbscListService;
  exports.ɵd = MbscBase;
  exports.ɵe = MbscValueBase;
  exports.ɵf = MbscCloneBase;
  exports.ɵg = MbscControlBase;
  exports.ɵh = MbscFrameBase;
  exports.ɵi = MbscScrollerBase;
  exports.ɵj = MbscBaseModule;
  exports.ɵk = MbscFrameBaseModule;
  exports.ɵl = MbscScrollerBaseModule;
  exports.ɵm = INPUT_TEMPLATE;
  exports.ɵn = MbscDateBase;
  exports.ɵo = MbscFormBase;
  exports.ɵp = MbscFormValueBase;
  exports.ɵq = MbscInputBase;
  exports.ɵr = MbscRadioService;
  exports.ɵs = MbscRadioGroupBase;
  exports.ɵt = MbscListviewService;
  exports.ɵu = MbscSublistService;
  exports.ɵv = MbscListitemService;
  exports.ɵw = MbscMeasurementBase;
  exports.ɵx = MbscMeasurementChild;
  exports.ɵy = MbscNumpadBase;
  exports.ɵz = MbscCalBase;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
